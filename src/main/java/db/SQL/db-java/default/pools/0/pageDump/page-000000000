/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/codeql-db/log/ext/javac-1.properties/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/codeql-db/log/ext/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/codeql-db/log/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/codeql-db/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/Users/burakyetistiren/Desktop/Users/burakyetistiren/Users/apple.awt.application.nameclassworlds.conffile.encodingUTF-8file.separatorftp.nonProxyHostsgit.branchgit.build.hostgit.build.timegit.build.user.emailgit.build.user.namegit.build.versiongit.closest.tag.commit.countgit.closest.tag.namegit.commit.author.timegit.commit.committer.timegit.commit.idgit.commit.id.abbrevgit.commit.id.describegit.commit.id.describe-shortgit.commit.message.fullgit.commit.message.shortgit.commit.timegit.commit.user.emailgit.commit.user.namegit.dirtygit.local.branch.aheadgit.local.branch.behindgit.remote.origin.urlgit.taggit.tagsgit.total.commit.countguice.disable.misplaced.annotation.checkhttp.nonProxyHostsjava.class.path/opt/homebrew/Cellar/maven/3.9.7/libexec/boot/plexus-classworlds-2.8.0.jarjava.class.version65.0java.home/Library/Java/JavaVirtualMachines/openlogic-openjdk-21.jdk/Contents/Homejava.io.tmpdir/var/folders/fg/w4tmrn0j6zl36ffgcnsyd26h0000gn/T/java.library.path/Users/burakyetistiren/Library/Java/Extensions:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java:.java.runtime.nameOpenJDK Runtime Environmentjava.runtime.version21.0.3+9-adhoc.admin.jdk21ujava.specification.nameJava Platform API Specificationjava.specification.vendorOracle Corporationjava.specification.version21java.vendor.url.bughttps://techsupport.roguewave.com/java.vendor.urlhttps://openlogic.com/java.vendor.versionOpenLogic-OpenJDKjava.vendorOpenLogicjava.version.date2024-04-16java.version21.0.3java.vm.compressedOopsModeZero basedjava.vm.infomixed mode, sharingjava.vm.nameOpenJDK 64-Bit Server VMjava.vm.specification.nameJava Virtual Machine Specificationjava.vm.specification.vendorjava.vm.specification.versionjava.vm.vendorjava.vm.versionjdk.debugreleaselibrary.jansi.pathline.separator
maven.confmaven.homemaven.multiModuleProjectDirectorynative.encodingos.archx86_64os.nameMac OS Xos.version14.1path.separator:socksNonProxyHostsstderr.encodingstdout.encodingsun.arch.data.model64sun.boot.library.path/Library/Java/JavaVirtualMachines/openlogic-openjdk-21.jdk/Contents/Home/libsun.cpu.endianlittlesun.io.unicode.encodingUnicodeBigsun.java.commandorg.codehaus.plexus.classworlds.launcher.Launcher clean compile -Pskip-licensesun.java.launcherSUN_STANDARDsun.jnu.encodingsun.management.compilerHotSpot 64-Bit Tiered Compilersuser.countryuser.diruser.homeuser.languageuser.nameuser.timezone/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/codeql-db/log/ext/javac.properties/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/format.xml

       Copyright 2009-2024 the original author or authors.

       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at

          https://www.apache.org/licenses/LICENSE-2.0

       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.

Format Dummy format file /Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/pom.xmlhttp://maven.apache.org/POM/4.0.0xsihttp://www.w3.org/2001/XMLSchema-instanceprojectschemaLocationhttps://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsdmodelVersion4.0.0parentgroupIdorg.mybatisartifactIdmybatis-parentversion44relativePathmybatis3.5.17-SNAPSHOTnamedescriptionThe MyBatis SQL mapper framework makes it easier to use a relational database with object-oriented
    applications. MyBatis couples objects with stored procedures or SQL statements using a XML descriptor or
    annotations. Simplicity is the biggest advantage of the MyBatis data mapper over object relational mapping
    tools.urlhttps://www.mybatis.org/mybatis-3/inceptionYear2009contributorscontributorAdam Gentemailadam.gent@evocatus.comAndrea Selvaselva.andre@gmail.comAntonio Sánchezjuntandolineas@gmail.comArkadi Shishlovarkadi.shishlov@gmail.comAxel Doerfleraxel.doerfler@gmail.comChris Dadejchris.dadej@gmail.comDenis Vygovskiyqizant@gmail.comFranta Mejtamejta@rewor.czJurriaan Pruysjurriaan@pruys.comKeith Wongwongkwl@gmail.comLasse Vosslasse.voss@motor-talk-gmbh.deLuke Stevensnosuchluke@gmail.comPaul Krausepaulkrause88@alum.mit.eduPeter Leibigerkuhnroyal@gmail.comRiccardo Cossuriccardo.cossu@gmail.comTomáš Neubergneuberg@m-atelier.czscmconnectionscm:git:ssh://git@github.com/mybatis/mybatis-3.gitdeveloperConnectiontagHEADhttps://github.com/mybatis/mybatis-3issueManagementsystemGitHub Issue Managementhttps://github.com/mybatis/mybatis-3/issuesciManagementGithubhttps://github.com/mybatis/mybatis-3/actionsdistributionManagementsiteidgh-pages-scmMybatis GitHub Pagespropertiesclirr.comparisonVersion3.4.6byte-buddy.version1.14.17derby.version10.17.1.0log4j.version2.23.1mockito.version5.12.0mssql-jdbc.version12.6.2.jre11testcontainers.version1.19.8 Add slow test groups here and annotate classes similar to @Tag('groupName').  Excluded groups are ran on github ci, to force here, pass -d"excludedGroups=" excludedGroupsTestcontainersTests Automatic Module Name module.name OSGI Data osgi.exportorg.apache.ibatis.*;version=${project.version};-noimport:=true,org.apache.ibatis.javassist.util.proxy;version=${project.version};-noimport:=trueosgi.import*;resolution:=optionalosgi.dynamicImport* Spotbugs Setup spotbugs.onlyAnalyzeorg.apache.ibatis.* Surefire Setup argLine-Xmx2048m -javaagent:${settings.localRepository}/net/bytebuddy/byte-buddy-agent/${byte-buddy.version}/byte-buddy-agent-${byte-buddy.version}.jar Reproducible Builds project.build.outputTimestamp1712079482dependenciesdependencyognl3.4.3scopecompileoptionaltrueorg.javassistjavassist3.30.2-GAcglib3.3.0 Test dependencies org.junit.jupiterjunit-jupiter-engine5.10.2testjunit-jupiter-paramsorg.hsqldbhsqldb2.7.3org.apache.derbyderby${derby.version}derbysharedderbyoptionaltoolscom.h2databaseh22.2.224org.mockitomockito-core${mockito.version}mockito-subclassmockito-junit-jupiterorg.apache.velocityvelocity-engine-core2.3 postgresql driver is required to run the refcursor tests org.postgresqlpostgresql42.7.3com.mysqlmysql-connector-j8.4.0org.assertjassertj-core3.26.0net.bytebuddybyte-buddy${byte-buddy.version}byte-buddy-agentcom.github.hazendaz.catch-exceptioncatch-exception2.3.2org.testcontainersjunit-jupiter${testcontainers.version}mysql For javadoc link com.microsoft.sqlservermssql-jdbc${mssql-jdbc.version}provided Logging Support ch.qos.reload4jreload4j1.2.25commons-logging1.3.2org.apache.logging.log4jlog4j-api${log4j.version}org.slf4jslf4j-api2.0.13 Logging Support used in testing ch.qos.logbacklogback-classic1.5.6log4j-corebuildpluginspluginorg.apache.maven.pluginsmaven-compiler-pluginconfigurationannotationProcessorPathspathmaven-surefire-pluginsystemPropertyVariablespropertyderby.stream.error.filevalue${project.build.directory}/derby.logderby.system.home${project.build.directory} Do not run pdf plugin as not compliant with site 2.0
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-pdf-plugin</artifactId>
      </plugin>
      maven-shade-pluginexecutionsexecutiongoalsgoalshadephasepackagecreateDependencyReducedPomfalsecreateSourcesJarartifactSetincludesincludeorg.mybatis:mybatisognl:ognlorg.javassist:javassistfiltersfilterartifactexcludesexcludeMETA-INF/MANIFEST.MFrelocationsrelocationpatternshadedPatternorg.apache.ibatis.ognlorg.apache.ibatis.javassistshadeSourcesContentmaven-site-pluginlocalesdefault,es,ja,fr,zh_CN,koorg.jacocojacoco-maven-pluginorg.apache.ibatis.ognl.*org.apache.ibatis.javassist.*profilesprofileskip-licenseactivationcom.mycilalicense-maven-pluginskippre16jdk(,16)10.15.2.012.4.2.jre8pluginManagementtestExcludestestExclude**/record_type/*.javanet.revelc.codeimpsort-maven-plugin16[16,)java.release.versionjava.test.versionjava.test.release.versionTestcontainersTests,RequireIllegalAccessallowed.build.jdks[11,12),[17,18),[21,22),[22,23),[23,24)17[17,)10.16.1.119[19,) We are manipulating the phase to run before package so shading will be used for building source jar
         and further turning off attach here as shading will do that.  This is required for ognl and javassist
         for IDE's usage maven-source-pluginattach-sourcesjar-no-forkprepare-packageattach/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/Arg.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/srcorg.apache.ibatis.annotationsjava.langClass<>/G/java.base/java/lang/Class.sig/G/java.base/java/lang/G/java.base/java/G/java.base/Gjava.lang.invokeOfField<>/CDEFGHIJK/java.base/java/lang/invoke/TypeDescriptor$OfField.sig/CDEFGHIJK/java.base/java/lang/invoke/CDEFGHIJK/java.base/java/lang/CDEFGHIJK/java.base/java/CDEFGHIJK/java.base/CDEFGHIJKpublicabstractstaticfinalClass<ConstructorArgs>?Class<?>OfField<Class<?>>ElementType[]lengthcloneclone()booleanorg.apache.ibatis.typeTypeHandler<>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/TypeHandler.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target? extends TypeHandler<>Class<? extends TypeHandler<>>Copyright 2009-2024 the original author or authors.Licensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License athttps://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.The annotation that specify a mapping definition for the constructor argument.@seeConstructorArgs@authorClinton BeginReturns whether id column or not.@return{@code true} if id column; {@code false} if otherwiseReturn the column name(or column label) to map to this argument.the column name(or column label)Return the java type for this argument.the java typeReturn the jdbc type for column that map to this argument.the jdbc typeReturns the {@link TypeHandler} type for retrieving a column value from result set.the {@link TypeHandler} typeReturn the statement id for retrieving a object that map to this argument.the statement idReturns the result map id for mapping to a object that map to this argument.the result map idReturns the parameter name for applying this mapping.the parameter name@sinceReturns the column prefix that use when applying {@link #resultMap()}.the column prefix3.5.0/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/AutomapConstructor.javaThe marker annotation that indicate a constructor for automatic mapping.<p><b>How to use:</b><pre>public class User {private int id;private String name;public User(int id) {this.id = id;}&#064;AutomapConstructorpublic User(int id, String name) {this.name = name;// ...</pre>Tim Chen/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/CacheNamespace.java? extends CacheClass<? extends Cache>longintProperty[] @formatter:offThe annotation that specify to use cache on namespace(e.g. mapper interface).&#064;CacheNamespace(implementation = CustomCache.class, properties = {&#064;Property(name = "host", value = "${mybatis.cache.host}"),&#064;Property(name = "port", value = "${mybatis.cache.port}"),&#064;Property(name = "name", value = "usersCache")})public interface UserMapper {Kazuki Shimizu @formatter:onReturns the cache implementation type to use.the cache implementation typeReturns the cache evicting implementation type to use.the cache evicting implementation typeReturns the flush interval.the flush intervalReturn the cache size.the cache sizeReturns whether use read/write cache.{@code true} if use read/write cache; {@code false} if otherwiseReturns whether block the cache at request time or not.{@code true} if block the cache; {@code false} if otherwiseReturns property values for a implementation object.property values3.4.2/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/CacheNamespaceRef.javaThe annotation that reference a cache.If you use this annotation, should be specified either {@link #value()} or {@link #name()} attribute.&#064;CacheNamespaceRef(UserMapper.class)public interface AdminUserMapper {Returns the namespace type to reference a cache (the namespace name become a FQCN of specified type).the namespace type to reference a cacheReturns the namespace name to reference a cache.the namespace name/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/Case.javaResult[]Arg[]The annotation that conditional mapping definition for {@link TypeDiscriminator}.TypeDiscriminatorResultArgResultsReturn the condition value to apply this mapping.the condition valueReturn the object type that create a object using this mapping.the object typeReturn mapping definitions for property.mapping definitions for propertyReturn mapping definitions for constructor.mapping definitions for constructor/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/ConstructorArgs.javaThe annotation that be grouping mapping definitions for constructor.&#064;ConstructorArgs({&#064;Arg(column = "id", javaType = int.class, id = true),&#064;Arg(column = "name", javaType = String.class),&#064;Arg(javaType = UserEmail.class, select = "selectUserEmailById", column = "id")&#064;Select("SELECT id, name FROM users WHERE id = #{id}")User selectById(int id);Returns mapping definitions for constructor.mapping definitions/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/Delete.javaClass<List>String[]Delete[]The annotation that specify an SQL for deleting record(s).&#064;Delete("DELETE FROM users WHERE id = #{id}")boolean deleteById(int id);Returns an SQL for deleting record(s).an SQL for deleting record(s)A database id that correspond this statement3.5.5The container annotation for {@link Delete}./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/DeleteProvider.javaDeleteProvider[]The annotation that specify a method that provide an SQL for deleting record(s).&#064;DeleteProvider(type = SqlProvider.class, method = "deleteById")public static class SqlProvider {public static String deleteById() {return "DELETE FROM users WHERE id = #{id}";Specify a type that implements an SQL provider method.a type that implements an SQL provider method3.5.2#type()This attribute is alias of {@link #value()}.</p>#value()Specify a method for providing an SQL.Since 3.5.1, this attribute can omit.If this attribute omit, the MyBatis will call a method that decide by following rules.<ul><li>If class that specified the {@link #type()} attribute implements the{@link org.apache.ibatis.builder.annotation.ProviderMethodResolver},the MyBatis use a method that returned by it</li>If cannot resolve a method by {@link org.apache.ibatis.builder.annotation.ProviderMethodResolver}(= not implement it or it was returned {@code null}),the MyBatis will search and use a fallback method that named {@code provideSql} from specified type</ul>a method name of method for providing an SQLA database id that correspond this providerThe container annotation for {@link DeleteProvider}./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/Flush.javaThe maker annotation that invoke a flush statements via Mapper interface.&#064;FlushList&lt;BatchResult&gt; flush();/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/Insert.javaInsert[]The annotation that specify an SQL for inserting record(s).&#064;Insert("INSERT INTO users (id, name) VALUES(#{id}, #{name})")void insert(User user);Returns an SQL for inserting record(s).an SQL for inserting record(s)The container annotation for {@link Insert}./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/InsertProvider.javaInsertProvider[]The annotation that specify a method that provide an SQL for inserting record(s).&#064;InsertProvider(type = SqlProvider.class, method = "insert")public static String insert() {return "INSERT INTO users (id, name) VALUES(#{id}, #{name})";The container annotation for {@link InsertProvider}./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/Lang.java? extends LanguageDriverClass<? extends LanguageDriver>The annotation that specify a {@link LanguageDriver} to use.&#064;Lang(MyXMLLanguageDriver.class)Returns the {@link LanguageDriver} implementation type to use.the {@link LanguageDriver} implementation type/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/Many.javaThe annotation that specify the nested statement for retrieving collections.Returns the columnPrefix.the columnPrefix.Returns the result map id used to map collection.Returns the statement id that retrieves collection.Returns the fetch strategy for nested statement.the fetch strategy/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/MapKey.javaThe annotation that specify the property name(or column name) for a key value of {@link java.util.Map}.&#064;MapKey("id")&#064;Select("SELECT id, name FROM users WHERE name LIKE #{name} || '%")Map&lt;Integer, User&gt; selectByStartingWithName(String name);Returns the property name(or column name) for a key value of {@link java.util.Map}.the property name(or column name)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/Mapper.javaMarker interface for MyBatis mappers.&#064;MapperFrank David Martínez Interface Mapper/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/One.javaThe annotation that specify the nested statement for retrieving single object.Returns the result map id used to map single object.Returns the statement id that retrieves single object./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/Options.javavoidFlushCachePolicyFlushCachePolicy()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/annotations/Options$FlushCachePolicy.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/annotationsprivate<clinit><clinit>()Options[]The annotation that specify options for customizing default behaviors.&#064;Options(useGeneratedKeys = true, keyProperty = "id")&#064;Insert("INSERT INTO users (name) VALUES(#{name})")boolean insert(User user);The options for the {@link Options#flushCache()}. The default is {@link FlushCachePolicy#DEFAULT}<code>false</code> for select statement; <code>true</code> for insert/update/delete statement.Flushes cache regardless of the statement type.Does not flush cache regardless of the statement type.Returns whether use the 2nd cache feature if assigned the cache.{@code true} if use; {@code false} if otherwiseReturns the 2nd cache flush strategy.the 2nd cache flush strategyReturns the result set type.the result set typeReturn the statement type.the statement typeReturns the fetch size.the fetch sizeReturns the statement timeout.the statement timeoutReturns whether use the generated keys feature supported by JDBC 3.0Returns property names that holds a key value.If you specify multiple property, please separate using comma(',').property names that separate with comma(',')Returns column names that retrieves a key value.If you specify multiple column, please separate using comma(',').column names that separate with comma(',')Returns result set names.If you specify multiple result set, please separate using comma(',').result set names that separate with comma(',')A database id that correspond this optionsThe container annotation for {@link Options}./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/Param.javaThe annotation that specify the parameter name.&#064;Select("SELECT id, name FROM users WHERE name = #{name}")User selectById(&#064;Param("name") String value);Returns the parameter name./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/Property.javaThe annotation that inject a property value.CacheNamespaceReturns the property name.the property nameReturns the property value or placeholder.the property value or placeholder/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/Result.javaClass<Results>The annotation that specify a mapping definition for the property.Returns the property name for applying this mapping.Returns the mapping definition for single relationship.the mapping definition for single relationshipReturns the mapping definition for collection relationship.the mapping definition for collection relationship/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/ResultMap.javaThe annotation that specify result map names to use.<b>How to use:</b><br>Mapper interface:&#064;ResultMap("userMap")&#064;Select("SELECT u.id, u.name FROM users u INNER JOIN users_email ue ON u.id = ue.id WHERE ue.email = #{email}")User selectByEmail(String email);Mapper XML:<pre>{@code<mapper namespace="com.example.mapper.UserMapper"><resultMap id="userMap" type="com.example.model.User"><id property="id" column="id" /><result property="name" column="name" /><association property="email" select="selectUserEmailById" column="id" fetchType="lazy"/></resultMap></mapper>Jeff ButlerReturns result map names to use.result map names/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/ResultType.javaThis annotation can be used when a @Select method is using a ResultHandler. Those methods must have void return type,so this annotation can be used to tell MyBatis what kind of object it should build for each row.&#064;ResultType(User.class)&#064;Select("SELECT id, name FROM users WHERE name LIKE #{name} || '%' ORDER BY id")void collectByStartingWithName(String name, ResultHandler&lt;User&gt; handler);3.2.0Returns the return type.the return type/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/Results.javaThe annotation that be grouping mapping definitions for property.&#064;Results({&#064;Result(property = "id", column = "id", id = true),&#064;Result(property = "name", column = "name"),&#064;Result(property = "email" column = "id", one = @One(select = "selectUserEmailById", fetchType = FetchType.LAZY)),&#064;Result(property = "telephoneNumbers" column = "id", many = @Many(select = "selectAllUserTelephoneNumberById", fetchType = FetchType.LAZY))Returns the id of this result map.the id of this result mapReturns mapping definitions for property./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/Select.javaSelect[]The annotation that specify an SQL for retrieving record(s).<li>Simple:@Select("SELECTid, name FROM users WHERE id = #{id}")}</pre><li>Dynamic SQL:@Select({"<script>", "select * from users", "where name = #{name}","<if test=\"age != null\"> age = #{age} </if>", "</script>" })User select(@NotNull String name, @Nullable Intger age);<a href="https://mybatis.org/mybatis-3/dynamic-sql.html">How to use Dynamic SQL</a>Returns an SQL for retrieving record(s).an SQL for retrieving record(s)Returns whether this select affects DB data.<br>e.g. RETURNING of PostgreSQL or OUTPUT of MS SQL Server.{@code true} if this select affects DB data; {@code false} if otherwise3.5.12The container annotation for {@link Select}./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/SelectKey.javaSelectKey[]The annotation that specify an SQL for retrieving a key value.&#064;SelectKey(statement = "SELECT identity('users')", keyProperty = "id", before = true, resultType = int.class)Returns an SQL for retrieving a key value.an SQL for retrieving a key valueReturns whether retrieves a key value before executing insert/update statement.{@code true} if execute before; {@code false} if otherwiseReturns the key value type.the key value typeReturns the statement type to use.A database id that correspond this select keyThe container annotation for {@link SelectKey}./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/SelectProvider.javaSelectProvider[]The annotation that specify a method that provide an SQL for retrieving record(s).&#064;SelectProvider(type = SqlProvider.class, method = "selectById")public static String selectById() {return "SELECT id, name FROM users WHERE id = #{id}";the MyBatis use a method that returned by it.If cannot resolve a method by {@link org.apache.ibatis.builder.annotation.ProviderMethodResolver}(= not implement it or it was returned <code>null</code>,the MyBatis will search and use a fallback method that named <code>provideSql</code> fromspecified type.The container annotation for {@link SelectProvider}./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/TypeDiscriminator.javaCase[]The annotation that be grouping conditional mapping definitions.&#064;Select("SELECT id, name, type FROM users ORDER BY id")&#064;TypeDiscriminator(column = "type",javaType = String.class,cases = {&#064;Case(value = "1", type = PremiumUser.class),&#064;Case(value = "2", type = GeneralUser.class),&#064;Case(value = "3", type = TemporaryUser.class))List&lt;User&gt; selectAll();Returns the column name(column label) that hold conditional value.the column name(column label)Return the java type for conditional value.Return the jdbc type for column that hold conditional value.Returns conditional mapping definitions.conditional mapping definitions/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/Update.javaUpdate[]The annotation that specify an SQL for updating record(s).&#064;Update("UPDATE users SET name = #{name} WHERE id = #{id}")boolean update(User user);Returns an SQL for updating record(s).an SQL for updating record(s)The container annotation for {@link Update}./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/UpdateProvider.javaUpdateProvider[]The annotation that specify a method that provide an SQL for updating record(s).&#064;UpdateProvider(type = SqlProvider.class, method = "update")public static String update() {return "UPDATE users SET name = #{name} WHERE id = #{id}";Since 3.5.1, this attribute can omit. If this attribute omit, the MyBatis will call a method that decide byfollowing rules.the MyBatis will search and use a fallback method that named <code>provideSql</code> from specified typeThe container annotation for {@link UpdateProvider}./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/annotations/package-info.javaContains all the annotation that are used in mapper interfaces./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/binding/BindingException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/bindingorg.apache.ibatis.bindingserialVersionUID/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/binding/BindingException.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/binding4300802238789381562L4300802238789381562messagecause/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/binding/MapperMethod.javaObject[]java.utilMap<>/BCDEFGHIJK/java.base/java/util/Map.sig/BCDEFGHIJK/java.base/java/util/BCDEFGHIJK/java.base/java/BCDEFGHIJK/java.base/BCDEFGHIJKK/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/binding/MapperMethod.classVMap<K,V>executeForMapexecuteForMap(org.apache.ibatis.session.SqlSession,java.lang.Object[])List<>/BCDEFGHIJK/java.base/java/util/List.sigCollection<>/BCDEFGHIJK/java.base/java/util/Collection.sigIterable<>/BCDEFGHIJK/java.base/java/lang/Iterable.sig/BCDEFGHIJK/java.base/java/langEconvertToArrayconvertToArray(java.util.List)List<E>Collection<E>Iterable<E>"unchecked"uncheckedconvertToDeclaredCollectionconvertToDeclaredCollection(org.apache.ibatis.session.Configuration,java.util.List)org.apache.ibatis.cursorCursor<>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cursor/Cursor.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cursorTCursor<T>Iterable<T>executeForCursorexecuteForCursor(org.apache.ibatis.session.SqlSession,java.lang.Object[])executeForManyexecuteForMany(org.apache.ibatis.session.SqlSession,java.lang.Object[])executeWithResultHandlerexecuteWithResultHandler(org.apache.ibatis.session.SqlSession,java.lang.Object[])rowCountResultrowCountResult(int)methodcommandmapperInterfaceconfigsqlSessionargsresultparam<nulltype>Map<Object,Object>Cursor<Object>Iterable<Object>? extends ObjectClass<? extends Object>Optional<Object>/GHIJK/java.base/java/util/Optional.sig/GHIJK/java.base/java/util/GHIJK/java.base/java/GHIJK/java.base/GHIJKOptional<>List<BatchResult>Collection<BatchResult>Iterable<BatchResult>"Unknown execution method for: "Unknown execution method for: isPrimitiveisPrimitive()nativearrayTypearrayType()componentTypecomponentType()isArrayisArray()Class[]Class<>[]Class<?>[]getPermittedSubclassesgetPermittedSubclasses()isHiddenisHidden()castcast(java.lang.Object)isRecordisRecord()RecordComponent[]getRecordComponentsgetRecordComponents()getModifiersgetModifiers()? super TClass<? super T>getSuperclassgetSuperclass()isInterfaceisInterface()isAssignableFromisAssignableFrom(java.lang.Class)isInstanceisInstance(java.lang.Object)isSealedisSealed()Optional<ClassDesc>describeConstabledescribeConstable()descriptorStringdescriptorString()getNestMembersgetNestMembers()isNestmateOfisNestmateOf(java.lang.Class)getNestHostgetNestHost()getResourcegetResource(java.lang.String)getResourceAsStreamgetResourceAsStream(java.lang.String)java.lang.reflectConstructor<>/BCDEFGHIJK/java.base/java/lang/reflect/Constructor.sig/BCDEFGHIJK/java.base/java/lang/reflectConstructor<T>getDeclaredConstructorgetDeclaredConstructor(java.lang.Class[])Constructor<?>getDeclaredMethodgetDeclaredMethod(java.lang.String,java.lang.Class[])getDeclaredFieldgetDeclaredField(java.lang.String)Constructor[]Constructor<>[]Constructor<?>[]getDeclaredConstructorsgetDeclaredConstructors()Method[]getDeclaredMethodsgetDeclaredMethods()Field[]getDeclaredFieldsgetDeclaredFields()getDeclaredClassesgetDeclaredClasses()getConstructorgetConstructor(java.lang.Class[])getMethodgetMethod(java.lang.String,java.lang.Class[])getFieldgetField(java.lang.String)getConstructorsgetConstructors()getMethodsgetMethods()getFieldsgetFields()getClassesgetClasses()getEnclosingClassgetEnclosingClass()getDeclaringClassgetDeclaringClass()getEnclosingConstructorgetEnclosingConstructor()getEnclosingMethodgetEnclosingMethod()getComponentTypegetComponentType()getPackageNamegetPackageName()getModulegetModule()getClassLoadergetClassLoader()newInstancenewInstance()forNameforName(java.lang.Module,java.lang.String)forName(java.lang.String,boolean,java.lang.ClassLoader)forName(java.lang.String)AnnotatedType[]getAnnotatedInterfacesgetAnnotatedInterfaces()getAnnotatedSuperclassgetAnnotatedSuperclass()Annotation[]getDeclaredAnnotationsgetDeclaredAnnotations()AA[]getDeclaredAnnotationsByTypegetDeclaredAnnotationsByType(java.lang.Class)Class<A>getDeclaredAnnotationgetDeclaredAnnotation(java.lang.Class)getAnnotationsgetAnnotations()getAnnotationsByTypegetAnnotationsByType(java.lang.Class)? extends AnnotationClass<? extends Annotation>isAnnotationPresentisAnnotationPresent(java.lang.Class)getAnnotationgetAnnotation(java.lang.Class)U? extends UClass<? extends U>asSubclassasSubclass(java.lang.Class)Class<U>T[]getEnumConstantsgetEnumConstants()isEnumisEnum()desiredAssertionStatusdesiredAssertionStatus()getProtectionDomaingetProtectionDomain()isMemberClassisMemberClass()isLocalClassisLocalClass()isAnonymousClassisAnonymousClass()getCanonicalNamegetCanonicalName()getTypeNamegetTypeName()getSimpleNamegetSimpleName()getSignersgetSigners()Type[]getGenericInterfacesgetGenericInterfaces()getInterfacesgetInterfaces()getPackagegetPackage()getGenericSuperclassgetGenericSuperclass()TypeVariable[]TypeVariable<>/BCDEFGHIJK/java.base/java/lang/reflect/TypeVariable.sigTypeVariable<>[]TypeVariable<Class>TypeVariable<Class>[]getTypeParametersgetTypeParameters()TypeVariable<Class<?>>TypeVariable<Class<?>>[]getNamegetName()isSyntheticisSynthetic()isAnnotationisAnnotation()toGenericStringtoGenericString()toStringtoString()"Mapper method '"Mapper method '"' attempted to return null from a method with a primitive return type ("' attempted to return null from a method with a primitive return type (").").rowCountClass<Integer>Class<Long>Class<Boolean>0"' has an unsupported return type: "' has an unsupported return type: msEnum<StatementType>/CDEFGH/java.base/java/lang/Enum.sig/CDEFGH/java.base/java/lang/CDEFGH/java.base/java/CDEFGH/java.base/CDEFGHComparable<StatementType>/BCDEFGHIJK/java.base/java/lang/Comparable.sigequalsequals(java.lang.Object)compareTocompareTo(java.lang.Object)compareTo(org.apache.ibatis.mapping.StatementType)EnumDesc<E>/CDEFGHIJK/java.base/java/lang/Enum$EnumDesc.sigjava.lang.constantDynamicConstantDesc<E>/DEFG/java.base/java/lang/constant/DynamicConstantDesc.sig/DEFG/java.base/java/lang/constant/DEFG/java.base/java/lang/DEFG/java.base/java/DEFG/java.base/DEFGOptional<EnumDesc<E>>EnumDesc<StatementType>DynamicConstantDesc<StatementType>Optional<EnumDesc<StatementType>>finalizefinalize()protectedEnum<>Comparable<>Enum<T>Comparable<T>valueOfvalueOf(java.lang.Class,java.lang.String)Class<T>Class<E>Class<StatementType>compareTo(java.lang.Enum)hashCodehashCode()EnumEnum(java.lang.String,int)Enum<StatementType>(java.lang.String,int)ordinalordinal()name()Class<Void>List<ResultMap>Collection<ResultMap>Iterable<ResultMap>getget(int)Spliterator<>/BCDEFGHIJK/java.base/java/util/Spliterator.sigSpliterator<T>spliteratorspliterator()defaultSpliterator<ResultMap>java.util.functionConsumer<? super T>/G/java.base/java/util/function/Consumer.sig/G/java.base/java/util/function/G/java.base/java/utilforEachforEach(java.util.function.Consumer)? super ResultMapConsumer<? super ResultMap>Iterator<>/BCDEFGHIJK/java.base/java/util/Iterator.sigIterator<T>iteratoriterator()Iterator<ResultMap>IntFunction<>/BCDEFGHIJK/java.base/java/util/function/IntFunction.sig/BCDEFGHIJK/java.base/java/util/functiontoArraytoArray(java.util.function.IntFunction)IntFunction<T[]>java.util.streamStream<>/GHIJK/java.base/java/util/stream/Stream.sig/GHIJK/java.base/java/util/streamBaseStream<>/BCDEFGHIJK/java.base/java/util/stream/BaseStream.sig/BCDEFGHIJK/java.base/java/util/streamStream<E>BaseStream<E,Stream<E>>parallelStreamparallelStream()Stream<ResultMap>BaseStream<ResultMap,Stream<ResultMap>>streamstream()Spliterator<E>clearclear()Collection<?>Iterable<?>retainAllretainAll(java.util.Collection)? super EPredicate<? super E>/G/java.base/java/util/function/Predicate.sigremoveIfremoveIf(java.util.function.Predicate)Predicate<? super ResultMap>removeAllremoveAll(java.util.Collection)? extends ECollection<? extends E>Iterable<? extends E>addAlladdAll(java.util.Collection)? extends ResultMapCollection<? extends ResultMap>Iterable<? extends ResultMap>containsAllcontainsAll(java.util.Collection)removeremove(java.lang.Object)addadd(java.lang.Object)add(org.apache.ibatis.mapping.ResultMap)toArray(java.lang.Object[])toArray()Iterator<E>containscontains(java.lang.Object)isEmptyisEmpty()sizesize()copyOfcopyOf(java.util.Collection)ofof(java.lang.Object[])E[]of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object)of(java.lang.Object)of()subListsubList(int,int)ListIterator<>/BCDEFGHIJK/java.base/java/util/ListIterator.sigListIterator<E>listIteratorlistIterator(int)ListIterator<ResultMap>listIterator()lastIndexOflastIndexOf(java.lang.Object)indexOfindexOf(java.lang.Object)remove(int)add(int,java.lang.Object)add(int,org.apache.ibatis.mapping.ResultMap)setset(int,java.lang.Object)set(int,org.apache.ibatis.mapping.ResultMap)Comparator<? super E>/G/java.base/java/util/Comparator.sigsortsort(java.util.Comparator)Comparator<? super ResultMap>UnaryOperator<E>/G/java.base/java/util/function/UnaryOperator.sigFunction<E,E>/G/java.base/java/util/function/Function.sigreplaceAllreplaceAll(java.util.function.UnaryOperator)UnaryOperator<ResultMap>Function<ResultMap,ResultMap>addAll(int,java.util.Collection)"method "method " needs either a @ResultMap annotation, a @ResultType annotation,"
              + " or a resultType attribute in XML so a ResultHandler can be used as a parameter." needs either a @ResultMap annotation, a @ResultType annotation, or a resultType attribute in XML so a ResultHandler can be used as a parameter.rowBoundsorg.apache.ibatis.sessionResultHandler<>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/ResultHandler.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session? extends List<>Class<? extends List<>>listcollectionmetaObjectarrayComponentTypearrayConsumer<? super E>i/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/binding/MapperMethod$ParamMap.classHashMap<String,V>/89ABCDEFGH/java.base/java/util/HashMap.sig/89ABCDEFGH/java.base/java/util/89ABCDEFGH/java.base/java/89ABCDEFGH/java.base/89ABCDEFGHAbstractMap<String,V>/DEFGHIJK/java.base/java/util/AbstractMap.sig/DEFGHIJK/java.base/java/util/DEFGHIJK/java.base/java/DEFGHIJK/java.base/DEFGHIJKMap<String,V>2212268410512043556L2212268410512043556keycontainsKeycontainsKey(java.lang.Object)copyOf(java.util.Map)? extends K? extends VMap<? extends K,? extends V>Entry<>/BCDEFG/java.base/java/util/Map$Entry.sig/BCDEFG/java.base/java/util/BCDEFG/java.base/java/BCDEFG/java.base/BCDEFGEntry<K,V>entryentry(java.lang.Object,java.lang.Object)Entry[]Entry<>[]ofEntriesofEntries(java.util.Map.Entry[])Entry<? extends K,? extends V>Entry<? extends K,? extends V>[]of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)? super VBiFunction<? super V,? super V,? extends V>/G/java.base/java/util/function/BiFunction.sigmergemerge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)merge(java.lang.String,java.lang.Object,java.util.function.BiFunction)? super KBiFunction<? super K,? super V,? extends V>computecompute(java.lang.Object,java.util.function.BiFunction)? super StringBiFunction<? super String,? super V,? extends V>compute(java.lang.String,java.util.function.BiFunction)computeIfPresentcomputeIfPresent(java.lang.Object,java.util.function.BiFunction)computeIfPresent(java.lang.String,java.util.function.BiFunction)Function<? super K,? extends V>computeIfAbsentcomputeIfAbsent(java.lang.Object,java.util.function.Function)Function<? super String,? extends V>computeIfAbsent(java.lang.String,java.util.function.Function)replacereplace(java.lang.Object,java.lang.Object)replace(java.lang.String,java.lang.Object)replace(java.lang.Object,java.lang.Object,java.lang.Object)replace(java.lang.String,java.lang.Object,java.lang.Object)remove(java.lang.Object,java.lang.Object)putIfAbsentputIfAbsent(java.lang.Object,java.lang.Object)putIfAbsent(java.lang.String,java.lang.Object)replaceAll(java.util.function.BiFunction)BiConsumer<? super K,? super V>/G/java.base/java/util/function/BiConsumer.sigforEach(java.util.function.BiConsumer)BiConsumer<? super String,? super V>getOrDefaultgetOrDefault(java.lang.Object,java.lang.Object)Set<>/BCDEFGHIJK/java.base/java/util/Set.sigSet<Entry<K,V>>Collection<Entry<K,V>>Iterable<Entry<K,V>>entrySetentrySet()Entry<String,V>Set<Entry<String,V>>Collection<Entry<String,V>>Iterable<Entry<String,V>>Collection<V>Iterable<V>valuesvalues()Set<K>Collection<K>Iterable<K>keySetkeySet()Set<String>Collection<String>Iterable<String>putAllputAll(java.util.Map)? extends StringMap<? extends String,? extends V>putput(java.lang.Object,java.lang.Object)put(java.lang.String,java.lang.Object)get(java.lang.Object)containsValuecontainsValue(java.lang.Object)AbstractMapAbstractMap()AbstractMap<String,V>()HashMapHashMap(java.util.Map)HashMap<String,V>(java.util.Map)HashMap()HashMap<String,V>()HashMap(int)HashMap<String,V>(int)floatHashMap(int,float)HashMap<String,V>(int,float)"Parameter '"Parameter '"' not found. Available parameters are "' not found. Available parameters are resolveMappedStatementresolveMappedStatement(java.lang.Class,java.lang.String,java.lang.Class,org.apache.ibatis.session.Configuration)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/binding/MapperMethod$SqlCommand.classtypemethodNamedeclaringClassClass<Flush>"Invalid bound statement (not found): "Invalid bound statement (not found): ".".statementIdsuperInterfacegetMapKeygetMapKey(java.lang.reflect.Method)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/binding/MapperMethod$MethodSignature.classgetUniqueParamIndexgetUniqueParamIndex(java.lang.reflect.Method,java.lang.Class)paramNameResolverrowBoundsIndexresultHandlerIndexmapKeyreturnTypereturnsOptionalreturnsCursorreturnsVoidreturnsMapreturnsManyresolvedReturnTypeClass<Cursor<>>Class<Optional<>>Class<RowBounds>Class<ResultHandler<>>paramTypeindexargTypes" cannot have multiple " cannot have multiple " parameters" parametersClass<Map<>>? super Map<>Class<? super Map<>>Constructor<Map<>>Map[]Map<>[]TypeVariable<Class<Map<>>>TypeVariable<Class<Map<>>>[]mapKeyAnnotationClass<MapKey>Eduardo Macarron issue #510 Collections & arrays supportreturn whether return type is {@code java.util.Optional}.return {@code true}, if return type is {@code java.util.Optional}/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/binding/MapperProxy.javagetMethodHandleJava8getMethodHandleJava8(java.lang.reflect.Method)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/binding/MapperProxy.classgetMethodHandleJava9getMethodHandleJava9(java.lang.reflect.Method)cachedInvokercachedInvoker(java.lang.reflect.Method)Map<Method,MapperMethodInvoker>methodCacheprivateLookupInMethodConstructor<Lookup>lookupConstructorALLOWED_MODES4724728412955527868L4724728412955527868privateLookupInlookupClass<MethodHandles>? super MethodHandlesClass<? super MethodHandles>Constructor<MethodHandles>MethodHandles[]TypeVariable<Class<MethodHandles>>TypeVariable<Class<MethodHandles>>[]Class<Class<>>Class<Lookup>"privateLookupIn"e? super LookupClass<? super Lookup>Lookup[]TypeVariable<Class<Lookup>>TypeVariable<Class<Lookup>>[]setAccessiblesetAccessible(boolean)newInstance(java.lang.Object[])getAnnotatedReceiverTypegetAnnotatedReceiverType()getAnnotatedReturnTypegetAnnotatedReturnType()Annotation[][]getParameterAnnotationsgetParameterAnnotations()isVarArgsisVarArgs()getGenericExceptionTypesgetGenericExceptionTypes()getExceptionTypesgetExceptionTypes()getGenericParameterTypesgetGenericParameterTypes()getParameterCountgetParameterCount()getParameterTypesgetParameterTypes()TypeVariable<Constructor>TypeVariable<Constructor>[]TypeVariable<Constructor<Lookup>>TypeVariable<Constructor<Lookup>>[]"There is neither 'privateLookupIn(Class, Lookup)' nor 'Lookup(Class, int)' method in java.lang.invoke.MethodHandles."There is neither 'privateLookupIn(Class, Lookup)' nor 'Lookup(Class, int)' method in java.lang.invoke.MethodHandles.proxyClass<Object>tFunction<>Function<Method,MapperMethodInvoker>()Function<T,T>identityidentity()Function<T,V>andThenandThen(java.util.function.Function)? super RFunction<? super R,? extends V>Function<Method,V>? super MapperMethodInvokerFunction<? super MapperMethodInvoker,? extends V>Function<V,R>composecompose(java.util.function.Function)? extends TFunction<? super V,? extends T>Function<V,MapperMethodInvoker>? extends MethodFunction<? super V,? extends Method>applyapply(java.lang.Object)apply(java.lang.reflect.Method)mremapperMethod/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/binding/MapperProxy$PlainMethodInvoker.classmethodHandle/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/binding/MapperProxy$DefaultMethodInvoker.class JDK 1.8/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/binding/MapperProxyFactory.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/binding/MapperProxyFactory.class<obinit><obinit>()java.util.concurrentConcurrentHashMap<Method,MapperMethodInvoker>/DEFGHI/java.base/java/util/concurrent/ConcurrentHashMap.sig/DEFGHI/java.base/java/util/concurrent/DEFGHI/java.base/java/util/DEFGHI/java.base/java/DEFGHI/java.base/DEFGHIAbstractMap<Method,MapperMethodInvoker>ConcurrentMap<Method,MapperMethodInvoker>/G/java.base/java/util/concurrent/ConcurrentMap.sig/G/java.base/java/util/concurrentConcurrentHashMap<Method,MapperMethodInvoker>()? extends MapperMethodInvokerBiFunction<? super MapperMethodInvoker,? super MapperMethodInvoker,? extends MapperMethodInvoker>merge(java.lang.reflect.Method,org.apache.ibatis.binding.MapperProxy.MapperMethodInvoker,java.util.function.BiFunction)? super MethodBiFunction<? super Method,? super MapperMethodInvoker,? extends MapperMethodInvoker>compute(java.lang.reflect.Method,java.util.function.BiFunction)computeIfPresent(java.lang.reflect.Method,java.util.function.BiFunction)Function<? super Method,? extends MapperMethodInvoker>computeIfAbsent(java.lang.reflect.Method,java.util.function.Function)replace(java.lang.reflect.Method,org.apache.ibatis.binding.MapperProxy.MapperMethodInvoker)replace(java.lang.reflect.Method,org.apache.ibatis.binding.MapperProxy.MapperMethodInvoker,org.apache.ibatis.binding.MapperProxy.MapperMethodInvoker)putIfAbsent(java.lang.reflect.Method,org.apache.ibatis.binding.MapperProxy.MapperMethodInvoker)BiConsumer<? super Method,? super MapperMethodInvoker>getOrDefault(java.lang.Object,org.apache.ibatis.binding.MapperProxy.MapperMethodInvoker)Entry<Method,MapperMethodInvoker>Set<Entry<Method,MapperMethodInvoker>>Collection<Entry<Method,MapperMethodInvoker>>Iterable<Entry<Method,MapperMethodInvoker>>Collection<MapperMethodInvoker>Iterable<MapperMethodInvoker>Set<Method>Collection<Method>Iterable<Method>Map<? extends Method,? extends MapperMethodInvoker>put(java.lang.reflect.Method,org.apache.ibatis.binding.MapperProxy.MapperMethodInvoker)AbstractMap<Method,MapperMethodInvoker>()ToIntFunction<Entry<K,V>>/BCDEFGHIJK/java.base/java/util/function/ToIntFunction.sigreduceEntriesToIntreduceEntriesToInt(long,java.util.function.ToIntFunction,int,java.util.function.IntBinaryOperator)ToIntFunction<Entry<Method,MapperMethodInvoker>>ToLongFunction<Entry<K,V>>/BCDEFGHIJK/java.base/java/util/function/ToLongFunction.sigreduceEntriesToLongreduceEntriesToLong(long,java.util.function.ToLongFunction,long,java.util.function.LongBinaryOperator)ToLongFunction<Entry<Method,MapperMethodInvoker>>ToDoubleFunction<Entry<K,V>>/BCDEFGHIJK/java.base/java/util/function/ToDoubleFunction.sigdoublereduceEntriesToDoublereduceEntriesToDouble(long,java.util.function.ToDoubleFunction,double,java.util.function.DoubleBinaryOperator)ToDoubleFunction<Entry<Method,MapperMethodInvoker>>BiFunction<>reduceEntriesreduceEntries(long,java.util.function.Function,java.util.function.BiFunction)Function<Entry<K,V>,? extends U>? super UBiFunction<? super U,? super U,? extends U>Function<Entry<Method,MapperMethodInvoker>,? extends U>? extends Entry<K,V>BiFunction<Entry<K,V>,Entry<K,V>,? extends Entry<K,V>>reduceEntries(long,java.util.function.BiFunction)? extends Entry<Method,MapperMethodInvoker>BiFunction<Entry<Method,MapperMethodInvoker>,Entry<Method,MapperMethodInvoker>,? extends Entry<Method,MapperMethodInvoker>>searchEntriessearchEntries(long,java.util.function.Function)Consumer<>forEachEntryforEachEntry(long,java.util.function.Function,java.util.function.Consumer)Consumer<? super U>? super Entry<K,V>Consumer<? super Entry<K,V>>forEachEntry(long,java.util.function.Consumer)? super Entry<Method,MapperMethodInvoker>Consumer<? super Entry<Method,MapperMethodInvoker>>ToIntFunction<? super V>reduceValuesToIntreduceValuesToInt(long,java.util.function.ToIntFunction,int,java.util.function.IntBinaryOperator)ToIntFunction<? super MapperMethodInvoker>ToLongFunction<? super V>reduceValuesToLongreduceValuesToLong(long,java.util.function.ToLongFunction,long,java.util.function.LongBinaryOperator)ToLongFunction<? super MapperMethodInvoker>ToDoubleFunction<? super V>reduceValuesToDoublereduceValuesToDouble(long,java.util.function.ToDoubleFunction,double,java.util.function.DoubleBinaryOperator)ToDoubleFunction<? super MapperMethodInvoker>reduceValuesreduceValues(long,java.util.function.Function,java.util.function.BiFunction)Function<? super V,? extends U>Function<? super MapperMethodInvoker,? extends U>reduceValues(long,java.util.function.BiFunction)searchValuessearchValues(long,java.util.function.Function)forEachValueforEachValue(long,java.util.function.Function,java.util.function.Consumer)Consumer<? super V>forEachValue(long,java.util.function.Consumer)Consumer<? super MapperMethodInvoker>ToIntFunction<? super K>reduceKeysToIntreduceKeysToInt(long,java.util.function.ToIntFunction,int,java.util.function.IntBinaryOperator)ToIntFunction<? super Method>ToLongFunction<? super K>reduceKeysToLongreduceKeysToLong(long,java.util.function.ToLongFunction,long,java.util.function.LongBinaryOperator)ToLongFunction<? super Method>ToDoubleFunction<? super K>reduceKeysToDoublereduceKeysToDouble(long,java.util.function.ToDoubleFunction,double,java.util.function.DoubleBinaryOperator)ToDoubleFunction<? super Method>reduceKeysreduceKeys(long,java.util.function.Function,java.util.function.BiFunction)Function<? super K,? extends U>Function<? super Method,? extends U>BiFunction<? super K,? super K,? extends K>reduceKeys(long,java.util.function.BiFunction)BiFunction<? super Method,? super Method,? extends Method>searchKeyssearchKeys(long,java.util.function.Function)forEachKeyforEachKey(long,java.util.function.Function,java.util.function.Consumer)Consumer<? super K>forEachKey(long,java.util.function.Consumer)Consumer<? super Method>ToIntBiFunction<? super K,? super V>/BCDEFGHIJK/java.base/java/util/function/ToIntBiFunction.sigreduceToIntreduceToInt(long,java.util.function.ToIntBiFunction,int,java.util.function.IntBinaryOperator)ToIntBiFunction<? super Method,? super MapperMethodInvoker>ToLongBiFunction<? super K,? super V>/BCDEFGHIJK/java.base/java/util/function/ToLongBiFunction.sigreduceToLongreduceToLong(long,java.util.function.ToLongBiFunction,long,java.util.function.LongBinaryOperator)ToLongBiFunction<? super Method,? super MapperMethodInvoker>ToDoubleBiFunction<? super K,? super V>/BCDEFGHIJK/java.base/java/util/function/ToDoubleBiFunction.sigreduceToDoublereduceToDouble(long,java.util.function.ToDoubleBiFunction,double,java.util.function.DoubleBinaryOperator)ToDoubleBiFunction<? super Method,? super MapperMethodInvoker>reducereduce(long,java.util.function.BiFunction,java.util.function.BiFunction)BiFunction<? super K,? super V,? extends U>BiFunction<? super Method,? super MapperMethodInvoker,? extends U>searchsearch(long,java.util.function.BiFunction)forEach(long,java.util.function.BiFunction,java.util.function.Consumer)forEach(long,java.util.function.BiConsumer)KeySetView<>/DEFGHI/java.base/java/util/concurrent/ConcurrentHashMap$KeySetView.sigCollectionView<>/BCDEFGHI/java.base/java/util/concurrent/ConcurrentHashMap$CollectionView.sig/BCDEFGHI/java.base/java/util/concurrent/BCDEFGHI/java.base/java/util/BCDEFGHI/java.base/java/BCDEFGHI/java.base/BCDEFGHIKeySetView<K,V>CollectionView<K,V,K>keySet(java.lang.Object)KeySetView<Method,MapperMethodInvoker>CollectionView<Method,MapperMethodInvoker,Method>keySet(org.apache.ibatis.binding.MapperProxy.MapperMethodInvoker)KeySetView<K,Boolean>CollectionView<K,Boolean,K>newKeySetnewKeySet(int)newKeySet()mappingCountmappingCount()Enumeration<>/9ABCDEFGHIJK/java.base/java/util/Enumeration.sig/9ABCDEFGHIJK/java.base/java/util/9ABCDEFGHIJK/java.base/java/9ABCDEFGHIJK/java.base/9ABCDEFGHIJKEnumeration<V>elementselements()Enumeration<MapperMethodInvoker>Enumeration<K>keyskeys()Enumeration<Method>ConcurrentHashMapConcurrentHashMap(int,float,int)ConcurrentHashMap<Method,MapperMethodInvoker>(int,float,int)ConcurrentHashMap(int,float)ConcurrentHashMap<Method,MapperMethodInvoker>(int,float)ConcurrentHashMap(java.util.Map)ConcurrentHashMap<Method,MapperMethodInvoker>(java.util.Map)ConcurrentHashMap(int)ConcurrentHashMap<Method,MapperMethodInvoker>(int)ConcurrentHashMap()MapperProxy<T>mapperProxyTypeVariable<Class<T>>TypeVariable<Class<T>>[]MapperProxy<T>(org.apache.ibatis.session.SqlSession,java.lang.Class,java.util.Map)invokeinvoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object[])MapperProxyMapperProxy(org.apache.ibatis.session.SqlSession,java.lang.Class,java.util.Map)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/binding/MapperRegistry.javaMapperProxyFactory<?>Map<Class<?>,MapperProxyFactory<?>>knownMappers/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/binding/MapperRegistry.classConcurrentHashMap<Class<?>,MapperProxyFactory<?>>AbstractMap<Class<?>,MapperProxyFactory<?>>ConcurrentMap<Class<?>,MapperProxyFactory<?>>ConcurrentHashMap<Class<?>,MapperProxyFactory<?>>()? super MapperProxyFactory<?>? extends MapperProxyFactory<?>BiFunction<? super MapperProxyFactory<?>,? super MapperProxyFactory<?>,? extends MapperProxyFactory<?>>MapperProxyFactory<>merge(java.lang.Class,org.apache.ibatis.binding.MapperProxyFactory,java.util.function.BiFunction)? super Class<?>BiFunction<? super Class<?>,? super MapperProxyFactory<?>,? extends MapperProxyFactory<?>>compute(java.lang.Class,java.util.function.BiFunction)computeIfPresent(java.lang.Class,java.util.function.BiFunction)Function<? super Class<?>,? extends MapperProxyFactory<?>>computeIfAbsent(java.lang.Class,java.util.function.Function)replace(java.lang.Class,org.apache.ibatis.binding.MapperProxyFactory)replace(java.lang.Class,org.apache.ibatis.binding.MapperProxyFactory,org.apache.ibatis.binding.MapperProxyFactory)putIfAbsent(java.lang.Class,org.apache.ibatis.binding.MapperProxyFactory)BiConsumer<? super Class<?>,? super MapperProxyFactory<?>>getOrDefault(java.lang.Object,org.apache.ibatis.binding.MapperProxyFactory)Entry<Class<?>,MapperProxyFactory<?>>Set<Entry<Class<?>,MapperProxyFactory<?>>>Collection<Entry<Class<?>,MapperProxyFactory<?>>>Iterable<Entry<Class<?>,MapperProxyFactory<?>>>Collection<MapperProxyFactory<?>>Iterable<MapperProxyFactory<?>>Set<Class<?>>Collection<Class<?>>Iterable<Class<?>>? extends Class<?>Map<? extends Class<?>,? extends MapperProxyFactory<?>>put(java.lang.Class,org.apache.ibatis.binding.MapperProxyFactory)AbstractMap<Class<?>,MapperProxyFactory<?>>()ToIntFunction<Entry<Class<?>,MapperProxyFactory<?>>>ToLongFunction<Entry<Class<?>,MapperProxyFactory<?>>>ToDoubleFunction<Entry<Class<?>,MapperProxyFactory<?>>>Function<Entry<Class<?>,MapperProxyFactory<?>>,? extends U>? extends Entry<Class<?>,MapperProxyFactory<?>>BiFunction<Entry<Class<?>,MapperProxyFactory<?>>,Entry<Class<?>,MapperProxyFactory<?>>,? extends Entry<Class<?>,MapperProxyFactory<?>>>? super Entry<Class<?>,MapperProxyFactory<?>>Consumer<? super Entry<Class<?>,MapperProxyFactory<?>>>ToIntFunction<? super MapperProxyFactory<?>>ToLongFunction<? super MapperProxyFactory<?>>ToDoubleFunction<? super MapperProxyFactory<?>>Function<? super MapperProxyFactory<?>,? extends U>Consumer<? super MapperProxyFactory<?>>ToIntFunction<? super Class<?>>ToLongFunction<? super Class<?>>ToDoubleFunction<? super Class<?>>Function<? super Class<?>,? extends U>BiFunction<? super Class<?>,? super Class<?>,? extends Class<?>>Consumer<? super Class<?>>ToIntBiFunction<? super Class<?>,? super MapperProxyFactory<?>>ToLongBiFunction<? super Class<?>,? super MapperProxyFactory<?>>ToDoubleBiFunction<? super Class<?>,? super MapperProxyFactory<?>>BiFunction<? super Class<?>,? super MapperProxyFactory<?>,? extends U>KeySetView<Class<?>,MapperProxyFactory<?>>CollectionView<Class<?>,MapperProxyFactory<?>,Class<?>>keySet(org.apache.ibatis.binding.MapperProxyFactory)Enumeration<MapperProxyFactory<?>>Enumeration<Class<?>>ConcurrentHashMap<Class<?>,MapperProxyFactory<?>>(int,float,int)ConcurrentHashMap<Class<?>,MapperProxyFactory<?>>(int,float)ConcurrentHashMap<Class<?>,MapperProxyFactory<?>>(java.util.Map)ConcurrentHashMap<Class<?>,MapperProxyFactory<?>>(int)MapperProxyFactory<T>mapperProxyFactory"Type "Type " is not known to the MapperRegistry." is not known to the MapperRegistry.newInstance(org.apache.ibatis.session.SqlSession)newInstance(org.apache.ibatis.binding.MapperProxy)getMethodCachegetMethodCache()getMapperInterfacegetMapperInterface()MapperProxyFactoryMapperProxyFactory(java.lang.Class)MapperProxyFactory<T>(java.lang.Class)"Error getting mapper instance. Cause: "Error getting mapper instance. Cause: loadCompleted" is already known to the MapperRegistry." is already known to the MapperRegistry.parserpackageNamesuperTypeorg.apache.ibatis.ioResolverUtil<Class<?>>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/io/ResolverUtil.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/ioresolverUtilResolverUtil<Class<?>>()addIfMatchingaddIfMatching(org.apache.ibatis.io.ResolverUtil.Test,java.lang.String)getPackagePathgetPackagePath(java.lang.String)ResolverUtil<>findfind(org.apache.ibatis.io.ResolverUtil.Test,java.lang.String)findAnnotatedfindAnnotated(java.lang.Class,java.lang.String[])findImplementationsfindImplementations(java.lang.Class,java.lang.String[])setClassLoadersetClassLoader(java.lang.ClassLoader)Class<? extends T>Set<Class<? extends T>>Collection<Class<? extends T>>Iterable<Class<? extends T>>Class<? extends Class<?>>Set<Class<? extends Class<?>>>Collection<Class<? extends Class<?>>>Iterable<Class<? extends Class<?>>>ResolverUtilResolverUtil()mapperSetmapperClass It's important that the type is added before the parser is run otherwise the binding may automatically be attempted by the mapper parser. If the type is already known, it won't try.Gets the mappers.the mappers3.2.2Adds the mappers.@paramthe package namethe super type/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/binding/package-info.javaBinds mapper interfaces with mapped statements./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/BaseBuilder.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builderorg.apache.ibatis.builderregexdefaultValueHashSet<String>/G/java.base/java/util/HashSet.sigAbstractSet<String>/BCDEFGHIJK/java.base/java/util/AbstractSet.sigAbstractCollection<String>/BCDEFGHIJK/java.base/java/util/AbstractCollection.sigList<String>Collection<? extends String>Iterable<? extends String>HashSet<String>(java.util.Collection)Spliterator<String>Consumer<? super String>Iterator<String>Stream<String>BaseStream<String,Stream<String>>Predicate<? super String>add(java.lang.String)AbstractCollectionAbstractCollection()AbstractCollection<String>()Set<E>AbstractSetAbstractSet()AbstractSet<String>()HashSetHashSet(int)HashSet<String>(int)HashSet(int,float)HashSet<String>(int,float)HashSet(java.util.Collection)HashSet()HashSet<String>()",",alias"Error resolving JdbcType. Cause: "Error resolving JdbcType. Cause: "Error resolving ResultSetType. Cause: "Error resolving ResultSetType. Cause: "Error resolving ParameterMode. Cause: "Error resolving ParameterMode. Cause: clazzTypeVariable<Constructor<?>>TypeVariable<Constructor<?>>[]"Error creating instance. Cause: "Error creating instance. Cause: "Error resolving class. Cause: "Error resolving class. Cause: TypeHandler<?>javaTypetypeHandlerAlias? extends TypeHandler<?>Class<? extends TypeHandler<?>>typeHandlerType/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/BaseBuilder.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builderClass<TypeHandler<>>? super TypeHandler<>Class<? super TypeHandler<>>Constructor<TypeHandler<>>TypeHandler[]TypeHandler<>[]TypeVariable<Class<TypeHandler<>>>TypeVariable<Class<TypeHandler<>>>[]" is not a valid TypeHandler because it does not implement TypeHandler interface" is not a valid TypeHandler because it does not implement TypeHandler interfacehandlerTypeHandler<Object> already verified it is a TypeHandler javaType ignored for injected handlers see issue #746 for full detail if handler not in registry, create a new one, otherwise return directly/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/BuilderException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/BuilderException.class3885164021020443281L3885164021020443281/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/CacheRefResolver.javacacheRefNamespace/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/CacheRefResolver.classassistant/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/IncompleteElementException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/IncompleteElementException.class3697292286890900315L3697292286890900315/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/InitializingObject.javaInterface that indicate to provide an initialization method.Initialize an instance.This method will be invoked after it has set all properties.@throwsExceptionin the event of misconfiguration (such as failure to set an essential property) or if initializationfails/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/MapperBuilderAssistant.javaresolveParameterJavaTyperesolveParameterJavaType(java.lang.Class,java.lang.String,java.lang.Class,org.apache.ibatis.type.JdbcType)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/MapperBuilderAssistant.classresolveResultJavaTyperesolveResultJavaType(java.lang.Class,java.lang.String,java.lang.Class)List<ResultMapping>Collection<ResultMapping>Iterable<ResultMapping>parseCompositeColumnNameparseCompositeColumnName(java.lang.String)parseMultipleColumnNamesparseMultipleColumnNames(java.lang.String)getStatementResultMapsgetStatementResultMaps(java.lang.String,java.lang.Class,java.lang.String)getStatementParameterMapgetStatementParameterMap(java.lang.String,java.lang.Class,java.lang.String)valueOrDefaultvalueOrDefault(java.lang.Object,java.lang.Object)unresolvedCacheRefcurrentCacheresourcecurrentNamespace"The mapper element requires a namespace attribute to be specified."The mapper element requires a namespace attribute to be specified."Wrong namespace. Expected '"Wrong namespace. Expected '"' but found '"' but found '"'."'.baseisReference"Dots are not allowed in element names, please remove it from "Dots are not allowed in element names, please remove it from namespace"cache-ref element requires a namespace attribute."cache-ref element requires a namespace attribute.cache"No cache for namespace '"No cache for namespace '"' could be found."' could be found.typeClassevictionClassflushIntervalreadWriteblockingpropsClass<PerpetualCache>Class<LruCache>List<ParameterMapping>Collection<ParameterMapping>Iterable<ParameterMapping>parameterClassparameterMappingsparameterMapparameterTypejdbcTyperesultMapparameterModetypeHandlernumericScalejavaTypeClasstypeHandlerInstanceextenddiscriminatorresultMappingsautoMappingextendedResultMappingsArrayList<ResultMapping>/BCDEFGHIJK/java.base/java/util/ArrayList.sigAbstractList<ResultMapping>/89ABCDEFGHIJK/java.base/java/util/AbstractList.sig/89ABCDEFGHIJK/java.base/java/util/89ABCDEFGHIJK/java.base/java/89ABCDEFGHIJK/java.base/89ABCDEFGHIJKAbstractCollection<ResultMapping>? extends ResultMappingCollection<? extends ResultMapping>Iterable<? extends ResultMapping>ArrayList<ResultMapping>(java.util.Collection)Spliterator<ResultMapping>? super ResultMappingConsumer<? super ResultMapping>Iterator<ResultMapping>Stream<ResultMapping>BaseStream<ResultMapping,Stream<ResultMapping>>Predicate<? super ResultMapping>add(org.apache.ibatis.mapping.ResultMapping)AbstractCollection<ResultMapping>()ListIterator<ResultMapping>add(int,org.apache.ibatis.mapping.ResultMapping)set(int,org.apache.ibatis.mapping.ResultMapping)Comparator<? super ResultMapping>UnaryOperator<ResultMapping>Function<ResultMapping,ResultMapping>removeRangeremoveRange(int,int)AbstractListAbstractList()AbstractList<ResultMapping>()modCounttransientensureCapacityensureCapacity(int)trimToSizetrimToSize()ArrayListArrayList(java.util.Collection)ArrayList()ArrayList<ResultMapping>()ArrayList(int)ArrayList<ResultMapping>(int)declaresConstructor"Could not find a parent resultmap with id '"Could not find a parent resultmap with id '"'"'resultMappingList<ResultFlag>Collection<ResultFlag>Iterable<ResultFlag>Spliterator<ResultFlag>? super ResultFlagConsumer<? super ResultFlag>Iterator<ResultFlag>Stream<ResultFlag>BaseStream<ResultFlag,Stream<ResultFlag>>Predicate<? super ResultFlag>? extends ResultFlagCollection<? extends ResultFlag>Iterable<? extends ResultFlag>add(org.apache.ibatis.mapping.ResultFlag)ListIterator<ResultFlag>add(int,org.apache.ibatis.mapping.ResultFlag)set(int,org.apache.ibatis.mapping.ResultFlag)Comparator<? super ResultFlag>UnaryOperator<ResultFlag>Function<ResultFlag,ResultFlag>Predicate<ResultMapping>Predicate<>Predicate<T>notnot(java.util.function.Predicate)Predicate<? super T>isEqualisEqual(java.lang.Object)oror(java.util.function.Predicate)negatenegate()andand(java.util.function.Predicate)test(java.lang.Object)test(org.apache.ibatis.mapping.ResultMapping)Map<String,String>resultTypecolumndiscriminatorMapArrayList<ResultFlag>AbstractList<ResultFlag>AbstractCollection<ResultFlag>ArrayList<ResultFlag>()AbstractCollection<ResultFlag>()AbstractList<ResultFlag>()ArrayList<ResultFlag>(java.util.Collection)ArrayList<ResultFlag>(int)namespaceDiscriminatorMapHashMap<String,String>AbstractMap<String,String>HashMap<String,String>()BiFunction<? super String,? super String,? extends String>merge(java.lang.String,java.lang.String,java.util.function.BiFunction)Function<? super String,? extends String>replace(java.lang.String,java.lang.String)replace(java.lang.String,java.lang.String,java.lang.String)putIfAbsent(java.lang.String,java.lang.String)BiConsumer<? super String,? super String>getOrDefault(java.lang.Object,java.lang.String)Entry<String,String>Set<Entry<String,String>>Collection<Entry<String,String>>Iterable<Entry<String,String>>Map<? extends String,? extends String>put(java.lang.String,java.lang.String)AbstractMap<String,String>()HashMap<String,String>(java.util.Map)HashMap<String,String>(int)HashMap<String,String>(int,float)getValuegetValue()Comparator<>Comparator<Entry<K,V>>comparingByValuecomparingByValue(java.util.Comparator)Comparator<? super V>comparingByKeycomparingByKey(java.util.Comparator)Comparator<? super K>Comparable<? super V>comparingByValue()Comparable<? super K>comparingByKey()setValuesetValue(java.lang.Object)setValue(java.lang.String)getKeygetKey()sqlSourcestatementTypesqlCommandTypefetchSizetimeoutresultSetTypeflushCacheuseCacheresultOrderedkeyGeneratorkeyPropertykeyColumndatabaseIdlangresultSetsdirtySelectstatementBuilderstatementParameterMapstatement"Cache-ref not yet resolved"Cache-ref not yet resolvedparameterMapNameparameterTypeClass"Could not find parameter map "Could not find parameter map ArrayList<ParameterMapping>AbstractList<ParameterMapping>AbstractCollection<ParameterMapping>ArrayList<ParameterMapping>()Spliterator<ParameterMapping>? super ParameterMappingConsumer<? super ParameterMapping>Iterator<ParameterMapping>Stream<ParameterMapping>BaseStream<ParameterMapping,Stream<ParameterMapping>>Predicate<? super ParameterMapping>? extends ParameterMappingCollection<? extends ParameterMapping>Iterable<? extends ParameterMapping>add(org.apache.ibatis.mapping.ParameterMapping)AbstractCollection<ParameterMapping>()ListIterator<ParameterMapping>add(int,org.apache.ibatis.mapping.ParameterMapping)set(int,org.apache.ibatis.mapping.ParameterMapping)Comparator<? super ParameterMapping>UnaryOperator<ParameterMapping>Function<ParameterMapping,ParameterMapping>AbstractList<ParameterMapping>()ArrayList<ParameterMapping>(java.util.Collection)ArrayList<ParameterMapping>(int)"-Inline"-InlineresultMapsArrayList<ResultMap>AbstractList<ResultMap>AbstractCollection<ResultMap>ArrayList<ResultMap>()AbstractCollection<ResultMap>()AbstractList<ResultMap>()ArrayList<ResultMap>(java.util.Collection)ArrayList<ResultMap>(int)resultMapNamesresultMapName"Could not find result map '"Could not find result map '"' referenced from '"' referenced from 'inlineResultMapnestedSelectnestedResultMapnotNullColumncolumnPrefixflagsresultSetforeignColumnlazycompositeslangClasscolumnNamecolumnschar','1"{}, "{}, '='="{}=, "{}=, complexResultMappingmetaResultTypeEnum<JdbcType>Comparable<JdbcType>compareTo(org.apache.ibatis.type.JdbcType)EnumDesc<JdbcType>DynamicConstantDesc<JdbcType>Optional<EnumDesc<JdbcType>>Class<JdbcType>Enum<JdbcType>(java.lang.String,int)Class<ResultSet> issue #676 is it qualified with any namespace yet? is it qualified with this namespace yet? Class parameterType = parameterMapBuilder.type(); Remove parent constructor if this resultMap declares a constructor.Backward compatibility signature 'addMappedStatement'.the idthe sql sourcethe sql command typethe timeoutthe parameter mapthe parameter typethe result mapthe result typethe flush cachethe use cachethe result orderedthe key generatorthe key propertythe key columnthe database idthe langthe mapped statementBackward compatibility signature 'buildResultMapping'.the propertythe columnthe nested selectthe nested result mapthe not null columnthe type handlerthe flagsthe result mappingGets the language driver.the lang classthe language driver@deprecatedUse {@link Configuration#getLanguageDriver(Class)} ignore, following null check statement will deal with the situation/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/ParameterExpression.javatrimmedStrtrimmedStr(java.lang.String,int,int)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/ParameterExpression.classoptionoption(java.lang.String,int)jdbcType(java.lang.String,int)jdbcTypeOptjdbcTypeOpt(java.lang.String,int)skipUntilskipUntil(java.lang.String,int,java.lang.String)skipWSskipWS(java.lang.String,int)property(java.lang.String,int)expressionexpression(java.lang.String,int)parseparse(java.lang.String)2417552199605158680L2417552199605158680p'('(leftmatchright')'"expression"",:",:"property"0x2032endCharsc':'"Parsing error in {"Parsing error in {"} in position "} in position "jdbcType""="strstartend""Inline parameter expression parser. Supported grammar (simplified):inline-parameter = (propertyName | expression) oldJdbcType attributespropertyName = /expression language's property navigation path/expression = '(' /expression language's expression/ ')'oldJdbcType = ':' /any valid jdbc type/attributes = (',' attribute)*attribute = name '=' valueFrank D. Martinez [mnesarco]/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/ResultMapResolver.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/ResultMapResolver.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/SqlSourceBuilder.javaPARAMETER_PROPERTIES/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/SqlSourceBuilder.class"javaType,jdbcType,mode,numericScale,resultMap,typeHandler,jdbcTypeName"javaType,jdbcType,mode,numericScale,resultMap,typeHandler,jdbcTypeNameMap<String,Object>originalSqladditionalParameters"#{"#{"}"sqloriginaltokenizerbuilderhasMoreTokens' ' parseParameterMappingparseParameterMapping(java.lang.String)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/SqlSourceBuilder$ParameterMappingTokenHandler.classbuildParameterMappingbuildParameterMapping(java.lang.String)metaParameterscontent"?"propertiesMappropertyTypemetaClass"javaType""mode"mode"numericScale""resultMap""typeHandler""jdbcTypeName"jdbcTypeName"Expression based parameters are not supported yet"Expression based parameters are not supported yet"An invalid property '"An invalid property '"' was found in mapping #{"' was found in mapping #{"}.  Valid properties are "}.  Valid properties are ex"Parsing error was found in mapping #{"Parsing error was found in mapping #{"}.  Check syntax #{property|(expression), var1=value1, var2=value2, ...} "}.  Check syntax #{property|(expression), var1=value1, var2=value2, ...}  issue #448 get type from additional params Do Nothing/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/StaticSqlSource.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/StaticSqlSource.classparameterObject/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/annotation/MapperAnnotationBuilder.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/annotationorg.apache.ibatis.builder.annotationCollection<Class<? extends Annotation>>Iterable<Class<? extends Annotation>>Optional<AnnotationWrapper>getAnnotationWrappergetAnnotationWrapper(java.lang.reflect.Method,boolean,java.util.Collection)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/annotation/MapperAnnotationBuilder.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/annotationClass<? extends Annotation>[]getAnnotationWrapper(java.lang.reflect.Method,boolean,java.lang.Class[])buildSqlSourceFromStringsbuildSqlSourceFromStrings(java.lang.String[],java.lang.Class,org.apache.ibatis.scripting.LanguageDriver)buildSqlSourcebuildSqlSource(java.lang.annotation.Annotation,java.lang.Class,org.apache.ibatis.scripting.LanguageDriver,java.lang.reflect.Method)handleSelectKeyAnnotationhandleSelectKeyAnnotation(org.apache.ibatis.annotations.SelectKey,java.lang.String,java.lang.Class,org.apache.ibatis.scripting.LanguageDriver)nullOrEmptynullOrEmpty(java.lang.String)applyConstructorArgsapplyConstructorArgs(org.apache.ibatis.annotations.Arg[],java.lang.Class,java.util.List)hasNestedSelecthasNestedSelect(org.apache.ibatis.annotations.Result)isLazyisLazy(org.apache.ibatis.annotations.Result)nestedSelectIdnestedSelectId(org.apache.ibatis.annotations.Result)hasNestedResultMaphasNestedResultMap(org.apache.ibatis.annotations.Result)nestedResultMapIdnestedResultMapId(org.apache.ibatis.annotations.Result)findColumnPrefixfindColumnPrefix(org.apache.ibatis.annotations.Result)applyResultsapplyResults(org.apache.ibatis.annotations.Result[],java.lang.Class,java.util.List)getReturnTypegetReturnType(java.lang.reflect.Method,java.lang.Class)getParameterTypegetParameterType(java.lang.reflect.Method)getLanguageDrivergetLanguageDriver(java.lang.reflect.Method)parseStatementparseStatement(java.lang.reflect.Method)applyDiscriminatorapplyDiscriminator(java.lang.String,java.lang.Class,org.apache.ibatis.annotations.TypeDiscriminator)createDiscriminatorResultMapscreateDiscriminatorResultMaps(java.lang.String,java.lang.Class,org.apache.ibatis.annotations.TypeDiscriminator)applyResultMapapplyResultMap(java.lang.String,java.lang.Class,org.apache.ibatis.annotations.Arg[],org.apache.ibatis.annotations.Result[],org.apache.ibatis.annotations.TypeDiscriminator)generateResultMapNamegenerateResultMapName(java.lang.reflect.Method)parseResultMapparseResultMap(java.lang.reflect.Method)parseCacheRefparseCacheRef()convertToPropertiesconvertToProperties(org.apache.ibatis.annotations.Property[])parseCacheparseCache()loadXmlResourceloadXmlResource()canHaveStatementcanHaveStatement(java.lang.reflect.Method)Set<Class<? extends Annotation>>statementAnnotationTypesStream<Class<? extends Annotation>>BaseStream<Class<? extends Annotation>,Stream<Class<? extends Annotation>>>Collector<>/BCDEFGHIJK/java.base/java/util/stream/Collector.sigcollectcollect(java.util.stream.Collector)? super Class<? extends Annotation>Collector<? super Class<? extends Annotation>,A,R>closeclose()onCloseonClose(java.lang.Runnable)unorderedunordered()parallelparallel()sequentialsequential()isParallelisParallel()Spliterator<Class<? extends Annotation>>Iterator<Class<? extends Annotation>>List<T>Collection<T>toListtoList()List<Class<? extends Annotation>>? super DoubleConsumerBiConsumer<? super T,? super DoubleConsumer>mapMultiToDoublemapMultiToDouble(java.util.function.BiConsumer)BiConsumer<? super Class<? extends Annotation>,? super DoubleConsumer>? super LongConsumerBiConsumer<? super T,? super LongConsumer>mapMultiToLongmapMultiToLong(java.util.function.BiConsumer)BiConsumer<? super Class<? extends Annotation>,? super LongConsumer>? super IntConsumerBiConsumer<? super T,? super IntConsumer>mapMultiToIntmapMultiToInt(java.util.function.BiConsumer)BiConsumer<? super Class<? extends Annotation>,? super IntConsumer>BiConsumer<>RStream<R>BaseStream<R,Stream<R>>mapMultimapMulti(java.util.function.BiConsumer)Consumer<R>? super Consumer<R>BiConsumer<? super T,? super Consumer<R>>BiConsumer<? super Class<? extends Annotation>,? super Consumer<R>>Supplier<>/BCDEFGHIJK/java.base/java/util/function/Supplier.sigStream<T>BaseStream<T,Stream<T>>generategenerate(java.util.function.Supplier)Supplier<? extends T>UnaryOperator<>iterateiterate(java.lang.Object,java.util.function.Predicate,java.util.function.UnaryOperator)UnaryOperator<T>ofNullableofNullable(java.lang.Object)dropWhiledropWhile(java.util.function.Predicate)Predicate<? super Class<? extends Annotation>>takeWhiletakeWhile(java.util.function.Predicate)concatconcat(java.util.stream.Stream,java.util.stream.Stream)Stream<? extends T>BaseStream<? extends T,Stream<? extends T>>iterate(java.lang.Object,java.util.function.UnaryOperator)emptyempty()Builder<>/BCDEFGHIJK/java.base/java/util/stream/Stream$Builder.sigBuilder<T>Consumer<T>builder()Optional<T>findAnyfindAny()Optional<Class<? extends Annotation>>findFirstfindFirst()noneMatchnoneMatch(java.util.function.Predicate)allMatchallMatch(java.util.function.Predicate)anyMatchanyMatch(java.util.function.Predicate)countcount()Comparator<? super T>maxmax(java.util.Comparator)Comparator<? super Class<? extends Annotation>>minmin(java.util.Comparator)Collector<? super T,A,R>collect(java.util.function.Supplier,java.util.function.BiConsumer,java.util.function.BiConsumer)Supplier<R>BiConsumer<R,? super T>BiConsumer<R,R>BiConsumer<R,? super Class<? extends Annotation>>BinaryOperator<>/G/java.base/java/util/function/BinaryOperator.sigreduce(java.lang.Object,java.util.function.BiFunction,java.util.function.BinaryOperator)BiFunction<U,? super T,U>BinaryOperator<U>BiFunction<U,U,U>BiFunction<U,? super Class<? extends Annotation>,U>BinaryOperator<T>BiFunction<T,T,T>reduce(java.util.function.BinaryOperator)BinaryOperator<Class<? extends Annotation>>BiFunction<Class<? extends Annotation>,Class<? extends Annotation>,Class<? extends Annotation>>reduce(java.lang.Object,java.util.function.BinaryOperator)reduce(java.lang.Class,java.util.function.BinaryOperator)IntFunction<A[]>forEachOrderedforEachOrdered(java.util.function.Consumer)Consumer<? super Class<? extends Annotation>>skip(long)limitlimit(long)peekpeek(java.util.function.Consumer)sortedsorted(java.util.Comparator)sorted()distinctdistinct()? extends DoubleStreamFunction<? super T,? extends DoubleStream>flatMapToDoubleflatMapToDouble(java.util.function.Function)Function<? super Class<? extends Annotation>,? extends DoubleStream>? extends LongStreamFunction<? super T,? extends LongStream>flatMapToLongflatMapToLong(java.util.function.Function)Function<? super Class<? extends Annotation>,? extends LongStream>? extends IntStreamFunction<? super T,? extends IntStream>flatMapToIntflatMapToInt(java.util.function.Function)Function<? super Class<? extends Annotation>,? extends IntStream>flatMapflatMap(java.util.function.Function)? extends RStream<? extends R>BaseStream<? extends R,Stream<? extends R>>? extends Stream<? extends R>Function<? super T,? extends Stream<? extends R>>Function<? super Class<? extends Annotation>,? extends Stream<? extends R>>ToDoubleFunction<? super T>mapToDoublemapToDouble(java.util.function.ToDoubleFunction)ToDoubleFunction<? super Class<? extends Annotation>>ToLongFunction<? super T>mapToLongmapToLong(java.util.function.ToLongFunction)ToLongFunction<? super Class<? extends Annotation>>ToIntFunction<? super T>mapToIntmapToInt(java.util.function.ToIntFunction)ToIntFunction<? super Class<? extends Annotation>>mapmap(java.util.function.Function)Function<? super T,? extends R>Function<? super Class<? extends Annotation>,? extends R>filter(java.util.function.Predicate)Collector<Class<? extends Annotation>,?,Set<Class<? extends Annotation>>>Class<Select>Class<Update>Class<Insert>Class<Delete>Class<SelectProvider>Class<UpdateProvider>Class<InsertProvider>Class<DeleteProvider>'.''/'".java (best guess)".java (best guess)isPresentisPresent()orElseThroworElseThrow()Stream<AnnotationWrapper>BaseStream<AnnotationWrapper,Stream<AnnotationWrapper>>Optional<? extends T>? extends Optional<? extends T>Supplier<? extends Optional<? extends T>>or(java.util.function.Supplier)? extends AnnotationWrapperOptional<? extends AnnotationWrapper>? extends Optional<? extends AnnotationWrapper>Supplier<? extends Optional<? extends AnnotationWrapper>>Optional<U>Optional<? extends U>? extends Optional<? extends U>Function<? super T,? extends Optional<? extends U>>? super AnnotationWrapperFunction<? super AnnotationWrapper,? extends Optional<? extends U>>ifPresentOrElseifPresentOrElse(java.util.function.Consumer,java.lang.Runnable)Consumer<? super AnnotationWrapper>XorElseThrow(java.util.function.Supplier)? extends XSupplier<? extends X>orElseGetorElseGet(java.util.function.Supplier)Supplier<? extends AnnotationWrapper>orElseorElse(java.lang.Object)orElse(org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.AnnotationWrapper)Function<? super T,? extends U>Function<? super AnnotationWrapper,? extends U>Predicate<? super AnnotationWrapper>ifPresentifPresent(java.util.function.Consumer)get()Class<ResultMap>"namespace:"namespace:xmlResource".xml".xmlinputStream"/"e2xmlParserMap<String,XNode>cacheDomainClass<CacheNamespace>cacheDomainRefClass<CacheNamespaceRef>refTyperefName"Should be specified either value() or name() attribute in the @CacheNamespaceRef"Should be specified either value() or name() attribute in the @CacheNamespaceRef"Cannot use both value() and name() attribute in the @CacheNamespaceRef"Cannot use both value() and name() attribute in the @CacheNamespaceRefClass<Arg>resultsClass<Result>typeDiscriminatorClass<TypeDiscriminator>resultMapIdsuffix"-"-"-void"-voiddisccaseResultMapIdClass<String>Class<UnknownTypeHandler>caseslanguageDriverConsumer<AnnotationWrapper>andThen(java.util.function.Consumer)acceptaccept(java.lang.Object)accept(org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.AnnotationWrapper)statementAnnotationoptionsOptional<Options>orElse(org.apache.ibatis.annotations.Options)Stream<Options>BaseStream<Options,Stream<Options>>? extends OptionsOptional<? extends Options>? extends Optional<? extends Options>Supplier<? extends Optional<? extends Options>>? super OptionsFunction<? super Options,? extends Optional<? extends U>>Consumer<? super Options>Supplier<? extends Options>Function<? super Options,? extends U>Predicate<? super Options>Function<AnnotationWrapper,Options>Class<Options>Function<AnnotationWrapper,V>Function<? super Options,? extends V>Function<V,Options>Function<? super V,? extends AnnotationWrapper>apply(org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.AnnotationWrapper)xmappedStatementIdisSelectEnum<SqlCommandType>Comparable<SqlCommandType>compareTo(org.apache.ibatis.mapping.SqlCommandType)EnumDesc<SqlCommandType>DynamicConstantDesc<SqlCommandType>Optional<EnumDesc<SqlCommandType>>Class<SqlCommandType>Enum<SqlCommandType>(java.lang.String,int)selectKeyOptional<SelectKey>orElse(org.apache.ibatis.annotations.SelectKey)Stream<SelectKey>BaseStream<SelectKey,Stream<SelectKey>>? extends SelectKeyOptional<? extends SelectKey>? extends Optional<? extends SelectKey>Supplier<? extends Optional<? extends SelectKey>>? super SelectKeyFunction<? super SelectKey,? extends Optional<? extends U>>Consumer<? super SelectKey>Supplier<? extends SelectKey>Function<? super SelectKey,? extends U>Predicate<? super SelectKey>Function<AnnotationWrapper,SelectKey>Class<SelectKey>Function<? super SelectKey,? extends V>Function<V,SelectKey>Enum<FlushCachePolicy>Comparable<FlushCachePolicy>compareTo(org.apache.ibatis.annotations.Options.FlushCachePolicy)EnumDesc<FlushCachePolicy>DynamicConstantDesc<FlushCachePolicy>Optional<EnumDesc<FlushCachePolicy>>Class<FlushCachePolicy>Enum<FlushCachePolicy>(java.lang.String,int)resultMapAnnotationCharSequence[]Class<Lang>parameterTypescurrentParameterType? super RowBoundsClass<? super RowBounds>Constructor<RowBounds>RowBounds[]TypeVariable<Class<RowBounds>>TypeVariable<Class<RowBounds>>[]? super ResultHandler<>Class<? super ResultHandler<>>Constructor<ResultHandler<>>ResultHandler[]ResultHandler<>[]TypeVariable<Class<ResultHandler<>>>TypeVariable<Class<ResultHandler<>>>[]ParamMap<>HashMap<>AbstractMap<>Class<ParamMap<>>rtClass<ResultType>parameterizedTyperawTypeClass<Collection<>>? super Collection<>Class<? super Collection<>>Constructor<Collection<>>Collection[]Collection<>[]TypeVariable<Class<Collection<>>>TypeVariable<Class<Collection<>>>[]? super Cursor<>Class<? super Cursor<>>Constructor<Cursor<>>Cursor[]Cursor<>[]TypeVariable<Class<Cursor<>>>TypeVariable<Class<Cursor<>>>[]actualTypeArgumentsreturnTypeParameter2"Cannot use both @One and @Many annotations in the same @Result"Cannot use both @One and @Many annotations in the same @ResultargselectKeyAnnotationbaseStatementIdresultTypeClassexecuteBeforeresultSetTypeEnumkeyStatementanswerannotationstrings" "errorIfNoMatchtargetTypesMap<String,AnnotationWrapper>statementAnnotationsCollector<? super AnnotationWrapper,A,R>Spliterator<AnnotationWrapper>Iterator<AnnotationWrapper>List<AnnotationWrapper>Collection<AnnotationWrapper>Iterable<AnnotationWrapper>BiConsumer<? super AnnotationWrapper,? super DoubleConsumer>BiConsumer<? super AnnotationWrapper,? super LongConsumer>BiConsumer<? super AnnotationWrapper,? super IntConsumer>BiConsumer<? super AnnotationWrapper,? super Consumer<R>>Comparator<? super AnnotationWrapper>BiConsumer<R,? super AnnotationWrapper>BiFunction<U,? super AnnotationWrapper,U>BinaryOperator<AnnotationWrapper>BiFunction<AnnotationWrapper,AnnotationWrapper,AnnotationWrapper>reduce(org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.AnnotationWrapper,java.util.function.BinaryOperator)Function<? super AnnotationWrapper,? extends DoubleStream>Function<? super AnnotationWrapper,? extends LongStream>Function<? super AnnotationWrapper,? extends IntStream>Function<? super AnnotationWrapper,? extends Stream<? extends R>>ToDoubleFunction<? super AnnotationWrapper>ToLongFunction<? super AnnotationWrapper>ToIntFunction<? super AnnotationWrapper>Function<? super AnnotationWrapper,? extends R>Collector<AnnotationWrapper,?,Map<String,AnnotationWrapper>>Stream<? extends Annotation>BaseStream<? extends Annotation,Stream<? extends Annotation>>Function<?,? extends R>Spliterator<? extends Annotation>Iterator<? extends Annotation>List<? extends Annotation>Collection<? extends Annotation>Iterable<? extends Annotation>BiConsumer<?,? super DoubleConsumer>BiConsumer<?,? super LongConsumer>BiConsumer<?,? super IntConsumer>BiConsumer<?,? super Consumer<R>>Predicate<?>Optional<? extends Annotation>Comparator<?>Collector<?,A,R>BiConsumer<R,?>BiFunction<U,?,U>BinaryOperator<? extends Annotation>BiFunction<? extends Annotation,? extends Annotation,? extends Annotation>reduce(<nulltype>,java.util.function.BinaryOperator)Consumer<?>Function<?,? extends DoubleStream>Function<?,? extends LongStream>Function<?,? extends IntStream>Function<?,? extends Stream<? extends R>>ToDoubleFunction<?>ToLongFunction<?>ToIntFunction<?>Function<? extends Annotation,AnnotationWrapper>? extends ? extends AnnotationStream<? extends ? extends Annotation>Function<Class<? extends Annotation>,Stream<? extends ? extends Annotation>>? extends Class<? extends Annotation>Collection<? extends Class<? extends Annotation>>Iterable<? extends Class<? extends Annotation>>add(java.lang.Class)Function<Class<? extends Annotation>,V>? super Stream<? extends Annotation>Function<? super Stream<? extends Annotation>,? extends V>Function<V,Stream<? extends Annotation>>Function<? super V,? extends Class<? extends Annotation>>apply(java.lang.Class)? extends Annotation[]Function<? extends Annotation,V>Function<? super AnnotationWrapper,? extends V>Function<V,AnnotationWrapper>Function<? super V,? extends Annotation>apply(<nulltype>)apply(java.lang.annotation.Annotation)Function<AnnotationWrapper,String>Function<AnnotationWrapper,AnnotationWrapper>Function<V,String>BiFunction<T,U,V>BiFunction<AnnotationWrapper,AnnotationWrapper,V>apply(java.lang.Object,java.lang.Object)apply(org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.AnnotationWrapper,org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.AnnotationWrapper)maxBymaxBy(java.util.Comparator)minByminBy(java.util.Comparator)existingduplicate"Detected conflicting annotations '%s' and '%s' on '%s'."Detected conflicting annotations '%s' and '%s' on '%s'.annotationWrapperBiFunction<? super AnnotationWrapper,? super AnnotationWrapper,? extends AnnotationWrapper>merge(java.lang.String,org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.AnnotationWrapper,java.util.function.BiFunction)BiFunction<? super String,? super AnnotationWrapper,? extends AnnotationWrapper>Function<? super String,? extends AnnotationWrapper>replace(java.lang.String,org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.AnnotationWrapper)replace(java.lang.String,org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.AnnotationWrapper,org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.AnnotationWrapper)putIfAbsent(java.lang.String,org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.AnnotationWrapper)BiConsumer<? super String,? super AnnotationWrapper>getOrDefault(java.lang.Object,org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.AnnotationWrapper)Entry<String,AnnotationWrapper>Set<Entry<String,AnnotationWrapper>>Collection<Entry<String,AnnotationWrapper>>Iterable<Entry<String,AnnotationWrapper>>Map<? extends String,? extends AnnotationWrapper>put(java.lang.String,org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.AnnotationWrapper)"Could not find a statement annotation that correspond a current database or default statement on method '%s.%s'. Current database id is [%s]."Could not find a statement annotation that correspond a current database or default statement on method '%s.%s'. Current database id is [%s].mapperFqnlocalStatementIdisDirtySelectisDirtySelect()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/annotation/MapperAnnotationBuilder$AnnotationWrapper.classgetDatabaseIdgetDatabaseId()getSqlCommandTypegetSqlCommandType()getAnnotation()AnnotationWrapperAnnotationWrapper(java.lang.annotation.Annotation) issue #237 Spring may not know the real resource name so we check a flag to prevent loading again a resource twice this flag is set at XMLMapperBuilder#bindMapperForNamespace #1347 Search XML mapper that is not in the module but in the classpath. ignore, resource is not required TODO add AutoMappingBehaviour issue #136 first check for SelectKey annotation - that overrides everything else issue #348 ParameterMapID TODO gcode issue #577 ResultSets issue #135 gcode issue #508 (gcode issue #443) actual type can be a also a parameterized type (gcode issue #525) support List<byte[]> (gcode issue 504) Do not look into Maps if there is not MapKey annotation (gcode issue 443) actual type can be a also a parameterized type defaults Annotations exist, but there is no matching one for the specified databaseId No corresponding mapper interface which is OK/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/annotation/MethodResolver.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/annotation/MethodResolver.classannotationBuilder/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/annotation/ProviderContext.javaProviderContextProviderContext(java.lang.Class,java.lang.reflect.Method,java.lang.String)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/annotation/ProviderContext.classmapperTypeThe context object for sql provider method.3.4.5Constructor.A mapper interface type that specified providerA mapper method that specified providerA database idGet a mapper interface type that specified provider.Get a mapper method that specified provider.Get a database id that provided from {@link org.apache.ibatis.mapping.DatabaseIdProvider}.3.5.1/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/annotation/ProviderMethodResolver.javacontextList<Method>sameNameMethodsStream<Method>BaseStream<Method,Stream<Method>>Collector<? super Method,A,R>Spliterator<Method>Iterator<Method>BiConsumer<? super Method,? super DoubleConsumer>BiConsumer<? super Method,? super LongConsumer>BiConsumer<? super Method,? super IntConsumer>BiConsumer<? super Method,? super Consumer<R>>Predicate<? super Method>Optional<Method>Comparator<? super Method>BiConsumer<R,? super Method>BiFunction<U,? super Method,U>BinaryOperator<Method>BiFunction<Method,Method,Method>reduce(java.lang.reflect.Method,java.util.function.BinaryOperator)Function<? super Method,? extends DoubleStream>Function<? super Method,? extends LongStream>Function<? super Method,? extends IntStream>Function<? super Method,? extends Stream<? extends R>>Function<? super Method,? extends R>Collector<Method,?,List<Method>>Predicate<Method>? extends ProviderMethodResolverClass<? extends ProviderMethodResolver>Constructor<? extends ProviderMethodResolver>ProviderMethodResolver[]TypeVariable<Class<? extends ProviderMethodResolver>>TypeVariable<Class<? extends ProviderMethodResolver>>[]test(java.lang.reflect.Method)targetMethodsCollection<? extends Method>Iterable<? extends Method>add(java.lang.reflect.Method)Class<CharSequence>? super CharSequenceClass<? super CharSequence>Constructor<CharSequence>TypeVariable<Class<CharSequence>>TypeVariable<Class<CharSequence>>[]ListIterator<Method>add(int,java.lang.reflect.Method)set(int,java.lang.reflect.Method)UnaryOperator<Method>Function<Method,Method>"Cannot resolve the provider method because '"Cannot resolve the provider method because '"' not found in SqlProvider '"' not found in SqlProvider '"' does not return the CharSequence or its subclass in SqlProvider '"' does not return the CharSequence or its subclass in SqlProvider '"' is found multiple in SqlProvider '"' is found multiple in SqlProvider 'The interface that resolve an SQL provider method via an SQL provider class.This interface need to implements at an SQL provider class and it need to define the default constructor for creatinga new instance.Resolve an SQL provider method.The default implementation return a method that matches following conditions.<li>Method name matches with mapper method</li><li>Return type matches the {@link CharSequence}({@link String}, {@link StringBuilder}, etc...)</li>If matched method is zero or multiple, it throws a {@link BuilderException}.a context for SQL provideran SQL provider methodBuilderExceptionThrows when cannot resolve a target method/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/annotation/ProviderSqlSource.javagetProviderTypegetProviderType(org.apache.ibatis.session.Configuration,java.lang.annotation.Annotation,java.lang.reflect.Method)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/annotation/ProviderSqlSource.classinvokeProviderMethodinvokeProviderMethod(java.lang.Object[])extractProviderMethodArgumentsextractProviderMethodArguments(java.util.Map,java.lang.String[])extractProviderMethodArguments(java.lang.Object)extractRootCauseextractRootCause(java.lang.Exception)createSqlSourcecreateSqlSource(java.lang.Object)providerContextIndexproviderContextproviderMethodParameterTypesproviderMethodArgumentNamesproviderMethodproviderTypeprovidercandidateProviderMethodNamecandidateProviderMethodcandidateProviderContextcandidateProviderContextIndexConstructor<? extends Annotation>TypeVariable<Class<? extends Annotation>>TypeVariable<Class<? extends Annotation>>[]"method"Class<ProviderMethodResolver>? super ProviderMethodResolverClass<? super ProviderMethodResolver>Constructor<ProviderMethodResolver>TypeVariable<Class<ProviderMethodResolver>>TypeVariable<Class<ProviderMethodResolver>>[]"provideSql"provideSql"Error creating SqlSource for SqlProvider. Method '"Error creating SqlSource for SqlProvider. Method '"'. Sql provider method can not overload."'. Sql provider method can not overload."Error creating SqlSource for SqlProvider.  Cause: "Error creating SqlSource for SqlProvider.  Cause: Class<ProviderContext>"Error creating SqlSource for SqlProvider. ProviderContext found multiple in SqlProvider method ("Error creating SqlSource for SqlProvider. ProviderContext found multiple in SqlProvider method ("). ProviderContext can not define multiple in SqlProvider method argument."). ProviderContext can not define multiple in SqlProvider method argument.bindParameterCountparams"Cannot invoke SqlProvider method '"Cannot invoke SqlProvider method '"' with specify parameter '"' with specify parameter '"' because SqlProvider method arguments for '"' because SqlProvider method arguments for '"' is an invalid combination."' is an invalid combination."Error invoking SqlProvider method '"Error invoking SqlProvider method '"'.  Cause: "'.  Cause: argumentNames? super ObjectBiFunction<? super Object,? super Object,? extends Object>BiFunction<? super String,? super Object,? extends Object>Function<? super String,? extends Object>BiConsumer<? super String,? super Object>Entry<String,Object>Set<Entry<String,Object>>Collection<Entry<String,Object>>Iterable<Entry<String,Object>>Collection<Object>Map<? extends String,? extends Object>targetObjectproviderAnnotation"type""value""Please specify either 'value' or 'type' attribute of @"Please specify either 'value' or 'type' attribute of @" at the '" at the '"Cannot specify different class on 'value' and 'type' attribute of @"Cannot specify different class on 'value' and 'type' attribute of @This constructor will remove at a future version.the configurationthe providerSince 3.5.3, Please use the {@link #ProviderSqlSource(Configuration, Annotation, Class, Method)}instead of this.the mapper typethe mapper methodInstantiates a new provider sql source.3.5.3/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/annotation/package-info.javaParses annotions to create a Configuration./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/package-info.javaBase package for the Configuration building code./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/xml/XMLConfigBuilder.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/xmlorg.apache.ibatis.builder.xml? extends ConfigurationClass<? extends Configuration>newConfignewConfig(java.lang.Class)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/xml/XMLConfigBuilder.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/xmlisSpecifiedEnvironmentisSpecifiedEnvironment(java.lang.String)mappersElementmappersElement(org.apache.ibatis.parsing.XNode)typeHandlersElementtypeHandlersElement(org.apache.ibatis.parsing.XNode)dataSourceElementdataSourceElement(org.apache.ibatis.parsing.XNode)transactionManagerElementtransactionManagerElement(org.apache.ibatis.parsing.XNode)databaseIdProviderElementdatabaseIdProviderElement(org.apache.ibatis.parsing.XNode)environmentsElementenvironmentsElement(org.apache.ibatis.parsing.XNode)settingsElementsettingsElement(java.util.Properties)propertiesElementpropertiesElement(org.apache.ibatis.parsing.XNode)reflectorFactoryElementreflectorFactoryElement(org.apache.ibatis.parsing.XNode)objectWrapperFactoryElementobjectWrapperFactoryElement(org.apache.ibatis.parsing.XNode)objectFactoryElementobjectFactoryElement(org.apache.ibatis.parsing.XNode)pluginsElementpluginsElement(org.apache.ibatis.parsing.XNode)typeAliasesElementtypeAliasesElement(org.apache.ibatis.parsing.XNode)loadCustomLogImplloadCustomLogImpl(java.util.Properties)loadCustomVfsImplloadCustomVfsImpl(java.util.Properties)settingsAsPropertiessettingsAsProperties(org.apache.ibatis.parsing.XNode)parseConfigurationparseConfiguration(org.apache.ibatis.parsing.XNode)XMLConfigBuilderXMLConfigBuilder(java.lang.Class,org.apache.ibatis.parsing.XPathParser,java.lang.String,java.util.Properties)localReflectorFactoryenvironmentparsedreaderClass<Configuration>configClass"SQL Mapper Configuration"SQL Mapper Configuration"Each XMLConfigBuilder can only be used once."Each XMLConfigBuilder can only be used once."/configuration"/configurationrootsettings"settings""properties""typeAliases"typeAliases"plugins""objectFactory"objectFactory"objectWrapperFactory"objectWrapperFactory"reflectorFactory"reflectorFactory"environments"environments"databaseIdProvider"databaseIdProvider"typeHandlers"typeHandlers"mappers"mappers"Error parsing SQL Mapper Configuration. Cause: "Error parsing SQL Mapper Configuration. Cause: metaConfigSet<Object>"The setting "The setting " is not known.  Make sure you spelled it correctly (case sensitive)." is not known.  Make sure you spelled it correctly (case sensitive)."vfsImpl"vfsImplclazzes? extends VFSClass<? extends VFS>? extends LogClass<? extends Log>logImpl"logImpl"childList<XNode>Collection<XNode>Iterable<XNode>"package"typeAliasPackage"name""alias""Error registering typeAlias for '"Error registering typeAlias for '"'. Cause: "'. Cause: interceptor"interceptor"interceptorInstanceConstructor<? extends Object>TypeVariable<Constructor<? extends Object>>TypeVariable<Constructor<? extends Object>>[]TypeVariable<Class<? extends Object>>TypeVariable<Class<? extends Object>>[]factorydefaults"resource""url"vars"The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other."The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.Map<?,?>"autoMappingBehavior"autoMappingBehavior"PARTIAL"PARTIAL"autoMappingUnknownColumnBehavior"autoMappingUnknownColumnBehavior"NONE"NONE"cacheEnabled"cacheEnabled"proxyFactory"proxyFactory"lazyLoadingEnabled"lazyLoadingEnabled"aggressiveLazyLoading"aggressiveLazyLoading"multipleResultSetsEnabled"multipleResultSetsEnabled"useColumnLabel"useColumnLabel"useGeneratedKeys"useGeneratedKeys"defaultExecutorType"defaultExecutorType"SIMPLE"SIMPLE"defaultStatementTimeout"defaultStatementTimeout"defaultFetchSize"defaultFetchSize"defaultResultSetType"defaultResultSetType"mapUnderscoreToCamelCase"mapUnderscoreToCamelCase"safeRowBoundsEnabled"safeRowBoundsEnabled"localCacheScope"localCacheScope"SESSION"SESSION"jdbcTypeForNull"jdbcTypeForNull"OTHER"OTHER"lazyLoadTriggerMethods"lazyLoadTriggerMethods"equals,clone,hashCode,toString"equals,clone,hashCode,toString"safeResultHandlerEnabled"safeResultHandlerEnabled"defaultScriptingLanguage"defaultScriptingLanguage"defaultEnumTypeHandler"defaultEnumTypeHandler"callSettersOnNulls"callSettersOnNulls"useActualParamName"useActualParamName"returnInstanceForEmptyRow"returnInstanceForEmptyRow"logPrefix"logPrefix"configurationFactory"configurationFactory"shrinkWhitespacesInSql"shrinkWhitespacesInSql"argNameBasedConstructorAutoMapping"argNameBasedConstructorAutoMapping"defaultSqlProviderType"defaultSqlProviderType"nullableOnForEach"nullableOnForEach"default""id"txFactory"transactionManager"transactionManagerdsFactory"dataSource"dataSourceenvironmentBuilder"VENDOR"VENDOR"DB_VENDOR"DB_VENDOR"Environment declaration requires a TransactionFactory."Environment declaration requires a TransactionFactory."Environment declaration requires a DataSourceFactory."Environment declaration requires a DataSourceFactory.typeHandlerPackagejavaTypeNamehandlerTypeName"handler"typeHandlerClassmapperPackage"class"classmapperParser"A mapper element may only specify a url, resource or class, but not more than one."A mapper element may only specify a url, resource or class, but not more than one."No environment specified."No environment specified."Environment requires an id attribute."Environment requires an id attribute.Constructor<? extends Configuration>TypeVariable<Constructor<? extends Configuration>>TypeVariable<Constructor<? extends Configuration>>[]Configuration[]TypeVariable<Class<? extends Configuration>>TypeVariable<Class<? extends Configuration>>[]"Failed to create a new Configuration instance."Failed to create a new Configuration instance. issue #117 read properties first read it after objectFactory and objectWrapperFactory issue #631 Check that all settings are known to the configuration class awful patch to keep backward compatibility/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/xml/XMLIncludeTransformer.javagetVariablesContextgetVariablesContext(org.w3c.dom.Node,java.util.Properties)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/xml/XMLIncludeTransformer.classgetStringAttributegetStringAttribute(org.w3c.dom.Node,java.lang.String)findSqlFragmentfindSqlFragment(java.lang.String,java.util.Properties)applyIncludesapplyIncludes(org.w3c.dom.Node,java.util.Properties,boolean)builderAssistantsourcevariablesContextconfigurationVariablesOptional<Properties>? super PropertiesConsumer<? super Properties>Stream<Properties>BaseStream<Properties,Stream<Properties>>? extends PropertiesOptional<? extends Properties>? extends Optional<? extends Properties>Supplier<? extends Optional<? extends Properties>>Function<? super Properties,? extends Optional<? extends U>>Supplier<? extends Properties>orElse(java.util.Properties)Function<? super Properties,? extends U>Predicate<? super Properties>Consumer<Properties>accept(java.util.Properties)arg0included"include"toInclude"refid"refidtoIncludeContextshortchildrenattributesattrvariablesnodeToInclude? super XNode? extends XNodeBiFunction<? super XNode,? super XNode,? extends XNode>merge(java.lang.String,org.apache.ibatis.parsing.XNode,java.util.function.BiFunction)BiFunction<? super String,? super XNode,? extends XNode>Function<? super String,? extends XNode>replace(java.lang.String,org.apache.ibatis.parsing.XNode)replace(java.lang.String,org.apache.ibatis.parsing.XNode,org.apache.ibatis.parsing.XNode)putIfAbsent(java.lang.String,org.apache.ibatis.parsing.XNode)BiConsumer<? super String,? super XNode>getOrDefault(java.lang.Object,org.apache.ibatis.parsing.XNode)Entry<String,XNode>Set<Entry<String,XNode>>Collection<Entry<String,XNode>>Iterable<Entry<String,XNode>>Map<? extends String,? extends XNode>put(java.lang.String,org.apache.ibatis.parsing.XNode)"Could not find SQL statement to include with refid '"Could not find SQL statement to include with refid 'nodeinheritedVariablesContextdeclaredPropertiesnewPropertiesn"Variable "Variable " defined twice in the same include definition" defined twice in the same include definitionRecursively apply includes through all SQL fragments.Include node in DOM treeCurrent context for static variables with values replace variables in attribute values replace variables in text nodeRead placeholders and their values from include node definition.Include node instanceCurrent context used for replace variables in new variables valuesvariables context from include instance (no inherited values) Replace variables inside/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/xml/XMLMapperBuilder.javabindMapperForNamespacebindMapperForNamespace()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/xml/XMLMapperBuilder.classprocessNestedResultMappingsprocessNestedResultMappings(org.apache.ibatis.parsing.XNode,java.util.List,java.lang.Class)buildResultMappingFromContextbuildResultMappingFromContext(org.apache.ibatis.parsing.XNode,java.lang.Class,java.util.List)databaseIdMatchesCurrentdatabaseIdMatchesCurrent(java.lang.String,java.lang.String,java.lang.String)sqlElementsqlElement(java.util.List,java.lang.String)sqlElement(java.util.List)processDiscriminatorElementprocessDiscriminatorElement(org.apache.ibatis.parsing.XNode,java.lang.Class,java.util.List)processConstructorElementprocessConstructorElement(org.apache.ibatis.parsing.XNode,java.lang.Class,java.util.List)resultMapElementresultMapElement(org.apache.ibatis.parsing.XNode,java.util.List,java.lang.Class)resultMapElement(org.apache.ibatis.parsing.XNode)resultMapElementsresultMapElements(java.util.List)parameterMapElementparameterMapElement(java.util.List)cacheElementcacheElement(org.apache.ibatis.parsing.XNode)cacheRefElementcacheRefElement(org.apache.ibatis.parsing.XNode)buildStatementFromContextbuildStatementFromContext(java.util.List,java.lang.String)buildStatementFromContext(java.util.List)configurationElementconfigurationElement(org.apache.ibatis.parsing.XNode)XMLMapperBuilderXMLMapperBuilder(org.apache.ibatis.parsing.XPathParser,org.apache.ibatis.session.Configuration,java.lang.String,java.util.Map)sqlFragments"/mapper"/mapper"namespace""Mapper's namespace cannot be empty"Mapper's namespace cannot be empty"cache-ref"cache-ref"cache""/mapper/parameterMap"/mapper/parameterMap"/mapper/resultMap"/mapper/resultMap"/mapper/sql"/mapper/sql"select|insert|update|delete"select|insert|update|delete"Error parsing Mapper XML. The XML location is '"Error parsing Mapper XML. The XML location is 'requiredDatabaseIdstatementParsercacheRefResolver"PERPETUAL"PERPETUALClass<Cache>eviction"eviction""LRU"LRU"flushInterval""size""readOnly"readOnly"blocking"parameterMapNodeparameterNodes"parameter"parameterparameterNodemodeEnumjdbcTypeEnumparameterMappingresultMapNodeadditionalResultMappingsenclosingType"ofType"ofType"resultType"resultChildren"extends"extends"autoMapping"resultMapResolver"processing "processing resultChild"constructor"constructor"discriminator""association"association"case"caseargChildrenargChild"idArg"idArg"column"caseChild"databaseId""select"selectSupplier<String>"notNullColumn""columnPrefix""resultSet""foreignColumn""lazy""fetchType"fetchType"eager"eagerListIterator<String>add(int,java.lang.String)set(int,java.lang.String)Comparator<? super String>UnaryOperator<String>Function<String,String>"collection""Ambiguous collection type for property '"Ambiguous collection type for property '"'. You must specify 'javaType' or 'resultMap'."'. You must specify 'javaType' or 'resultMap'.boundType ignore, it will be retried skip this fragment if there is a previous one with a not null databaseId ignore, bound type is not required Spring may not know the real resource name so we set a flag to prevent loading again this resource from the mapper interface look at MapperAnnotationBuilder#loadXmlResource/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/xml/XMLMapperEntityResolver.javagetInputSourcegetInputSource(java.lang.String,java.lang.String,java.lang.String)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/xml/XMLMapperEntityResolver.classMYBATIS_MAPPER_DTDMYBATIS_CONFIG_DTDMYBATIS_MAPPER_SYSTEMMYBATIS_CONFIG_SYSTEMIBATIS_MAPPER_SYSTEMIBATIS_CONFIG_SYSTEM"ibatis-3-config.dtd"ibatis-3-config.dtd"ibatis-3-mapper.dtd"ibatis-3-mapper.dtd"mybatis-3-config.dtd"mybatis-3-config.dtd"mybatis-3-mapper.dtd"mybatis-3-mapper.dtd"org/apache/ibatis/builder/xml/mybatis-3-config.dtd"org/apache/ibatis/builder/xml/mybatis-3-config.dtd"org/apache/ibatis/builder/xml/mybatis-3-mapper.dtd"org/apache/ibatis/builder/xml/mybatis-3-mapper.dtdpublicIdsystemIdlowerCaseSystemIdinOffline entity resolver for the MyBatis DTDs.Converts a public DTD into a local one.The public id that is what comes after "PUBLIC"The system id that is what comes after the public id.The InputSource for the DTDorg.xml.sax.SAXExceptionIf anything goes wrong ignore, null is ok/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/xml/XMLStatementBuilder.javagetLanguageDriver(java.lang.String)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/builder/xml/XMLStatementBuilder.classremoveSelectKeyNodesremoveSelectKeyNodes(java.util.List)parseSelectKeyNodeparseSelectKeyNode(java.lang.String,org.apache.ibatis.parsing.XNode,java.lang.Class,org.apache.ibatis.scripting.LanguageDriver,java.lang.String)parseSelectKeyNodesparseSelectKeyNodes(java.lang.String,java.util.List,java.lang.Class,org.apache.ibatis.scripting.LanguageDriver,java.lang.String)processSelectKeyNodesprocessSelectKeyNodes(java.lang.String,java.lang.Class,org.apache.ibatis.scripting.LanguageDriver)nodeName"flushCache""useCache""resultOrdered"includeParser"parameterType""lang"langDriverkeyStatementId"statementType""fetchSize""timeout""parameterMap""resultSetType""keyProperty""keyColumn""resultSets""affectData"affectDataselectKeyNodes"selectKey"parentIdskRequiredDatabaseIdnodeToHandle"BEFORE"BEFORE"order"order"AFTER"AFTERprevious Include Fragments before parsing Parse selectKey after includes and remove them. Parse the SQL (pre: <selectKey> and <include> were parsed and removed) skip this statement if there is a previous one with a not null databaseId issue #2/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/builder/xml/package-info.javaParses XML files to create a Configuration./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/Cache.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cacheorg.apache.ibatis.cacheSPI for cache providers.One instance of cache will be created for each namespace.The cache implementation must have a constructor that receives the cache id as an String parameter.MyBatis will pass the namespace as id to the constructor.public MyCache(final String id) {if (id == null) {throw new IllegalArgumentException("Cache instances require an ID");initialize();The identifier of this cacheCan be any object but usually it is a {@link CacheKey}The result of a select.The keyThe object stored in the cache.As of 3.3.0 this method is only called during a rollback for any previous value that was missing in the cache. Thislets any blocking cache to release the lock that may have previously put on the key. A blocking cache puts a lockwhen a value is null and releases it when the value is back again. This way other threads will wait for the valueto be available instead of hitting the database.Not usedClears this cache instance.Optional. This method is not called by the core.The number of elements stored in the cache (not its capacity).Optional. As of 3.2.6 this method is no longer called by the core.Any locking needed by the cache must be provided internally by the cache provider.A ReadWriteLock/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/CacheException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/CacheException.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache193202262468464650L193202262468464650/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/CacheKey.javaList<Object>updateList/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/CacheKey.classchecksumhashcodemultiplierDEFAULT_HASHCODEDEFAULT_MULTIPLIER1146682552656046210L1146682552656046210/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/CacheKey$1.classupdateAllupdateAll(java.lang.Object[])updateupdate(java.lang.Object)1Lobject"Not allowed to update a null cache key instance."Not allowed to update a null cache key instance.objects37ArrayList<Object>AbstractList<Object>AbstractCollection<Object>ArrayList<Object>()Spliterator<Object>Consumer<? super Object>Iterator<Object>Stream<Object>BaseStream<Object,Stream<Object>>Predicate<? super Object>Collection<? extends Object>Iterable<? extends Object>AbstractCollection<Object>()ListIterator<Object>Comparator<? super Object>UnaryOperator<Object>Function<Object,Object>AbstractList<Object>()ArrayList<Object>(java.util.Collection)ArrayList<Object>(int)baseHashCodeocacheKeythisObjectthatObjectreturnValue":"BiConsumer<? super String,? super DoubleConsumer>BiConsumer<? super String,? super LongConsumer>BiConsumer<? super String,? super IntConsumer>BiConsumer<? super String,? super Consumer<R>>Optional<String>Collector<? super String,A,R>BiConsumer<R,? super String>BiFunction<U,? super String,U>BinaryOperator<String>BiFunction<String,String,String>reduce(java.lang.String,java.util.function.BinaryOperator)Function<? super String,? extends DoubleStream>Function<? super String,? extends LongStream>Function<? super String,? extends IntStream>Function<? super String,? extends Stream<? extends R>>ToDoubleFunction<? super String>ToLongFunction<? super String>ToIntFunction<? super String>Function<? super String,? extends R>Consumer<String>Function<? super Object,? extends R>BiConsumer<? super Object,? super DoubleConsumer>BiConsumer<? super Object,? super LongConsumer>BiConsumer<? super Object,? super IntConsumer>BiConsumer<? super Object,? super Consumer<R>>Collector<? super Object,A,R>BiConsumer<R,? super Object>BiFunction<U,? super Object,U>BinaryOperator<Object>BiFunction<Object,Object,Object>Function<? super Object,? extends DoubleStream>Function<? super Object,? extends LongStream>Function<? super Object,? extends IntStream>Function<? super Object,? extends Stream<? extends R>>ToDoubleFunction<? super Object>ToLongFunction<? super Object>ToIntFunction<? super Object>Function<Object,String>Function<Object,V>Function<? super V,? extends Object>objaccept(java.lang.String)clonedCacheKey 8/21/2017 - Sonarlint flags this as needing to be marked transient. While true if content is not serializable, this is not always true and thus should not be marked transient./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/NullCacheKey.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/NullCacheKey.class3704229911977019465L3704229911977019465"Not allowed to update a NullCacheKey instance."Not allowed to update a NullCacheKey instance.Since 3.5.3, This class never used and will be removed future version./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/TransactionalCacheManager.javagetTransactionalCachegetTransactionalCache(org.apache.ibatis.cache.Cache)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/TransactionalCacheManager.classMap<Cache,TransactionalCache>transactionalCachesHashMap<Cache,TransactionalCache>AbstractMap<Cache,TransactionalCache>HashMap<Cache,TransactionalCache>()? super TransactionalCache? extends TransactionalCacheBiFunction<? super TransactionalCache,? super TransactionalCache,? extends TransactionalCache>merge(org.apache.ibatis.cache.Cache,org.apache.ibatis.cache.decorators.TransactionalCache,java.util.function.BiFunction)? super CacheBiFunction<? super Cache,? super TransactionalCache,? extends TransactionalCache>compute(org.apache.ibatis.cache.Cache,java.util.function.BiFunction)computeIfPresent(org.apache.ibatis.cache.Cache,java.util.function.BiFunction)Function<? super Cache,? extends TransactionalCache>computeIfAbsent(org.apache.ibatis.cache.Cache,java.util.function.Function)replace(org.apache.ibatis.cache.Cache,org.apache.ibatis.cache.decorators.TransactionalCache)replace(org.apache.ibatis.cache.Cache,org.apache.ibatis.cache.decorators.TransactionalCache,org.apache.ibatis.cache.decorators.TransactionalCache)putIfAbsent(org.apache.ibatis.cache.Cache,org.apache.ibatis.cache.decorators.TransactionalCache)BiConsumer<? super Cache,? super TransactionalCache>getOrDefault(java.lang.Object,org.apache.ibatis.cache.decorators.TransactionalCache)Entry<Cache,TransactionalCache>Set<Entry<Cache,TransactionalCache>>Collection<Entry<Cache,TransactionalCache>>Iterable<Entry<Cache,TransactionalCache>>Collection<TransactionalCache>Iterable<TransactionalCache>Set<Cache>Collection<Cache>Iterable<Cache>Map<? extends Cache,? extends TransactionalCache>put(org.apache.ibatis.cache.Cache,org.apache.ibatis.cache.decorators.TransactionalCache)AbstractMap<Cache,TransactionalCache>()HashMap<Cache,TransactionalCache>(java.util.Map)HashMap<Cache,TransactionalCache>(int)HashMap<Cache,TransactionalCache>(int,float)txCacheFunction<Cache,TransactionalCache>Function<Cache,V>Function<? super TransactionalCache,? extends V>Function<V,TransactionalCache>Function<? super V,? extends Cache>apply(org.apache.ibatis.cache.Cache)delegate/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/decorators/BlockingCache.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/decoratorsorg.apache.ibatis.cache.decoratorsreleaseLockreleaseLock(java.lang.Object)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/decorators/BlockingCache.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/decoratorsacquireLockacquireLock(java.lang.Object)ConcurrentHashMap<Object,CountDownLatch>AbstractMap<Object,CountDownLatch>Map<Object,CountDownLatch>ConcurrentMap<Object,CountDownLatch>locksConcurrentHashMap<Object,CountDownLatch>()? super CountDownLatch? extends CountDownLatchBiFunction<? super CountDownLatch,? super CountDownLatch,? extends CountDownLatch>merge(java.lang.Object,java.util.concurrent.CountDownLatch,java.util.function.BiFunction)BiFunction<? super Object,? super CountDownLatch,? extends CountDownLatch>Function<? super Object,? extends CountDownLatch>replace(java.lang.Object,java.util.concurrent.CountDownLatch)replace(java.lang.Object,java.util.concurrent.CountDownLatch,java.util.concurrent.CountDownLatch)putIfAbsent(java.lang.Object,java.util.concurrent.CountDownLatch)BiConsumer<? super Object,? super CountDownLatch>getOrDefault(java.lang.Object,java.util.concurrent.CountDownLatch)Entry<Object,CountDownLatch>Set<Entry<Object,CountDownLatch>>Collection<Entry<Object,CountDownLatch>>Iterable<Entry<Object,CountDownLatch>>Collection<CountDownLatch>Iterable<CountDownLatch>Map<? extends Object,? extends CountDownLatch>put(java.lang.Object,java.util.concurrent.CountDownLatch)AbstractMap<Object,CountDownLatch>()ToIntFunction<Entry<Object,CountDownLatch>>ToLongFunction<Entry<Object,CountDownLatch>>ToDoubleFunction<Entry<Object,CountDownLatch>>Function<Entry<Object,CountDownLatch>,? extends U>? extends Entry<Object,CountDownLatch>BiFunction<Entry<Object,CountDownLatch>,Entry<Object,CountDownLatch>,? extends Entry<Object,CountDownLatch>>? super Entry<Object,CountDownLatch>Consumer<? super Entry<Object,CountDownLatch>>ToIntFunction<? super CountDownLatch>ToLongFunction<? super CountDownLatch>ToDoubleFunction<? super CountDownLatch>Function<? super CountDownLatch,? extends U>Consumer<? super CountDownLatch>Function<? super Object,? extends U>ToIntBiFunction<? super Object,? super CountDownLatch>ToLongBiFunction<? super Object,? super CountDownLatch>ToDoubleBiFunction<? super Object,? super CountDownLatch>BiFunction<? super Object,? super CountDownLatch,? extends U>KeySetView<Object,CountDownLatch>CollectionView<Object,CountDownLatch,Object>keySet(java.util.concurrent.CountDownLatch)Enumeration<CountDownLatch>Enumeration<Object>ConcurrentHashMap<Object,CountDownLatch>(int,float,int)ConcurrentHashMap<Object,CountDownLatch>(int,float)ConcurrentHashMap<Object,CountDownLatch>(java.util.Map)ConcurrentHashMap<Object,CountDownLatch>(int)newLatchlatchacquired"Couldn't get a lock in "Couldn't get a lock in " for the key " for the key " at the cache " at the cache "Got interrupted while trying to acquire lock for key "Got interrupted while trying to acquire lock for key "Detected an attempt at releasing unacquired lock. This should never happen."Detected an attempt at releasing unacquired lock. This should never happen.Simple blocking decoratorSimple and inefficient version of EhCache's BlockingCache decorator. It sets a lock over a cache key when the elementis not found in cache. This way, other threads will wait until this element is filled instead of hitting thedatabase.By its nature, this implementation can cause deadlock when used incorrectly. despite its name, this method is called only to release locks/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/decorators/FifoCache.javacycleKeyListcycleKeyList(java.lang.Object)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/decorators/FifoCache.classDeque<Object>/BCDEFGHIJK/java.base/java/util/Deque.sigQueue<Object>/BCDEFGHIJK/java.base/java/util/Queue.sigkeyListLinkedList<Object>/89ABCDEFGHIJK/java.base/java/util/LinkedList.sigAbstractSequentialList<Object>/BCDEFGHIJK/java.base/java/util/AbstractSequentialList.sigLinkedList<Object>()AbstractSequentialListAbstractSequentialList()AbstractSequentialList<Object>()peek()elementelement()pollpoll()remove()offeroffer(java.lang.Object)descendingIteratordescendingIterator()poppop()pushpush(java.lang.Object)removeLastOccurrenceremoveLastOccurrence(java.lang.Object)removeFirstOccurrenceremoveFirstOccurrence(java.lang.Object)peekLastpeekLast()peekFirstpeekFirst()getLastgetLast()getFirstgetFirst()pollLastpollLast()pollFirstpollFirst()removeLastremoveLast()removeFirstremoveFirst()offerLastofferLast(java.lang.Object)offerFirstofferFirst(java.lang.Object)addLastaddLast(java.lang.Object)addFirstaddFirst(java.lang.Object)LinkedListLinkedList(java.util.Collection)LinkedList<Object>(java.util.Collection)LinkedList()1024oldestKeyFIFO (first in, first out) cache decorator./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/decorators/LoggingCache.javagetHitRatiogetHitRatio()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/decorators/LoggingCache.classlog"Cache Hit Ratio ["Cache Hit Ratio ["]: "]: /Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/decorators/LruCache.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/decorators/LruCache.classeldestKeykeyMap/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/decorators/LruCache$1.classLinkedHashMap<Object,Object>/89ABCDEFGHI/java.base/java/util/LinkedHashMap.sig/89ABCDEFGHI/java.base/java/util/89ABCDEFGHI/java.base/java/89ABCDEFGHI/java.base/89ABCDEFGHIHashMap<Object,Object>AbstractMap<Object,Object>Function<? super Object,? extends Object>BiConsumer<? super Object,? super Object>Entry<Object,Object>Set<Entry<Object,Object>>Collection<Entry<Object,Object>>Iterable<Entry<Object,Object>>Map<? extends Object,? extends Object>AbstractMap<Object,Object>()HashMap<Object,Object>(java.util.Map)HashMap<Object,Object>()HashMap<Object,Object>(int)HashMap<Object,Object>(int,float)removeEldestEntryremoveEldestEntry(java.util.Map.Entry)LinkedHashMapLinkedHashMap(int,float,boolean)LinkedHashMap<Object,Object>(int,float,boolean)LinkedHashMap(java.util.Map)LinkedHashMap<Object,Object>(java.util.Map)LinkedHashMap()LinkedHashMap<Object,Object>()LinkedHashMap(int)LinkedHashMap<Object,Object>(int)LinkedHashMap(int,float)LinkedHashMap<Object,Object>(int,float)(int,float,boolean).75F0.754267176411845948333L4267176411845948333arg1arg2eldesttooBigLru (least recently used) cache decorator. touch/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/decorators/ScheduledCache.javaclearWhenStaleclearWhenStale()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/decorators/ScheduledCache.classclearInterval/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/decorators/SerializedCache.javabytebyte[]deserializedeserialize(byte[])/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/decorators/SerializedCache.classserializeserialize(java.io.Serializable)"SharedCache failed to make a copy of a non-serializable object: "SharedCache failed to make a copy of a non-serializable object: bosoos"Error serializing object.  Cause: "Error serializing object.  Cause: bisois"Error deserializing object.  Cause: "Error deserializing object.  Cause: desc/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/decorators/SoftCache.javaremoveGarbageCollectedItemsremoveGarbageCollectedItems()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/decorators/SoftCache.classlocknumberOfHardLinksjava.lang.refReferenceQueue<Object>/89ABCDEFGHI/java.base/java/lang/ref/ReferenceQueue.sig/89ABCDEFGHI/java.base/java/lang/ref/89ABCDEFGHI/java.base/java/langqueueOfGarbageCollectedEntrieshardLinksToAvoidGarbageCollection256ReferenceQueue<Object>()Reference<>/GHI/java.base/java/lang/ref/Reference.sig/GHI/java.base/java/lang/ref/GHI/java.base/java/lang/GHI/java.base/java/GHI/java.base/GHIReference<? extends T>Reference<? extends Object>remove(long)ReferenceQueueReferenceQueue()SoftReference<Object>/BCDEFGHIJK/java.base/java/lang/ref/SoftReference.sig/BCDEFGHIJK/java.base/java/lang/refReference<Object>softReferenceisEnqueuedisEnqueued()refersTorefersTo(java.lang.Object)reachabilityFencereachabilityFence(java.lang.Object)enqueueenqueue()ReferenceQueue<? super T>SoftReferenceSoftReference(java.lang.Object,java.lang.ref.ReferenceQueue)ReferenceQueue<? super Object>SoftReference<Object>(java.lang.Object,java.lang.ref.ReferenceQueue)SoftReference(java.lang.Object)SoftReference<Object>(java.lang.Object)svSoftEntrySoftEntry(java.lang.Object,java.lang.Object,java.lang.ref.ReferenceQueue)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/decorators/SoftCache$SoftEntry.classgarbageCollectionQueueSoft Reference cache decorator.Thanks to Dr. Heinz Kabutz for his guidance here. assumed delegate cache is totally managed by this cache See #586 (and #335) modifications need more than a read lock/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/decorators/SynchronizedCache.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/decorators/SynchronizedCache.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/decorators/TransactionalCache.javaunlockMissedEntriesunlockMissedEntries()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/decorators/TransactionalCache.classflushPendingEntriesflushPendingEntries()resetreset()entriesMissedInCacheentriesToAddOnCommitclearOnCommitClass<TransactionalCache>HashSet<Object>AbstractSet<Object>HashSet<Object>()AbstractSet<Object>()HashSet<Object>(int)HashSet<Object>(int,float)HashSet<Object>(java.util.Collection)"Unexpected exception while notifying a rollback to the cache adapter. "
            + "Consider upgrading your cache adapter to the latest version. Cause: "Unexpected exception while notifying a rollback to the cache adapter. Consider upgrading your cache adapter to the latest version. Cause: The 2nd level cache transactional buffer.This class holds all cache entries that are to be added to the 2nd level cache during a Session. Entries are sent tothe cache when commit is called or discarded if the Session is rolled back. Blocking cache support has been added.Therefore any get() that returns a cache miss will be followed by a put() so any lock associated with the key can bereleased. issue #116 issue #146/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/decorators/WeakCache.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/decorators/WeakCache.classWeakReference<Object>/BCDEFGHIJK/java.base/java/lang/ref/WeakReference.sigweakReferenceWeakEntryWeakEntry(java.lang.Object,java.lang.Object,java.lang.ref.ReferenceQueue)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/decorators/WeakCache$WeakEntry.classWeak Reference cache decorator./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/decorators/package-info.javaContains cache decorators./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/impl/PerpetualCache.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/implorg.apache.ibatis.cache.impl/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/impl/PerpetualCache.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cache/implotherCache"Cache instances require an ID."Cache instances require an ID./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/impl/package-info.javaContains the default cache implementation./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cache/package-info.javaBase package for caching stuff./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cursor/Cursor.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cursorCursor contract to handle fetching items lazily using an Iterator. Cursors are a perfect fit to handle millions ofitems queries that would not normally fit in memory. If you use collections in resultMaps then cursor SQL queriesmust be ordered (resultOrdered="true") using the id columns of the resultMap.Guillaume Darmont / guillaume@dropinocean.comtrue if the cursor has started to fetch items from database.true if the cursor is fully consumed and has returned all elements matching the query.Get the current item index. The first item has the index 0.-1 if the first cursor item has not been retrieved. The index of the current item retrieved./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cursor/defaults/DefaultCursor.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cursor/defaultsorg.apache.ibatis.cursor.defaultsgetReadItemsCountgetReadItemsCount()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cursor/defaults/DefaultCursor.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cursor/defaultsisClosedisClosed()indexWithRowBoundstatusiteratorRetrievedcursorIteratorrswresultSetHandlerObjectWrapperResultHandler<T>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cursor/defaults/DefaultCursor$ObjectWrapperResultHandler.classResultHandler<T>ObjectWrapperResultHandler<T>()ResultContext<? extends T>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/ResultContext.classhandleResulthandleResult(org.apache.ibatis.session.ResultContext)fetchedObjectWrapperResultHandlerObjectWrapperResultHandler()CursorStatusCursorStatus()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cursor/defaults/DefaultCursor$CursorStatus.class"Cannot open more than one iterator on a Cursor"Cannot open more than one iterator on a Cursor"A Cursor is already closed."A Cursor is already closed.rsnextResultHandler<?>getResultObjectgetResultObject()stopstop()isStoppedisStopped()getResultCountgetResultCount()iteratorIndex/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/cursor/defaults/DefaultCursor$CursorIterator.class"Cannot remove element from Cursor"Cannot remove element from CursorThis is the default implementation of a MyBatis Cursor. This implementation is not thread safe. ResultSetHandler stuffA freshly created cursor, database ResultSet consuming has not started.A cursor currently in use, database ResultSet consuming has started.A closed cursor, not fully consumed.A fully consumed cursor, a consumed cursor is always closed. ignore No more object or limit reachedHolder for the next object to be returned.Index of objects returned using next(), and as such, visible to users. Fill next with object fetched from hasNext()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cursor/defaults/package-info.javaDefault implementation for cursor feature./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/cursor/package-info.javaBase package for cursor feature./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/datasource/DataSourceException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/datasourceorg.apache.ibatis.datasource/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/datasource/DataSourceException.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/datasource5251396250407091334L5251396250407091334/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/datasource/DataSourceFactory.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/datasource/jndi/JndiDataSourceFactory.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/datasource/jndiorg.apache.ibatis.datasource.jndigetEnvPropertiesgetEnvProperties(java.util.Properties)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/datasource/jndi/JndiDataSourceFactory.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/datasource/jndi"initial_context"initial_context"data_source"data_source"env."env.initCtxenvHashtable<?,?>/89ABCDEFGH/java.base/java/util/Hashtable.sigDictionary<?,?>/BCDEFGHIJK/java.base/java/util/Dictionary.sigctx"There was an error configuring JndiDataSourceTransactionPool. Cause: "There was an error configuring JndiDataSourceTransactionPool. Cause: allPropsPREFIXcontextProperties/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/datasource/jndi/package-info.javaJNDI Datasource factory./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/datasource/package-info.javaBase package for Datasources./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/datasource/pooled/PoolState.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/datasource/pooledorg.apache.ibatis.datasource.pooled/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/datasource/pooled/PoolState.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/datasource/pooledList<PooledConnection>Collection<PooledConnection>Iterable<PooledConnection>ArrayList<PooledConnection>AbstractList<PooledConnection>AbstractCollection<PooledConnection>ArrayList<PooledConnection>()Spliterator<PooledConnection>? super PooledConnectionConsumer<? super PooledConnection>Iterator<PooledConnection>Stream<PooledConnection>BaseStream<PooledConnection,Stream<PooledConnection>>Predicate<? super PooledConnection>? extends PooledConnectionCollection<? extends PooledConnection>Iterable<? extends PooledConnection>add(org.apache.ibatis.datasource.pooled.PooledConnection)AbstractCollection<PooledConnection>()ListIterator<PooledConnection>add(int,org.apache.ibatis.datasource.pooled.PooledConnection)set(int,org.apache.ibatis.datasource.pooled.PooledConnection)Comparator<? super PooledConnection>UnaryOperator<PooledConnection>Function<PooledConnection,PooledConnection>AbstractList<PooledConnection>()ArrayList<PooledConnection>(java.util.Collection)ArrayList<PooledConnection>(int)"\n===CONFIGURATION=============================================="
===CONFIGURATION=============================================="\n jdbcDriver                     "
 jdbcDriver                     "\n jdbcUrl                        "
 jdbcUrl                        "\n jdbcUsername                   "
 jdbcUsername                   "\n jdbcPassword                   "
 jdbcPassword                   "NULL"NULL"************"************"\n poolMaxActiveConnections       "
 poolMaxActiveConnections       "\n poolMaxIdleConnections         "
 poolMaxIdleConnections         "\n poolMaxCheckoutTime            "
 poolMaxCheckoutTime            "\n poolTimeToWait                 "
 poolTimeToWait                 "\n poolPingEnabled                "
 poolPingEnabled                "\n poolPingQuery                  "
 poolPingQuery                  "\n poolPingConnectionsNotUsedFor  "
 poolPingConnectionsNotUsedFor  "\n ---STATUS-----------------------------------------------------"
 ---STATUS-----------------------------------------------------"\n activeConnections              "
 activeConnections              "\n idleConnections                "
 idleConnections                "\n requestCount                   "
 requestCount                   "\n averageRequestTime             "
 averageRequestTime             "\n averageCheckoutTime            "
 averageCheckoutTime            "\n claimedOverdue                 "
 claimedOverdue                 "\n averageOverdueCheckoutTime     "
 averageOverdueCheckoutTime     "\n hadToWait                      "
 hadToWait                      "\n averageWaitTime                "
 averageWaitTime                "\n badConnectionCount             "
 badConnectionCount             "\n==============================================================="
=============================================================== This lock does not guarantee consistency. Field values can be modified in PooledDataSource after the instance is returned from PooledDataSource#getPoolState(). A possible fix is to create and return a 'snapshot'./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/datasource/pooled/PooledConnection.javacheckConnectioncheckConnection()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/datasource/pooled/PooledConnection.classvalidconnectionTypeCodelastUsedTimestampcreatedTimestampcheckoutTimestampproxyConnectionrealConnectionIFACESCLOSE"close"Class<Connection>? super ConnectionClass<? super Connection>Constructor<Connection>Connection[]TypeVariable<Class<Connection>>TypeVariable<Class<Connection>>[]timestamp"Error accessing PooledConnection. Connection is invalid."Error accessing PooledConnection. Connection is invalid.Constructor for SimplePooledConnection that uses the Connection and PooledDataSource passed in.- the connection that is to be presented as a pooled connection- the dataSource that the connection is fromInvalidates the connection.Method to see if the connection is usable.True if the connection is usableGetter for the *real* connection that this wraps.The connectionGetter for the proxy for the connection.The proxyGets the hashcode of the real connection (or 0 if it is null).The hashcode of the real connection (or 0 if it is null)Getter for the connection type (based on url + user + password).The connection typeSetter for the connection type.- the connection typeGetter for the time that the connection was created.The creation timestampSetter for the time that the connection was created.- the timestampGetter for the time that the connection was last used.Setter for the time that the connection was last used.Getter for the time since this connection was last used.- the time since the last useGetter for the age of the connection.the ageGetter for the timestamp that this connection was checked out.the timestampSetter for the timestamp that this connection was checked out.Getter for the time that this connection has been checked out.the timeAllows comparing this connection to another.- the other connection to test for equalityObject#equals(Object)Required for InvocationHandler implementation.- not used- the method to be executed- the parameters to be passed to the methodjava.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[]) issue #579 toString() should never fail throw an SQLException instead of a Runtime/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/datasource/pooled/PooledDataSource.javapopConnectionpopConnection(java.lang.String,java.lang.String)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/datasource/pooled/PooledDataSource.classassembleConnectionTypeCodeassembleConnectionTypeCode(java.lang.String,java.lang.String,java.lang.String)conditionexpectedConnectionTypeCodestate105200003"NO PING QUERY SET"NO PING QUERY SETClass<PooledDataSource>driverusernamepassworddriverPropertiesdriverClassLoaderloginTimeoutlogWriterdefaultAutoCommitdefaultTransactionIsolationLeveldriverPropsmillisecondspoolMaximumActiveConnectionspoolMaximumIdleConnectionspoolMaximumLocalBadConnectionTolerancepoolMaximumCheckoutTimepoolTimeToWaitpoolPingQuerypoolPingEnabledconnrealConn"PooledDataSource forcefully closed/removed all connections."PooledDataSource forcefully closed/removed all connections.newConn"Returned connection "Returned connection " to pool." to pool."Closed connection "Closed connection "A bad connection ("A bad connection (") attempted to return to the pool, discarding connection.") attempted to return to the pool, discarding connection.countedWaitlocalBadConnectionCount"Checked out connection "Checked out connection " from pool." from pool."Created connection "Created connection oldestActiveConnectionlongestCheckoutTime"Bad connection. Could not roll back"Bad connection. Could not roll back"Claimed overdue connection "Claimed overdue connection wt"Waiting as long as "Waiting as long as " milliseconds for connection." milliseconds for connection."Wait failed..."Wait failed...") was returned from the pool, getting another connection.") was returned from the pool, getting another connection."PooledDataSource: Could not get a good connection to the database."PooledDataSource: Could not get a good connection to the database."PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection."PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection."Connection "Connection " is BAD: " is BAD: "Testing connection "Testing connection " ..." ..." is GOOD!" is GOOD!"Execution of ping query '"Execution of ping query '"' failed: "' failed: ? extends ConnectionClass<? extends Connection>iface? extends PooledDataSourceClass<? extends PooledDataSource>Constructor<? extends PooledDataSource>PooledDataSource[]TypeVariable<Class<? extends PooledDataSource>>TypeVariable<Class<? extends PooledDataSource>>[]" is not a wrapper." is not a wrapper.This is a simple, synchronous, thread-safe database connection pool. OPTIONAL CONFIGURATION FIELDSSets the default network timeout value to wait for the database operation to complete. See{@link Connection#setNetworkTimeout(java.util.concurrent.Executor, int)}The time in milliseconds to wait for the database operation to complete.The maximum number of active connections.The maximum number of active connectionsThe maximum number of idle connections.The maximum number of idle connectionsThe maximum number of tolerance for bad connection happens in one thread which are applying for new{@link PooledConnection}.max tolerance for bad connection happens in one threadThe maximum time a connection can be used before it *may* be given away again.The maximum timeThe time to wait before retrying to get a connection.The time to waitThe query to be used to check a connection.The queryDetermines if the ping query should be used.True if we need to check a connection before using itIf a connection has not been used in this many milliseconds, ping the database to make sure the connection is stillgood.the number of milliseconds of inactivity that will trigger a pingGets the default network timeout.the default network timeoutCloses all active and idle connections in the pool. Pool has available connection Pool does not have available connection and can create a new connection Cannot create new connection Can claim overdue connectionJust log a message for debug and continue to execute the following statement like nothing happened.Wrap the bad connection with a new PooledConnection, this will help to not interrupt currentexecuting thread and give current thread a chance to join the next competition for another valid/gooddatabase connection. At the end of this loop, bad {@link @conn} will be set as null. Must wait set interrupt flag ping to server and check the connection is valid or notMethod to check to see if a connection is still usable- the connection to checkTrue if the connection is still usableUnwraps a pooled connection to get to the 'real' connection- the pooled connection to unwrapThe 'real' connection/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/datasource/pooled/PooledDataSourceFactory.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/datasource/pooled/package-info.javaSimple single-thread pooled datasource./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/datasource/unpooled/UnpooledDataSource.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/datasource/unpooledorg.apache.ibatis.datasource.unpooledconfigureConnectionconfigureConnection(java.sql.Connection)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/datasource/unpooled/UnpooledDataSource.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/datasource/unpooledinitializeDriverinitializeDriver()doGetConnectiondoGetConnection(java.util.Properties)doGetConnection(java.lang.String,java.lang.String)defaultNetworkTimeoutautoCommitMap<String,Driver>registeredDriversConcurrentHashMap<String,Driver>AbstractMap<String,Driver>ConcurrentMap<String,Driver>ConcurrentHashMap<String,Driver>()? super Driver? extends DriverBiFunction<? super Driver,? super Driver,? extends Driver>merge(java.lang.String,java.sql.Driver,java.util.function.BiFunction)BiFunction<? super String,? super Driver,? extends Driver>Function<? super String,? extends Driver>replace(java.lang.String,java.sql.Driver)replace(java.lang.String,java.sql.Driver,java.sql.Driver)putIfAbsent(java.lang.String,java.sql.Driver)BiConsumer<? super String,? super Driver>getOrDefault(java.lang.Object,java.sql.Driver)Entry<String,Driver>Set<Entry<String,Driver>>Collection<Entry<String,Driver>>Iterable<Entry<String,Driver>>Collection<Driver>Iterable<Driver>Map<? extends String,? extends Driver>put(java.lang.String,java.sql.Driver)AbstractMap<String,Driver>()ToIntFunction<Entry<String,Driver>>ToLongFunction<Entry<String,Driver>>ToDoubleFunction<Entry<String,Driver>>Function<Entry<String,Driver>,? extends U>? extends Entry<String,Driver>BiFunction<Entry<String,Driver>,Entry<String,Driver>,? extends Entry<String,Driver>>? super Entry<String,Driver>Consumer<? super Entry<String,Driver>>ToIntFunction<? super Driver>ToLongFunction<? super Driver>ToDoubleFunction<? super Driver>Function<? super Driver,? extends U>Consumer<? super Driver>Function<? super String,? extends U>ToIntBiFunction<? super String,? super Driver>ToLongBiFunction<? super String,? super Driver>ToDoubleBiFunction<? super String,? super Driver>BiFunction<? super String,? super Driver,? extends U>KeySetView<String,Driver>CollectionView<String,Driver,String>keySet(java.sql.Driver)Enumeration<Driver>Enumeration<String>ConcurrentHashMap<String,Driver>(int,float,int)ConcurrentHashMap<String,Driver>(int,float)ConcurrentHashMap<String,Driver>(java.util.Map)ConcurrentHashMap<String,Driver>(int)drivershasMoreElementshasMoreElements()asIteratorasIterator()Iterator<Driver>nextElementnextElement()Class<? extends Driver>Constructor<? extends Driver>Driver[]TypeVariable<Class<? extends Driver>>TypeVariable<Class<? extends Driver>>[]"user"user"password"Function<String,Driver>Function<String,V>Function<? super Driver,? extends V>Function<V,Driver>Function<? super V,? extends String>apply(java.lang.String)driverTypedriverInstance"Error setting driver on UnpooledDataSource."Error setting driver on UnpooledDataSource.DriverProxyDriverProxy(java.sql.Driver)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/datasource/unpooled/UnpooledDataSource$DriverProxy.classduDriverPropertyInfo[]? extends UnpooledDataSourceClass<? extends UnpooledDataSource>Constructor<? extends UnpooledDataSource>UnpooledDataSource[]TypeVariable<Class<? extends UnpooledDataSource>>TypeVariable<Class<? extends UnpooledDataSource>>[] requires JDK version 1.6/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/datasource/unpooled/UnpooledDataSourceFactory.javaconvertValueconvertValue(org.apache.ibatis.reflection.MetaObject,java.lang.String,java.lang.String)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/datasource/unpooled/UnpooledDataSourceFactory.classDRIVER_PROPERTY_PREFIX_LENGTHDRIVER_PROPERTY_PREFIX"driver."driver.metaDataSourcepropertyNameconvertedValue"Unknown DataSource property: "Unknown DataSource property: "driverProperties"targetType/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/datasource/unpooled/package-info.javaHyper-simple Datasource./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/exceptions/ExceptionFactory.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/exceptionsorg.apache.ibatis.exceptionsExceptionFactoryExceptionFactory()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/exceptions/ExceptionFactory.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/exceptions Prevent Instantiation/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/exceptions/IbatisException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/exceptions/IbatisException.class3880206998166270511L3880206998166270511/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/exceptions/PersistenceException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/exceptions/PersistenceException.class"deprecation"deprecation7537395265357977271L7537395265357977271/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/exceptions/TooManyResultsException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/exceptions/TooManyResultsException.class8935197089745865786L8935197089745865786/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/exceptions/package-info.javaBase package for exceptions./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/BaseExecutor.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executororg.apache.ibatis.executorEXECUTION_PLACEHOLDER/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/BaseExecutor.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executorqueryFromDatabasequeryFromDatabase(org.apache.ibatis.mapping.MappedStatement,java.lang.Object,org.apache.ibatis.session.RowBounds,org.apache.ibatis.session.ResultHandler,org.apache.ibatis.cache.CacheKey,org.apache.ibatis.mapping.BoundSql)handleLocallyCachedOutputParametershandleLocallyCachedOutputParameters(org.apache.ibatis.mapping.MappedStatement,org.apache.ibatis.cache.CacheKey,java.lang.Object,org.apache.ibatis.mapping.BoundSql)closedClass<BaseExecutor>ConcurrentLinkedQueue<DeferredLoad>/9ABCDEFGHIJK/java.base/java/util/concurrent/ConcurrentLinkedQueue.sig/9ABCDEFGHIJK/java.base/java/util/concurrentAbstractQueue<DeferredLoad>/BCDEFGHIJK/java.base/java/util/AbstractQueue.sigAbstractCollection<DeferredLoad>Collection<DeferredLoad>Iterable<DeferredLoad>Queue<DeferredLoad>transactionConcurrentLinkedQueue<DeferredLoad>()Spliterator<DeferredLoad>? super DeferredLoadConsumer<? super DeferredLoad>Iterator<DeferredLoad>Stream<DeferredLoad>BaseStream<DeferredLoad,Stream<DeferredLoad>>Predicate<? super DeferredLoad>? extends DeferredLoadCollection<? extends DeferredLoad>Iterable<? extends DeferredLoad>add(org.apache.ibatis.executor.BaseExecutor.DeferredLoad)AbstractCollection<DeferredLoad>()offer(org.apache.ibatis.executor.BaseExecutor.DeferredLoad)AbstractQueueAbstractQueue()AbstractQueue<DeferredLoad>()ConcurrentLinkedQueueConcurrentLinkedQueue(java.util.Collection)ConcurrentLinkedQueue<DeferredLoad>(java.util.Collection)ConcurrentLinkedQueue()"LocalCache"LocalCache"LocalOutputParameterCache"LocalOutputParameterCache"Executor was closed."Executor was closed.forceRollback"Unexpected exception on closing transaction.  Cause: "Unexpected exception on closing transaction.  Cause: "executing an update"executing an updateisRollBackresultHandlerboundSql"executing a query"executing a querydeferredLoadCursor<E>resultObjecttypeHandlerRegistryrequired"Cannot commit, transaction is already closed"Cannot commit, transaction is already closedisRollbackcachedParametermetaCachedParametermetaParameterparameterNamecachedValuestatementLogwrapperresultExtractor/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/BaseExecutor$DeferredLoad.classlocalCache Ignore. There's nothing that can be done at this point. issue #601 issue #482 mimic DefaultParameterHandler logic issue #176Apply a transaction timeout.a current statementSQLExceptionif a database access error occurs, this method is called on a closed <code>Statement</code>3.4.0StatementUtil#applyTransactionTimeout(Statement, Integer, Integer) issue #781 we suppose we get back a List/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/BatchExecutor.javacurrentStatement/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/BatchExecutor.classcurrentSqlbatchResultListList<Statement>Collection<Statement>Iterable<Statement>statementListArrayList<Statement>AbstractList<Statement>AbstractCollection<Statement>ArrayList<Statement>()Spliterator<Statement>? super StatementConsumer<? super Statement>Iterator<Statement>Stream<Statement>BaseStream<Statement,Stream<Statement>>Predicate<? super Statement>? extends StatementCollection<? extends Statement>Iterable<? extends Statement>add(java.sql.Statement)AbstractCollection<Statement>()ListIterator<Statement>add(int,java.sql.Statement)set(int,java.sql.Statement)Comparator<? super Statement>UnaryOperator<Statement>Function<Statement,Statement>AbstractList<Statement>()ArrayList<Statement>(java.util.Collection)ArrayList<Statement>(int)ArrayList<BatchResult>AbstractList<BatchResult>AbstractCollection<BatchResult>ArrayList<BatchResult>()Spliterator<BatchResult>? super BatchResultConsumer<? super BatchResult>Iterator<BatchResult>Stream<BatchResult>BaseStream<BatchResult,Stream<BatchResult>>Predicate<? super BatchResult>? extends BatchResultCollection<? extends BatchResult>Iterable<? extends BatchResult>add(org.apache.ibatis.executor.BatchResult)AbstractCollection<BatchResult>()ListIterator<BatchResult>add(int,org.apache.ibatis.executor.BatchResult)set(int,org.apache.ibatis.executor.BatchResult)Comparator<? super BatchResult>UnaryOperator<BatchResult>Function<BatchResult,BatchResult>AbstractList<BatchResult>()ArrayList<BatchResult>(java.util.Collection)ArrayList<BatchResult>(int)1002stmtlastbatchResultcursorparameterObjectsint[]Class<Jdbc3KeyGenerator>? extends KeyGeneratorClass<? extends KeyGenerator>jdbc3KeyGeneratorClass<NoKeyGenerator>" (batch index #" (batch index #")"" failed." failed." prior sub executor(s) completed successfully, but will be rolled back." prior sub executor(s) completed successfully, but will be rolled back. fix Issues 322 issue #141 Close statement to close cursor #1109/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/BatchExecutorException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/BatchExecutorException.classbatchUpdateExceptionsuccessfulBatchResults154049229650533990L154049229650533990" Cause: " Cause: This exception is thrown if a <code>java.sql.BatchUpdateException</code> is caught during the execution of any nestedbatch. The exception contains the java.sql.BatchUpdateException that is the root cause, as well as the results fromany prior nested batch that executed successfully.Returns the BatchUpdateException that caused the nested executor to fail. That exception contains an array of rowcounts that can be used to determine exactly which statement of the executor caused the failure (or failures).the root BatchUpdateExceptionReturns a list of BatchResult objects. There will be one entry in the list for each successful sub-executorexecuted before the failing executor.the previously successful executor results (maybe an empty list if no executor has executed successfully)Returns the SQL statement that caused the failure (not the parameterArray).the failing SQL stringReturns the statement id of the statement that caused the failure./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/BatchResult.javaupdateCounts/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/BatchResult.classmappedStatement/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/CachingExecutor.javaflushCacheIfRequiredflushCacheIfRequired(org.apache.ibatis.mapping.MappedStatement)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/CachingExecutor.classensureNoOutParamsensureNoOutParams(org.apache.ibatis.mapping.MappedStatement,org.apache.ibatis.mapping.BoundSql)tcm"Caching stored procedures with OUT params is not supported.  Please configure useCache=false in "Caching stored procedures with OUT params is not supported.  Please configure useCache=false in " statement." statement.executor"This method should not be called"This method should not be called issues #499, #524 and #573 issue #578 and #116/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/ErrorContext.javaErrorContextErrorContext()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/ErrorContext.classactivitystoredThreadLocal<ErrorContext>/89ABCDEFGHIJK/java.base/java/lang/ThreadLocal.sig/89ABCDEFGHIJK/java.base/java/langLOCALLINE_SEPARATORThreadLocal<>Supplier<ErrorContext>set(java.lang.Object)set(org.apache.ibatis.executor.ErrorContext)ThreadLocalThreadLocal()ThreadLocal<ErrorContext>()SThreadLocal<S>withInitialwithInitial(java.util.function.Supplier)? extends SSupplier<? extends S>initialValueinitialValue()newContext"### "### "### The error may exist in "### The error may exist in "### The error may involve "### The error may involve "### The error occurred while "### The error occurred while "### SQL: "### SQL: '\n''\r''\t'	"### Cause: "### Cause:  message resource object activity sql cause/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/ExecutionPlaceholder.javaExecutionPlaceholderExecutionPlaceholder()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/ExecutionPlaceholder.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/Executor.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/ExecutorException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/ExecutorException.class4060977051977364820L4060977051977364820/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/ResultExtractor.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/ResultExtractor.class"Statement returned more than one row, where no more than one was expected."Statement returned more than one row, where no more than one was expected.Andrew Gustafson/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/ReuseExecutor.javaputStatementputStatement(java.lang.String,java.sql.Statement)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/ReuseExecutor.classgetStatementgetStatement(java.lang.String)hasStatementForhasStatementFor(java.lang.String)prepareStatementprepareStatement(org.apache.ibatis.executor.statement.StatementHandler,org.apache.ibatis.logging.Log)Map<String,Statement>statementMapHashMap<String,Statement>AbstractMap<String,Statement>HashMap<String,Statement>()BiFunction<? super Statement,? super Statement,? extends Statement>merge(java.lang.String,java.sql.Statement,java.util.function.BiFunction)BiFunction<? super String,? super Statement,? extends Statement>Function<? super String,? extends Statement>replace(java.lang.String,java.sql.Statement)replace(java.lang.String,java.sql.Statement,java.sql.Statement)putIfAbsent(java.lang.String,java.sql.Statement)BiConsumer<? super String,? super Statement>getOrDefault(java.lang.Object,java.sql.Statement)Entry<String,Statement>Set<Entry<String,Statement>>Collection<Entry<String,Statement>>Iterable<Entry<String,Statement>>Map<? extends String,? extends Statement>put(java.lang.String,java.sql.Statement)AbstractMap<String,Statement>()HashMap<String,Statement>(java.util.Map)HashMap<String,Statement>(int)HashMap<String,Statement>(int,float)s/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/SimpleExecutor.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/SimpleExecutor.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/keygen/Jdbc3KeyGenerator.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/keygenorg.apache.ibatis.executor.keygencollectionizecollectionize(java.lang.Object)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/keygen/Jdbc3KeyGenerator.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/keygenMap<String,?>nameOfSingleParamnameOfSingleParam(java.util.Map)Entry<String,KeyAssigner>getAssignerForSingleParamgetAssignerForSingleParam(org.apache.ibatis.session.Configuration,java.sql.ResultSetMetaData,int,java.util.Map,java.lang.String,boolean)getAssignerForParamMapgetAssignerForParamMap(org.apache.ibatis.session.Configuration,java.sql.ResultSetMetaData,int,java.util.Map,java.lang.String,java.lang.String[],boolean)assignKeysToParamMapassignKeysToParamMap(org.apache.ibatis.session.Configuration,java.sql.ResultSet,java.sql.ResultSetMetaData,java.lang.String[],java.util.Map)ParamMap<?>HashMap<String,?>AbstractMap<String,?>ArrayList<ParamMap<?>>AbstractList<ParamMap<?>>AbstractCollection<ParamMap<?>>Collection<ParamMap<?>>Iterable<ParamMap<?>>List<ParamMap<?>>assignKeysToParamMapListassignKeysToParamMapList(org.apache.ibatis.session.Configuration,java.sql.ResultSet,java.sql.ResultSetMetaData,java.lang.String[],java.util.ArrayList)assignKeysToParamassignKeysToParam(org.apache.ibatis.session.Configuration,java.sql.ResultSet,java.sql.ResultSetMetaData,java.lang.String[],java.lang.Object)assignKeysassignKeys(org.apache.ibatis.session.Configuration,java.sql.ResultSet,java.sql.ResultSetMetaData,java.lang.String[],java.lang.Object)MSG_TOO_MANY_KEYSSECOND_GENERIC_PARAM_NAME"2""Too many keys are generated. There are only %d target objects. "
      + "You either specified a wrong 'keyProperty' or encountered a driver bug like #1523."Too many keys are generated. There are only %d target objects. You either specified a wrong 'keyProperty' or encountered a driver bug like #1523.keyPropertiesrsmd"Error getting generated key or setting result to parameter object. Cause: "Error getting generated key or setting result to parameter object. Cause: org.apache.ibatis.session.defaultsStrictMap<>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/defaults/DefaultSqlSession$StrictMap.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/defaults/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/defaults/DefaultSqlSession.classArrayList<>AbstractList<>AbstractCollection<>ArrayList<?>AbstractList<?>AbstractCollection<?>List<?>Spliterator<?>Iterator<?>Stream<?>BaseStream<?,Stream<?>>add(<nulltype>)AbstractCollection<?>()ListIterator<?>add(int,<nulltype>)set(int,<nulltype>)UnaryOperator<?>Function<?,?>AbstractList<?>()ArrayList<?>(java.util.Collection)ArrayList<?>()ArrayList<?>(int)List<KeyAssigner>Collection<KeyAssigner>Iterable<KeyAssigner>assignerListArrayList<KeyAssigner>AbstractList<KeyAssigner>AbstractCollection<KeyAssigner>ArrayList<KeyAssigner>()Spliterator<KeyAssigner>? super KeyAssignerConsumer<? super KeyAssigner>Iterator<KeyAssigner>Stream<KeyAssigner>BaseStream<KeyAssigner,Stream<KeyAssigner>>Predicate<? super KeyAssigner>? extends KeyAssignerCollection<? extends KeyAssigner>Iterable<? extends KeyAssigner>add(org.apache.ibatis.executor.keygen.Jdbc3KeyGenerator.KeyAssigner)AbstractCollection<KeyAssigner>()ListIterator<KeyAssigner>add(int,org.apache.ibatis.executor.keygen.Jdbc3KeyGenerator.KeyAssigner)set(int,org.apache.ibatis.executor.keygen.Jdbc3KeyGenerator.KeyAssigner)Comparator<? super KeyAssigner>UnaryOperator<KeyAssigner>Function<KeyAssigner,KeyAssigner>AbstractList<KeyAssigner>()ArrayList<KeyAssigner>(java.util.Collection)ArrayList<KeyAssigner>(int)next()forEachRemainingforEachRemaining(java.util.function.Consumer)hasNexthasNext()Consumer<KeyAssigner>accept(org.apache.ibatis.executor.keygen.Jdbc3KeyGenerator.KeyAssigner)paramMapListIterator<ParamMap<?>>Spliterator<ParamMap<?>>? super ParamMap<?>Consumer<? super ParamMap<?>>Stream<ParamMap<?>>BaseStream<ParamMap<?>,Stream<ParamMap<?>>>Predicate<? super ParamMap<?>>? extends ParamMap<?>Collection<? extends ParamMap<?>>Iterable<? extends ParamMap<?>>add(org.apache.ibatis.binding.MapperMethod.ParamMap)AbstractCollection<ParamMap<?>>()ListIterator<ParamMap<?>>add(int,org.apache.ibatis.binding.MapperMethod.ParamMap)set(int,org.apache.ibatis.binding.MapperMethod.ParamMap)Comparator<? super ParamMap<?>>UnaryOperator<ParamMap<?>>Function<ParamMap<?>,ParamMap<?>>AbstractList<ParamMap<?>>()ArrayList<ParamMap<?>>(java.util.Collection)ArrayList<ParamMap<?>>()ArrayList<ParamMap<?>>(int)counterparamMapsetValue(org.apache.ibatis.executor.keygen.Jdbc3KeyGenerator.KeyAssigner)Entry<Iterator<?>,List<KeyAssigner>>Map<String,Entry<Iterator<?>,List<KeyAssigner>>>assignerMapHashMap<String,Entry<Iterator<?>,List<KeyAssigner>>>AbstractMap<String,Entry<Iterator<?>,List<KeyAssigner>>>HashMap<String,Entry<Iterator<?>,List<KeyAssigner>>>()? super Entry<Iterator<?>,List<KeyAssigner>>? extends Entry<Iterator<?>,List<KeyAssigner>>BiFunction<? super Entry<Iterator<?>,List<KeyAssigner>>,? super Entry<Iterator<?>,List<KeyAssigner>>,? extends Entry<Iterator<?>,List<KeyAssigner>>>merge(java.lang.String,java.util.Map.Entry,java.util.function.BiFunction)BiFunction<? super String,? super Entry<Iterator<?>,List<KeyAssigner>>,? extends Entry<Iterator<?>,List<KeyAssigner>>>Function<? super String,? extends Entry<Iterator<?>,List<KeyAssigner>>>replace(java.lang.String,java.util.Map.Entry)replace(java.lang.String,java.util.Map.Entry,java.util.Map.Entry)putIfAbsent(java.lang.String,java.util.Map.Entry)BiConsumer<? super String,? super Entry<Iterator<?>,List<KeyAssigner>>>getOrDefault(java.lang.Object,java.util.Map.Entry)Entry<String,Entry<Iterator<?>,List<KeyAssigner>>>Set<Entry<String,Entry<Iterator<?>,List<KeyAssigner>>>>Collection<Entry<String,Entry<Iterator<?>,List<KeyAssigner>>>>Iterable<Entry<String,Entry<Iterator<?>,List<KeyAssigner>>>>Collection<Entry<Iterator<?>,List<KeyAssigner>>>Iterable<Entry<Iterator<?>,List<KeyAssigner>>>Map<? extends String,? extends Entry<Iterator<?>,List<KeyAssigner>>>put(java.lang.String,java.util.Map.Entry)AbstractMap<String,Entry<Iterator<?>,List<KeyAssigner>>>()HashMap<String,Entry<Iterator<?>,List<KeyAssigner>>>(java.util.Map)HashMap<String,Entry<Iterator<?>,List<KeyAssigner>>>(int)HashMap<String,Entry<Iterator<?>,List<KeyAssigner>>>(int,float)BiFunction<?,?,? extends Object>merge(java.lang.String,<nulltype>,java.util.function.BiFunction)BiFunction<? super String,?,? extends Object>replace(java.lang.String,<nulltype>)replace(java.lang.String,<nulltype>,<nulltype>)putIfAbsent(java.lang.String,<nulltype>)BiConsumer<? super String,?>getOrDefault(java.lang.Object,<nulltype>)Entry<String,?>Set<Entry<String,?>>Collection<Entry<String,?>>Iterable<Entry<String,?>>put(java.lang.String,<nulltype>)iteratorPairFunction<String,Entry<Iterator<?>,List<KeyAssigner>>>Function<? super Entry<Iterator<?>,List<KeyAssigner>>,? extends V>Function<V,Entry<Iterator<?>,List<KeyAssigner>>>kArrayList<E>AbstractList<E>AbstractCollection<E>ArrayList<E>()AbstractCollection<E>()AbstractList<E>()ArrayList<E>(java.util.Collection)ArrayList<E>(int)setValue(java.util.List)paircolumnPositionomitParamNamesingleParamfirstDotparamName"Could not determine which parameter to assign generated keys to. "
          + "Note that when there are multiple parameters, 'keyProperty' must include the parameter name (e.g. 'param.id'). "
          + "Specified key properties are "Could not determine which parameter to assign generated keys to. Note that when there are multiple parameters, 'keyProperty' must include the parameter name (e.g. 'param.id'). Specified key properties are " and available parameters are " and available parameters are argParamNameargKeyProperty"Could not find parameter '"Could not find parameter '"'. "
          + "Note that when there are multiple parameters, 'keyProperty' must include the parameter name (e.g. 'param.id'). "
          + "Specified key properties are "'. Note that when there are multiple parameters, 'keyProperty' must include the parameter name (e.g. 'param.id'). Specified key properties are singleParamName/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/keygen/Jdbc3KeyGenerator$KeyAssigner.classmetaParamBiFunction<?,?,?>BiFunction<? super String,?,?>Function<? super String,?>Map<? extends String,?>AbstractMap<String,?>()HashMap<String,?>(java.util.Map)HashMap<String,?>()HashMap<String,?>(int)HashMap<String,?>(int,float)ParamMapParamMap()ParamMap<?>()"No setter found for the keyProperty '"No setter found for the keyProperty '"' in '"' in 'getResultgetResult(java.sql.ResultSet,int)getResult(java.sql.CallableStatement,int)getResult(java.sql.ResultSet,java.lang.String)setParametersetParameter(java.sql.PreparedStatement,int,java.lang.Object,org.apache.ibatis.type.JdbcType)setParameter(java.sql.PreparedStatement,int,<nulltype>,org.apache.ibatis.type.JdbcType)A shared instance. do nothing Error? Multi-param or single param with @Param Multi-param or single param with @Param in batch operation Single param without @Param A caveat : if the only parameter has {@code @Param("param2")} on it, it must be referenced with param name e.g. 'param2.x'. Assume 'keyProperty' to be a property of the single param. There is virtually one parameter, so any key works. If paramName is set, param is ParamMap/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/keygen/KeyGenerator.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/keygen/NoKeyGenerator.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/keygen/SelectKeyGenerator.javasetValue(org.apache.ibatis.reflection.MetaObject,java.lang.String,java.lang.Object)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/keygen/SelectKeyGenerator.classhandleMultiplePropertieshandleMultipleProperties(java.lang.String[],org.apache.ibatis.reflection.MetaObject,org.apache.ibatis.reflection.MetaObject)processGeneratedKeysprocessGeneratedKeys(org.apache.ibatis.executor.Executor,org.apache.ibatis.mapping.MappedStatement,java.lang.Object)"!selectKey"!selectKeykeyExecutor"SelectKey returned no data."SelectKey returned no data."SelectKey returned more than one value."SelectKey returned more than one value.metaResult"Error selecting key or setting result to parameter object. Cause: "Error selecting key or setting result to parameter object. Cause: keyColumns"If SelectKey has key columns, the number must match the number of key properties."If SelectKey has key columns, the number must match the number of key properties."' in "' in  Do not close keyExecutor. The transaction will be closed by parent executor. no getter for the property - maybe just a single value object so try that no key columns specified, just use the property names/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/keygen/package-info.javaContains the key generators./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/loader/AbstractEnhancedDeserializationProxy.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/loaderorg.apache.ibatis.executor.loaderreloadingProperty/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/loader/AbstractEnhancedDeserializationProxy.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/loaderconstructorArgsList<Class<?>>constructorArgTypesMap<String,LoadPair>unloadedProperties"finalize""writeReplace"writeReplaceenhancedSpliterator<Class<?>>Iterator<Class<?>>Stream<Class<?>>BaseStream<Class<?>,Stream<Class<?>>>Predicate<? super Class<?>>Collection<? extends Class<?>>Iterable<? extends Class<?>>ListIterator<Class<?>>add(int,java.lang.Class)set(int,java.lang.Class)Comparator<? super Class<?>>UnaryOperator<Class<?>>Function<Class<?>,Class<?>>propertyKey? super LoadPair? extends LoadPairBiFunction<? super LoadPair,? super LoadPair,? extends LoadPair>merge(java.lang.String,org.apache.ibatis.executor.loader.ResultLoaderMap.LoadPair,java.util.function.BiFunction)BiFunction<? super String,? super LoadPair,? extends LoadPair>Function<? super String,? extends LoadPair>replace(java.lang.String,org.apache.ibatis.executor.loader.ResultLoaderMap.LoadPair)replace(java.lang.String,org.apache.ibatis.executor.loader.ResultLoaderMap.LoadPair,org.apache.ibatis.executor.loader.ResultLoaderMap.LoadPair)putIfAbsent(java.lang.String,org.apache.ibatis.executor.loader.ResultLoaderMap.LoadPair)BiConsumer<? super String,? super LoadPair>getOrDefault(java.lang.Object,org.apache.ibatis.executor.loader.ResultLoaderMap.LoadPair)Entry<String,LoadPair>Set<Entry<String,LoadPair>>Collection<Entry<String,LoadPair>>Iterable<Entry<String,LoadPair>>Collection<LoadPair>Iterable<LoadPair>Map<? extends String,? extends LoadPair>put(java.lang.String,org.apache.ibatis.executor.loader.ResultLoaderMap.LoadPair)loadPair"An attempt has been made to read a not loaded lazy property '"An attempt has been made to read a not loaded lazy property '"' of a disconnected object"' of a disconnected objectuserBeanI'm not sure if this case can really happen or is just in tests - we have an unread property but noloadPair to load it./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/loader/AbstractSerialStateHolder.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/loader/AbstractSerialStateHolder.classuserBeanBytesThreadLocal<ObjectOutputStream>8940388717901644661L8940388717901644661ThreadLocal<ObjectOutputStream>()set(java.io.ObjectOutputStream)HashMap<String,LoadPair>AbstractMap<String,LoadPair>HashMap<String,LoadPair>(java.util.Map)AbstractMap<String,LoadPair>()HashMap<String,LoadPair>()HashMap<String,LoadPair>(int)HashMap<String,LoadPair>(int,float)outfirstRoundbaososbytesdataarrayPropsarrayTypesarrayValuestargetSecond runFirst run/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/loader/CglibProxyFactory.javano-op/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/loader/JavassistProxyFactory.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/loader/ProxyFactory.javalazyLoader NOP/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/loader/ResultLoader.javanewExecutornewExecutor()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/loader/ResultLoader.classselectListselectList()localExecutordstransactionFactorytx"ResultLoader could not load lazily.  Environment was not configured."ResultLoader could not load lazily.  Environment was not configured."ResultLoader could not load lazily.  DataSource was not configured."ResultLoader could not load lazily.  DataSource was not configured./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/loader/ResultLoaderMap.javagetUppercaseFirstPropertygetUppercaseFirstProperty(java.lang.String)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/loader/ResultLoaderMap.classloaderMapmetaResultObjectresultLoaderupperFirst"Nested lazy loaded result property '"Nested lazy loaded result property '"' for query id '"' for query id '" already exists in the result map. The leftmost property of all lazy loaded properties must be unique within a result map." already exists in the result map. The leftmost property of all lazy loaded properties must be unique within a result map.methodNameSetmethodNamesparts"\\."\.getLoggergetLogger()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/loader/ResultLoaderMap$LoadPair.classgetConfigurationgetConfiguration()LoadPairLoadPair(java.lang.String,org.apache.ibatis.reflection.MetaObject,org.apache.ibatis.executor.loader.ResultLoader)mappedParameterserializationCheckFACTORY_METHOD20130412"getConfiguration"mappedStatementParameter"Property ["Property ["] of ["] of ["] cannot be loaded " + "after deserialization. Make sure it's loaded before serializing "
                + "forenamed object."] cannot be loaded after deserialization. Make sure it's loaded before serializing forenamed object."metaResultObject is null"metaResultObject is null"resultLoader is null"resultLoader is nulluserObject"] cannot be loaded because "
              + "required parameter of mapped statement ["] cannot be loaded because required parameter of mapped statement ["] is not serializable."] is not serializable."Cannot lazy load property ["Cannot lazy load property ["] of deserialized object ["] of deserialized object ["] because configuration does not contain statement ["] because configuration does not contain statement ["]"]oldconfigurationObject"Cannot get Configuration as configuration factory was not set."Cannot get Configuration as configuration factory was not set.factoryMethod"Cannot get Configuration as factory method ["Cannot get Configuration as factory method ["]#["]#["] is not static."] is not static.java.securityPrivilegedExceptionAction<>/DEFGHIJK/java.base/java/security/PrivilegedExceptionAction.sig/DEFGHIJK/java.base/java/securityPrivilegedExceptionAction<Object>runrun()"Cannot get Configuration as factory class ["Cannot get Configuration as factory class ["] is missing factory method of name ["] is missing factory method of name ["]."]."] threw an exception."] threw an exception.Object & .../BCDEFGHIJK/java.base/java/io/Serializable.sig/BCDEFGHIJK/java.base/java/iojava.io"] didn't return ["] didn't return ["] but ["] but ["null"null? super ConfigurationClass<? super Configuration>Constructor<Configuration>TypeVariable<Class<Configuration>>TypeVariable<Class<Configuration>>[]Class<? extends LoadPair>"Not supported."Not supported.Property which was not loaded yet.Name of factory method which returns database connection.Object to check whether we went through serialization..Meta object which sets loaded properties.Result loader which loads unread properties.Wow, logger.Factory class through which we get database connection.Name of the unread property.ID of SQL statement which loads the property.Parameter of the sql statement.Save required information only if original object can be serialized.@todo May the parameter be null?These field should not be null unless the loadpair was serialized. Yet in that case this method should not becalled.We are using a new executor because we may be (and likely are) on a new thread and executors aren't threadsafe. (Is this sufficient?) A better approach would be making executors thread safe./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/loader/WriteReplaceInterface.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/loader/cglib/CglibProxyFactory.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/loader/cgliborg.apache.ibatis.executor.loader.cglibcreateStaticProxycreateStaticProxy(java.lang.Class,net.sf.cglib.proxy.Callback,java.util.List,java.util.List)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/loader/cglib/CglibProxyFactory.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/loader/cglibWRITE_REPLACE_METHODFINALIZE_METHOD"net.sf.cglib.proxy.Enhancer"net.sf.cglib.proxy.Enhancer"Cannot enable lazy loading because CGLIB is not available. Add CGLIB to your classpath."Cannot enable lazy loading because CGLIB is not available. Add CGLIB to your classpath.callbackenhancer"CglibProxyFactory is deprecated. Use another proxy factory implementation."CglibProxyFactory is deprecated. Use another proxy factory implementation." method was found on bean " method was found on bean ", make sure it returns this", make sure it returns thisClass<WriteReplaceInterface>typesArrayvaluesArrayEnhancedResultObjectProxyImplEnhancedResultObjectProxyImpl(java.lang.Class,org.apache.ibatis.executor.loader.ResultLoaderMap,org.apache.ibatis.session.Configuration,org.apache.ibatis.reflection.factory.ObjectFactory,java.util.List,java.util.List)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/loader/cglib/CglibProxyFactory$EnhancedResultObjectProxyImpl.classaggressivemethodProxyEnhancedDeserializationProxyImplEnhancedDeserializationProxyImpl(java.lang.Class,java.util.Map,org.apache.ibatis.reflection.factory.ObjectFactory,java.util.List,java.util.List)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/loader/cglib/CglibProxyFactory$EnhancedDeserializationProxyImpl.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/loader/cglib/CglibProxyFactory$LogHolder.classLogHolderLogHolder()Class<CglibProxyFactory>Since 3.5.10, use Javassist instead. ObjectOutputStream will call writeReplace of objects returned by writeReplace nothing to do here/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/loader/cglib/CglibSerialStateHolder.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/loader/cglib/CglibSerialStateHolder.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/loader/cglib/package-info.javaCGLIB proxy factory./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/loader/javassist/JavassistProxyFactory.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/loader/javassistorg.apache.ibatis.executor.loader.javassistcreateStaticProxy(java.lang.Class,javassist.util.proxy.MethodHandler,java.util.List,java.util.List)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/loader/javassist/JavassistProxyFactory.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/loader/javassist"javassist.util.proxy.ProxyFactory"javassist.util.proxy.ProxyFactory"Cannot enable lazy loading because Javassist is not available. Add Javassist to your classpath."Cannot enable lazy loading because Javassist is not available. Add Javassist to your classpath."Error creating lazy proxy.  Cause: "Error creating lazy proxy.  Cause: /Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/loader/javassist/JavassistProxyFactory$EnhancedResultObjectProxyImpl.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/loader/javassist/JavassistProxyFactory$EnhancedDeserializationProxyImpl.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/loader/javassist/JavassistProxyFactory$LogHolder.classClass<JavassistProxyFactory>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/loader/javassist/JavassistSerialStateHolder.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/loader/javassist/JavassistSerialStateHolder.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/loader/javassist/package-info.javaJavassist proxy factory./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/loader/package-info.javaBase package for loading results into beans./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/package-info.javaContains the statement executors./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/parameter/ParameterHandler.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/parameterorg.apache.ibatis.executor.parameterpsA parameter handler sets the parameters of the {@code PreparedStatement}./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/parameter/package-info.javaBase package for handling parameters./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/result/DefaultMapResultHandler.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/resultorg.apache.ibatis.executor.result/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/result/DefaultMapResultHandler.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/resultmappedResultsResultHandler<V>ResultContext<? extends V>mo TODO is that assignment always true?/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/result/DefaultResultContext.javastopped/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/result/DefaultResultContext.classresultCountResultContext<T>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/result/DefaultResultHandler.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/result/DefaultResultHandler.classResultHandler<Object>Class<List<>>ResultContext<?>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/result/ResultMapException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/result/ResultMapException.class3270932060569707623L3270932060569707623Ryan Lamore/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/result/package-info.javaContains the result handlers./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/resultset/DefaultResultSetHandler.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/resultsetorg.apache.ibatis.executor.resultsethasTypeHandlerForResultObjecthasTypeHandlerForResultObject(org.apache.ibatis.executor.resultset.ResultSetWrapper,java.lang.Class)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/resultset/DefaultResultSetHandler.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/resultsetinstantiateCollectionPropertyIfAppropriateinstantiateCollectionPropertyIfAppropriate(org.apache.ibatis.mapping.ResultMapping,org.apache.ibatis.reflection.MetaObject)linkObjectslinkObjects(org.apache.ibatis.reflection.MetaObject,org.apache.ibatis.mapping.ResultMapping,java.lang.Object)createRowKeyForMapcreateRowKeyForMap(org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.cache.CacheKey)createRowKeyForUnmappedPropertiescreateRowKeyForUnmappedProperties(org.apache.ibatis.mapping.ResultMap,org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.cache.CacheKey,java.lang.String)createRowKeyForMappedPropertiescreateRowKeyForMappedProperties(org.apache.ibatis.mapping.ResultMap,org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.cache.CacheKey,java.util.List,java.lang.String)getResultMappingsForRowKeygetResultMappingsForRowKey(org.apache.ibatis.mapping.ResultMap)combineKeyscombineKeys(org.apache.ibatis.cache.CacheKey,org.apache.ibatis.cache.CacheKey)createRowKeycreateRowKey(org.apache.ibatis.mapping.ResultMap,org.apache.ibatis.executor.resultset.ResultSetWrapper,java.lang.String)getNestedResultMapgetNestedResultMap(java.sql.ResultSet,java.lang.String,java.lang.String)anyNotNullColumnHasValueanyNotNullColumnHasValue(org.apache.ibatis.mapping.ResultMapping,java.lang.String,org.apache.ibatis.executor.resultset.ResultSetWrapper)getColumnPrefixgetColumnPrefix(java.lang.String,org.apache.ibatis.mapping.ResultMapping)applyNestedResultMappingsapplyNestedResultMappings(org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.mapping.ResultMap,org.apache.ibatis.reflection.MetaObject,java.lang.String,org.apache.ibatis.cache.CacheKey,boolean)handleRowValuesForNestedResultMaphandleRowValuesForNestedResultMap(org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.mapping.ResultMap,org.apache.ibatis.session.ResultHandler,org.apache.ibatis.session.RowBounds,org.apache.ibatis.mapping.ResultMapping)prependPrefixprependPrefix(java.lang.String,java.lang.String)getDiscriminatorValuegetDiscriminatorValue(java.sql.ResultSet,org.apache.ibatis.mapping.Discriminator,java.lang.String)instantiateParameterObjectinstantiateParameterObject(java.lang.Class)prepareCompositeKeyParameterprepareCompositeKeyParameter(java.sql.ResultSet,org.apache.ibatis.mapping.ResultMapping,java.lang.Class,java.lang.String)prepareSimpleKeyParameterprepareSimpleKeyParameter(java.sql.ResultSet,org.apache.ibatis.mapping.ResultMapping,java.lang.Class,java.lang.String)prepareParameterForNestedQueryprepareParameterForNestedQuery(java.sql.ResultSet,org.apache.ibatis.mapping.ResultMapping,java.lang.Class,java.lang.String)getNestedQueryMappingValuegetNestedQueryMappingValue(java.sql.ResultSet,org.apache.ibatis.reflection.MetaObject,org.apache.ibatis.mapping.ResultMapping,org.apache.ibatis.executor.loader.ResultLoaderMap,java.lang.String)getNestedQueryConstructorValuegetNestedQueryConstructorValue(java.sql.ResultSet,org.apache.ibatis.mapping.ResultMapping,java.lang.String)createPrimitiveResultObjectcreatePrimitiveResultObject(org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.mapping.ResultMap,java.lang.String)columnMatchesParamcolumnMatchesParam(java.lang.String,java.lang.String,java.lang.String)applyArgNameBasedConstructorAutoMappingapplyArgNameBasedConstructorAutoMapping(org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.mapping.ResultMap,java.lang.String,java.util.List,java.util.List,java.lang.reflect.Constructor,boolean)applyColumnOrderBasedConstructorAutomappingapplyColumnOrderBasedConstructorAutomapping(org.apache.ibatis.executor.resultset.ResultSetWrapper,java.util.List,java.util.List,java.lang.reflect.Constructor,boolean)applyConstructorAutomappingapplyConstructorAutomapping(org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.mapping.ResultMap,java.lang.String,java.lang.Class,java.util.List,java.util.List,java.lang.reflect.Constructor)List<JdbcType>Collection<JdbcType>Iterable<JdbcType>findUsableConstructorByArgTypesfindUsableConstructorByArgTypes(java.lang.reflect.Constructor,java.util.List)Optional<Constructor<?>>findConstructorForAutomappingfindConstructorForAutomapping(java.lang.Class,org.apache.ibatis.executor.resultset.ResultSetWrapper)createByConstructorSignaturecreateByConstructorSignature(org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.mapping.ResultMap,java.lang.String,java.lang.Class,java.util.List,java.util.List)createParameterizedResultObjectcreateParameterizedResultObject(org.apache.ibatis.executor.resultset.ResultSetWrapper,java.lang.Class,java.util.List,java.util.List,java.util.List,java.lang.String)createResultObjectcreateResultObject(org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.mapping.ResultMap,java.util.List,java.util.List,java.lang.String)createResultObject(org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.mapping.ResultMap,org.apache.ibatis.executor.loader.ResultLoaderMap,java.lang.String)createKeyForMultipleResultscreateKeyForMultipleResults(java.sql.ResultSet,org.apache.ibatis.mapping.ResultMapping,java.lang.String,java.lang.String)addPendingChildRelationaddPendingChildRelation(java.sql.ResultSet,org.apache.ibatis.reflection.MetaObject,org.apache.ibatis.mapping.ResultMapping)linkToParentslinkToParents(java.sql.ResultSet,org.apache.ibatis.mapping.ResultMapping,java.lang.Object)applyAutomaticMappingsapplyAutomaticMappings(org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.mapping.ResultMap,org.apache.ibatis.reflection.MetaObject,java.lang.String)List<UnMappedColumnAutoMapping>Collection<UnMappedColumnAutoMapping>Iterable<UnMappedColumnAutoMapping>createAutomaticMappingscreateAutomaticMappings(org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.mapping.ResultMap,org.apache.ibatis.reflection.MetaObject,java.lang.String)getPropertyMappingValuegetPropertyMappingValue(java.sql.ResultSet,org.apache.ibatis.reflection.MetaObject,org.apache.ibatis.mapping.ResultMapping,org.apache.ibatis.executor.loader.ResultLoaderMap,java.lang.String)applyPropertyMappingsapplyPropertyMappings(org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.mapping.ResultMap,org.apache.ibatis.reflection.MetaObject,org.apache.ibatis.executor.loader.ResultLoaderMap,java.lang.String)shouldApplyAutomaticMappingsshouldApplyAutomaticMappings(org.apache.ibatis.mapping.ResultMap,boolean)putAncestorputAncestor(java.lang.Object,java.lang.String)getRowValuegetRowValue(org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.mapping.ResultMap,org.apache.ibatis.cache.CacheKey,java.lang.String,java.lang.Object)getRowValue(org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.mapping.ResultMap,java.lang.String)skipRowsskipRows(java.sql.ResultSet,org.apache.ibatis.session.RowBounds)shouldProcessMoreRowsshouldProcessMoreRows(org.apache.ibatis.session.ResultContext,org.apache.ibatis.session.RowBounds)DefaultResultContext<Object>ResultContext<Object>callResultHandlercallResultHandler(org.apache.ibatis.session.ResultHandler,org.apache.ibatis.executor.result.DefaultResultContext,java.lang.Object)storeObjectstoreObject(org.apache.ibatis.session.ResultHandler,org.apache.ibatis.executor.result.DefaultResultContext,java.lang.Object,org.apache.ibatis.mapping.ResultMapping,java.sql.ResultSet)handleRowValuesForSimpleResultMaphandleRowValuesForSimpleResultMap(org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.mapping.ResultMap,org.apache.ibatis.session.ResultHandler,org.apache.ibatis.session.RowBounds,org.apache.ibatis.mapping.ResultMapping)ensureNoRowBoundsensureNoRowBounds()collapseSingleResultListcollapseSingleResultList(java.util.List)handleResultSethandleResultSet(org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.mapping.ResultMap,java.util.List,org.apache.ibatis.mapping.ResultMapping)validateResultMapsCountvalidateResultMapsCount(org.apache.ibatis.executor.resultset.ResultSetWrapper,int)cleanUpAfterHandlingResultSetcleanUpAfterHandlingResultSet()closeResultSetcloseResultSet(java.sql.ResultSet)getNextResultSetgetNextResultSet(java.sql.Statement)getFirstResultSetgetFirstResultSet(java.sql.Statement)handleRefCursorOutputParameterhandleRefCursorOutputParameter(java.sql.ResultSet,org.apache.ibatis.mapping.ParameterMapping,org.apache.ibatis.reflection.MetaObject)useConstructorMappingsMap<String,List<String>>constructorAutoMappingColumnsMap<String,List<UnMappedColumnAutoMapping>>autoMappingsCacheList<PendingRelation>Collection<PendingRelation>Iterable<PendingRelation>Map<CacheKey,List<PendingRelation>>pendingRelationsMap<String,ResultMapping>nextResultMapspreviousRowValueancestorObjectsMap<CacheKey,Object>nestedResultObjectsparameterHandlerDEFERREDHashMap<CacheKey,Object>AbstractMap<CacheKey,Object>HashMap<CacheKey,Object>()merge(org.apache.ibatis.cache.CacheKey,java.lang.Object,java.util.function.BiFunction)? super CacheKeyBiFunction<? super CacheKey,? super Object,? extends Object>compute(org.apache.ibatis.cache.CacheKey,java.util.function.BiFunction)computeIfPresent(org.apache.ibatis.cache.CacheKey,java.util.function.BiFunction)Function<? super CacheKey,? extends Object>computeIfAbsent(org.apache.ibatis.cache.CacheKey,java.util.function.Function)replace(org.apache.ibatis.cache.CacheKey,java.lang.Object)replace(org.apache.ibatis.cache.CacheKey,java.lang.Object,java.lang.Object)putIfAbsent(org.apache.ibatis.cache.CacheKey,java.lang.Object)BiConsumer<? super CacheKey,? super Object>Entry<CacheKey,Object>Set<Entry<CacheKey,Object>>Collection<Entry<CacheKey,Object>>Iterable<Entry<CacheKey,Object>>Set<CacheKey>Collection<CacheKey>Iterable<CacheKey>? extends CacheKeyMap<? extends CacheKey,? extends Object>put(org.apache.ibatis.cache.CacheKey,java.lang.Object)AbstractMap<CacheKey,Object>()HashMap<CacheKey,Object>(java.util.Map)HashMap<CacheKey,Object>(int)HashMap<CacheKey,Object>(int,float)HashMap<String,Object>AbstractMap<String,Object>HashMap<String,Object>()AbstractMap<String,Object>()HashMap<String,Object>(java.util.Map)HashMap<String,Object>(int)HashMap<String,Object>(int,float)HashMap<String,ResultMapping>AbstractMap<String,ResultMapping>HashMap<String,ResultMapping>()BiFunction<? super ResultMapping,? super ResultMapping,? extends ResultMapping>merge(java.lang.String,org.apache.ibatis.mapping.ResultMapping,java.util.function.BiFunction)BiFunction<? super String,? super ResultMapping,? extends ResultMapping>Function<? super String,? extends ResultMapping>replace(java.lang.String,org.apache.ibatis.mapping.ResultMapping)replace(java.lang.String,org.apache.ibatis.mapping.ResultMapping,org.apache.ibatis.mapping.ResultMapping)putIfAbsent(java.lang.String,org.apache.ibatis.mapping.ResultMapping)BiConsumer<? super String,? super ResultMapping>getOrDefault(java.lang.Object,org.apache.ibatis.mapping.ResultMapping)Entry<String,ResultMapping>Set<Entry<String,ResultMapping>>Collection<Entry<String,ResultMapping>>Iterable<Entry<String,ResultMapping>>Map<? extends String,? extends ResultMapping>put(java.lang.String,org.apache.ibatis.mapping.ResultMapping)AbstractMap<String,ResultMapping>()HashMap<String,ResultMapping>(java.util.Map)HashMap<String,ResultMapping>(int)HashMap<String,ResultMapping>(int,float)HashMap<CacheKey,List<PendingRelation>>AbstractMap<CacheKey,List<PendingRelation>>HashMap<CacheKey,List<PendingRelation>>()? super List<PendingRelation>? extends List<PendingRelation>BiFunction<? super List<PendingRelation>,? super List<PendingRelation>,? extends List<PendingRelation>>merge(org.apache.ibatis.cache.CacheKey,java.util.List,java.util.function.BiFunction)BiFunction<? super CacheKey,? super List<PendingRelation>,? extends List<PendingRelation>>Function<? super CacheKey,? extends List<PendingRelation>>replace(org.apache.ibatis.cache.CacheKey,java.util.List)replace(org.apache.ibatis.cache.CacheKey,java.util.List,java.util.List)putIfAbsent(org.apache.ibatis.cache.CacheKey,java.util.List)BiConsumer<? super CacheKey,? super List<PendingRelation>>getOrDefault(java.lang.Object,java.util.List)Entry<CacheKey,List<PendingRelation>>Set<Entry<CacheKey,List<PendingRelation>>>Collection<Entry<CacheKey,List<PendingRelation>>>Iterable<Entry<CacheKey,List<PendingRelation>>>Collection<List<PendingRelation>>Iterable<List<PendingRelation>>Map<? extends CacheKey,? extends List<PendingRelation>>put(org.apache.ibatis.cache.CacheKey,java.util.List)AbstractMap<CacheKey,List<PendingRelation>>()HashMap<CacheKey,List<PendingRelation>>(java.util.Map)HashMap<CacheKey,List<PendingRelation>>(int)HashMap<CacheKey,List<PendingRelation>>(int,float)HashMap<String,List<UnMappedColumnAutoMapping>>AbstractMap<String,List<UnMappedColumnAutoMapping>>HashMap<String,List<UnMappedColumnAutoMapping>>()? super List<UnMappedColumnAutoMapping>? extends List<UnMappedColumnAutoMapping>BiFunction<? super List<UnMappedColumnAutoMapping>,? super List<UnMappedColumnAutoMapping>,? extends List<UnMappedColumnAutoMapping>>merge(java.lang.String,java.util.List,java.util.function.BiFunction)BiFunction<? super String,? super List<UnMappedColumnAutoMapping>,? extends List<UnMappedColumnAutoMapping>>Function<? super String,? extends List<UnMappedColumnAutoMapping>>replace(java.lang.String,java.util.List)replace(java.lang.String,java.util.List,java.util.List)putIfAbsent(java.lang.String,java.util.List)BiConsumer<? super String,? super List<UnMappedColumnAutoMapping>>Entry<String,List<UnMappedColumnAutoMapping>>Set<Entry<String,List<UnMappedColumnAutoMapping>>>Collection<Entry<String,List<UnMappedColumnAutoMapping>>>Iterable<Entry<String,List<UnMappedColumnAutoMapping>>>Collection<List<UnMappedColumnAutoMapping>>Iterable<List<UnMappedColumnAutoMapping>>Map<? extends String,? extends List<UnMappedColumnAutoMapping>>put(java.lang.String,java.util.List)AbstractMap<String,List<UnMappedColumnAutoMapping>>()HashMap<String,List<UnMappedColumnAutoMapping>>(java.util.Map)HashMap<String,List<UnMappedColumnAutoMapping>>(int)HashMap<String,List<UnMappedColumnAutoMapping>>(int,float)HashMap<String,List<String>>AbstractMap<String,List<String>>HashMap<String,List<String>>()? super List<String>? extends List<String>BiFunction<? super List<String>,? super List<String>,? extends List<String>>BiFunction<? super String,? super List<String>,? extends List<String>>Function<? super String,? extends List<String>>BiConsumer<? super String,? super List<String>>Entry<String,List<String>>Set<Entry<String,List<String>>>Collection<Entry<String,List<String>>>Iterable<Entry<String,List<String>>>Collection<List<String>>Iterable<List<String>>Map<? extends String,? extends List<String>>AbstractMap<String,List<String>>()HashMap<String,List<String>>(java.util.Map)HashMap<String,List<String>>(int)HashMap<String,List<String>>(int,float)PendingRelationPendingRelation()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/resultset/DefaultResultSetHandler$PendingRelation.classprimitive/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/resultset/DefaultResultSetHandler$UnMappedColumnAutoMapping.classcsmultipleResultsresultSetCountresultMapCount"handling results"handling resultsparentMapping"handling cursor results"handling cursor results"Cursor results cannot be mapped to multiple resultMaps"Cursor results cannot be mapped to multiple resultMapsDefaultCursor<E>DefaultCursor<E>(org.apache.ibatis.executor.resultset.DefaultResultSetHandler,org.apache.ibatis.mapping.ResultMap,org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.session.RowBounds)getCurrentIndexgetCurrentIndex()isConsumedisConsumed()isOpenisOpen()fetchNextObjectFromDatabasefetchNextObjectFromDatabase()fetchNextUsingRowBoundfetchNextUsingRowBound()DefaultCursorDefaultCursor(org.apache.ibatis.executor.resultset.DefaultResultSetHandler,org.apache.ibatis.mapping.ResultMap,org.apache.ibatis.executor.resultset.ResultSetWrapper,org.apache.ibatis.session.RowBounds)objectWrapperResultHandler"A query was run and no Result Maps were found for the Mapped Statement '"A query was run and no Result Maps were found for the Mapped Statement '"'. 'resultType' or 'resultMap' must be specified when there is no corresponding method."'. 'resultType' or 'resultMap' must be specified when there is no corresponding method.defaultResultHandler"Mapped Statements with nested result mappings cannot be safely constrained by RowBounds. "
              + "Use safeRowBoundsEnabled=false setting to bypass this check."Mapped Statements with nested result mappings cannot be safely constrained by RowBounds. Use safeRowBoundsEnabled=false setting to bypass this check."Mapped Statements with nested result mappings cannot be safely used with a custom ResultHandler. "
              + "Use safeResultHandlerEnabled=false setting to bypass this check "
              + "or ensure your statement returns ordered data and set resultOrdered=true on it."Mapped Statements with nested result mappings cannot be safely used with a custom ResultHandler. Use safeResultHandlerEnabled=false setting to bypass this check or ensure your statement returns ordered data and set resultOrdered=true on it.resultContextDefaultResultContext<Object>()nextResultObjectnextResultObject(java.lang.Object)DefaultResultContextDefaultResultContext()discriminatedResultMaprowValueResultContext<? extends Object>foundValuescombinedKeypartialObjectisNestedmappedColumnNamespropertyMappingspropertyMappingunmappedColumnNamesmappedInConstructorAutoMappingArrayList<UnMappedColumnAutoMapping>AbstractList<UnMappedColumnAutoMapping>AbstractCollection<UnMappedColumnAutoMapping>ArrayList<UnMappedColumnAutoMapping>()Spliterator<UnMappedColumnAutoMapping>? super UnMappedColumnAutoMappingConsumer<? super UnMappedColumnAutoMapping>Iterator<UnMappedColumnAutoMapping>Stream<UnMappedColumnAutoMapping>BaseStream<UnMappedColumnAutoMapping,Stream<UnMappedColumnAutoMapping>>Predicate<? super UnMappedColumnAutoMapping>? extends UnMappedColumnAutoMappingCollection<? extends UnMappedColumnAutoMapping>Iterable<? extends UnMappedColumnAutoMapping>add(org.apache.ibatis.executor.resultset.DefaultResultSetHandler.UnMappedColumnAutoMapping)AbstractCollection<UnMappedColumnAutoMapping>()ListIterator<UnMappedColumnAutoMapping>add(int,org.apache.ibatis.executor.resultset.DefaultResultSetHandler.UnMappedColumnAutoMapping)set(int,org.apache.ibatis.executor.resultset.DefaultResultSetHandler.UnMappedColumnAutoMapping)Comparator<? super UnMappedColumnAutoMapping>UnaryOperator<UnMappedColumnAutoMapping>Function<UnMappedColumnAutoMapping,UnMappedColumnAutoMapping>AbstractList<UnMappedColumnAutoMapping>()ArrayList<UnMappedColumnAutoMapping>(java.util.Collection)ArrayList<UnMappedColumnAutoMapping>(int)mappingparentKeyparentsdeferLoadrelationsFunction<CacheKey,List<PendingRelation>>Function<CacheKey,V>Function<? super List<PendingRelation>,? extends V>Function<V,List<PendingRelation>>Function<? super V,? extends CacheKey>apply(org.apache.ibatis.cache.CacheKey)ArrayList<PendingRelation>AbstractList<PendingRelation>AbstractCollection<PendingRelation>add(org.apache.ibatis.executor.resultset.DefaultResultSetHandler.PendingRelation)Spliterator<PendingRelation>? super PendingRelationConsumer<? super PendingRelation>Iterator<PendingRelation>Stream<PendingRelation>BaseStream<PendingRelation,Stream<PendingRelation>>Predicate<? super PendingRelation>? extends PendingRelationCollection<? extends PendingRelation>Iterable<? extends PendingRelation>ListIterator<PendingRelation>add(int,org.apache.ibatis.executor.resultset.DefaultResultSetHandler.PendingRelation)set(int,org.apache.ibatis.executor.resultset.DefaultResultSetHandler.PendingRelation)Comparator<? super PendingRelation>UnaryOperator<PendingRelation>Function<PendingRelation,PendingRelation>"Two different properties are mapped to the same resultSet"Two different properties are mapped to the same resultSetnamescolumnsArraynamesArrayArrayList<Class<?>>AbstractList<Class<?>>AbstractCollection<Class<?>>ArrayList<Class<?>>()AbstractCollection<Class<?>>()AbstractList<Class<?>>()ArrayList<Class<?>>(java.util.Collection)ArrayList<Class<?>>(int)metaTypeconstructorMappings"Do not know how to create an instance of "Do not know how to create an instance of constructorMappingconstructorColumnPrefix"Could not process result for mapping: "Could not process result for mapping: Stream<Constructor<?>>BaseStream<Constructor<?>,Stream<Constructor<?>>>? extends Constructor<?>Optional<? extends Constructor<?>>? extends Optional<? extends Constructor<?>>Supplier<? extends Optional<? extends Constructor<?>>>? super Constructor<?>Function<? super Constructor<?>,? extends Optional<? extends U>>Consumer<? super Constructor<?>>Supplier<? extends Constructor<?>>orElse(java.lang.reflect.Constructor)Function<? super Constructor<?>,? extends U>Predicate<? super Constructor<?>>Supplier<ExecutorException>"No constructor found in "No constructor found in " matching " matching constructorsannotatedBinaryOperator<Constructor<?>>BiFunction<Constructor<?>,Constructor<?>,Constructor<?>>Spliterator<Constructor<?>>Iterator<Constructor<?>>List<Constructor<?>>Collection<Constructor<?>>Iterable<Constructor<?>>BiConsumer<? super Constructor<?>,? super DoubleConsumer>BiConsumer<? super Constructor<?>,? super LongConsumer>BiConsumer<? super Constructor<?>,? super IntConsumer>BiConsumer<? super Constructor<?>,? super Consumer<R>>Comparator<? super Constructor<?>>Collector<? super Constructor<?>,A,R>BiConsumer<R,? super Constructor<?>>BiFunction<U,? super Constructor<?>,U>reduce(java.lang.reflect.Constructor,java.util.function.BinaryOperator)Function<? super Constructor<?>,? extends DoubleStream>Function<? super Constructor<?>,? extends LongStream>Function<? super Constructor<?>,? extends IntStream>Function<? super Constructor<?>,? extends Stream<? extends R>>ToDoubleFunction<? super Constructor<?>>ToLongFunction<? super Constructor<?>>ToIntFunction<? super Constructor<?>>Function<? super Constructor<?>,? extends R>Predicate<Constructor<?>>test(java.lang.reflect.Constructor)Class<AutomapConstructor>BiFunction<Constructor<?>,Constructor<?>,V>Function<? super Constructor<?>,? extends V>apply(java.lang.reflect.Constructor,java.lang.reflect.Constructor)y"@AutomapConstructor should be used in only one constructor."@AutomapConstructor should be used in only one constructor."'argNameBasedConstructorAutoMapping' is enabled and the class ''{0}'' has multiple constructors, so @AutomapConstructor must be added to one of the constructors."'argNameBasedConstructorAutoMapping' is enabled and the class ''{0}'' has multiple constructors, so @AutomapConstructor must be added to one of the constructors.jdbcTypesSpliterator<JdbcType>? super JdbcTypeConsumer<? super JdbcType>Iterator<JdbcType>Stream<JdbcType>BaseStream<JdbcType,Stream<JdbcType>>Predicate<? super JdbcType>? extends JdbcTypeCollection<? extends JdbcType>Iterable<? extends JdbcType>add(org.apache.ibatis.type.JdbcType)ListIterator<JdbcType>add(int,org.apache.ibatis.type.JdbcType)set(int,org.apache.ibatis.type.JdbcType)Comparator<? super JdbcType>UnaryOperator<JdbcType>Function<JdbcType,JdbcType>missingArgsParameter[]columnNotFoundparamAnnoClass<Param>Function<String,List<String>>Function<? super List<String>,? extends V>Function<V,List<String>>ArrayList<String>AbstractList<String>ArrayList<String>()AbstractList<String>()ArrayList<String>(java.util.Collection)ArrayList<String>(int)"Constructor auto-mapping of ''{1}'' failed " + "because ''{0}'' were not found in the result set; "
              + "Available columns are ''{2}'' and mapUnderscoreToCamelCase is ''{3}''."Constructor auto-mapping of ''{1}'' failed because ''{0}'' were not found in the result set; Available columns are ''{2}'' and mapUnderscoreToCamelCase is ''{3}''."_"_resultMappingListnestedQueryIdnestedQuerynestedQueryParameterTypenestedQueryParameterObjectnestedBoundSqlinnerResultMappingpropTypepropValuepastDiscriminatorsdiscriminatedMapIdlastDiscriminatorprefixrowKeyparentPrefixparentRowKeynewObjectknownValueancestorObject"Error getting nested result map values for '"Error getting nested result map values for 'columnPrefixBuildernotNullColumns"Error cloning cache key.  Cause: "Error cloning cache key.  Cause: thcolumnNamescollectionPropertytargetMetaObjectpropertyValue"Error instantiating collection property for result '"Error instantiating collection property for result 'Iwao AVE! nested resultmaps multiple resultsets Cached Automappings temporary marking flag that indicate using constructor mapping (use field to reduce memory usage) HANDLE OUTPUT PARAMETER issue #228 (close resultsets) HANDLE RESULT SETS move forward to get the first resultset in case the driver doesn't return the resultset as the first result (HSQLDB) no more results. Must be no resultset Making this method tolerant of bad JDBC drivers Crazy Standard JDBC way of determining if there are more results DO NOT try to 'improve' the condition even if IDE tells you to! It's important that getUpdateCount() is called here. Intentionally ignored. HANDLE ROWS FOR SIMPLE RESULTMAPbecause ResultHandler<?> is always ResultHandler<Object> GET VALUE FROM ROW FOR SIMPLE RESULT MAP GET VALUE FROM ROW FOR NESTED RESULT MAP PROPERTY MAPPINGS the user added a column attribute to a nested result map, ignore it issue #541 make property optional gcode issue #377, call setter on nulls (value is not 'found') TODO is that OK? Remove the entry to release the memory When columnPrefix is specified, ignore columns without the prefix. MULTIPLE RESULT SETS issue #255 INSTANTIATION & CONSTRUCTOR MAPPING reset previous mapping result issue gcode #109 && issue #149 set current mapping result Finding-best-match type implementation is possible, but using @AutomapConstructor seems sufficient. NESTED QUERY issue #353 & #560 do not execute nested query if key is null issue #649 DISCRIMINATOR HANDLE NESTED RESULT MAPS issue #577 && #542 NESTED RESULT MAP (JOIN MAPPING) try to fill circular reference only when columnPrefix is not specified for the nested result map (issue #215) issue #385 mandatory UNIQUE RESULT KEY Issue #114 When columnPrefix is specified, ignore columns without the prefix./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/resultset/ResultSetHandler.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/resultset/ResultSetWrapper.javaprependPrefixesprependPrefixes(java.util.Set,java.lang.String)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/resultset/ResultSetWrapper.classgetMapKey(org.apache.ibatis.mapping.ResultMap,java.lang.String)loadMappedAndUnmappedColumnNamesloadMappedAndUnmappedColumnNames(org.apache.ibatis.mapping.ResultMap,java.lang.String)resolveClassresolveClass(java.lang.String)unMappedColumnNamesMapMap<String,Set<String>>mappedColumnNamesMapMap<Class<?>,TypeHandler<?>>Map<String,Map<Class<?>,TypeHandler<?>>>typeHandlerMapclassNamesArrayList<JdbcType>AbstractList<JdbcType>AbstractCollection<JdbcType>ArrayList<JdbcType>()AbstractCollection<JdbcType>()AbstractList<JdbcType>()ArrayList<JdbcType>(java.util.Collection)ArrayList<JdbcType>(int)HashMap<String,Map<Class<?>,TypeHandler<?>>>AbstractMap<String,Map<Class<?>,TypeHandler<?>>>HashMap<String,Map<Class<?>,TypeHandler<?>>>()? super Map<Class<?>,TypeHandler<?>>? extends Map<Class<?>,TypeHandler<?>>BiFunction<? super Map<Class<?>,TypeHandler<?>>,? super Map<Class<?>,TypeHandler<?>>,? extends Map<Class<?>,TypeHandler<?>>>merge(java.lang.String,java.util.Map,java.util.function.BiFunction)BiFunction<? super String,? super Map<Class<?>,TypeHandler<?>>,? extends Map<Class<?>,TypeHandler<?>>>Function<? super String,? extends Map<Class<?>,TypeHandler<?>>>replace(java.lang.String,java.util.Map)replace(java.lang.String,java.util.Map,java.util.Map)putIfAbsent(java.lang.String,java.util.Map)BiConsumer<? super String,? super Map<Class<?>,TypeHandler<?>>>getOrDefault(java.lang.Object,java.util.Map)Entry<String,Map<Class<?>,TypeHandler<?>>>Set<Entry<String,Map<Class<?>,TypeHandler<?>>>>Collection<Entry<String,Map<Class<?>,TypeHandler<?>>>>Iterable<Entry<String,Map<Class<?>,TypeHandler<?>>>>Collection<Map<Class<?>,TypeHandler<?>>>Iterable<Map<Class<?>,TypeHandler<?>>>Map<? extends String,? extends Map<Class<?>,TypeHandler<?>>>put(java.lang.String,java.util.Map)AbstractMap<String,Map<Class<?>,TypeHandler<?>>>()HashMap<String,Map<Class<?>,TypeHandler<?>>>(java.util.Map)HashMap<String,Map<Class<?>,TypeHandler<?>>>(int)HashMap<String,Map<Class<?>,TypeHandler<?>>>(int,float)HashMap<String,Set<String>>AbstractMap<String,Set<String>>HashMap<String,Set<String>>()? super Set<String>? extends Set<String>BiFunction<? super Set<String>,? super Set<String>,? extends Set<String>>merge(java.lang.String,java.util.Set,java.util.function.BiFunction)BiFunction<? super String,? super Set<String>,? extends Set<String>>Function<? super String,? extends Set<String>>replace(java.lang.String,java.util.Set)replace(java.lang.String,java.util.Set,java.util.Set)putIfAbsent(java.lang.String,java.util.Set)BiConsumer<? super String,? super Set<String>>getOrDefault(java.lang.Object,java.util.Set)Entry<String,Set<String>>Set<Entry<String,Set<String>>>Collection<Entry<String,Set<String>>>Iterable<Entry<String,Set<String>>>Collection<Set<String>>Iterable<Set<String>>Map<? extends String,? extends Set<String>>put(java.lang.String,java.util.Set)AbstractMap<String,Set<String>>()HashMap<String,Set<String>>(java.util.Map)HashMap<String,Set<String>>(int)HashMap<String,Set<String>>(int,float)metaDatacolumnCountcolumnHandlersHashMap<Class<?>,TypeHandler<?>>AbstractMap<Class<?>,TypeHandler<?>>HashMap<Class<?>,TypeHandler<?>>()? super TypeHandler<?>BiFunction<? super TypeHandler<?>,? super TypeHandler<?>,? extends TypeHandler<?>>merge(java.lang.Class,org.apache.ibatis.type.TypeHandler,java.util.function.BiFunction)BiFunction<? super Class<?>,? super TypeHandler<?>,? extends TypeHandler<?>>Function<? super Class<?>,? extends TypeHandler<?>>replace(java.lang.Class,org.apache.ibatis.type.TypeHandler)replace(java.lang.Class,org.apache.ibatis.type.TypeHandler,org.apache.ibatis.type.TypeHandler)putIfAbsent(java.lang.Class,org.apache.ibatis.type.TypeHandler)BiConsumer<? super Class<?>,? super TypeHandler<?>>getOrDefault(java.lang.Object,org.apache.ibatis.type.TypeHandler)Entry<Class<?>,TypeHandler<?>>Set<Entry<Class<?>,TypeHandler<?>>>Collection<Entry<Class<?>,TypeHandler<?>>>Iterable<Entry<Class<?>,TypeHandler<?>>>Collection<TypeHandler<?>>Iterable<TypeHandler<?>>Map<? extends Class<?>,? extends TypeHandler<?>>put(java.lang.Class,org.apache.ibatis.type.TypeHandler)AbstractMap<Class<?>,TypeHandler<?>>()HashMap<Class<?>,TypeHandler<?>>(java.util.Map)HashMap<Class<?>,TypeHandler<?>>(int)HashMap<Class<?>,TypeHandler<?>>(int,float)classNameupperColumnPrefixmappedColumnsupperColumnNameunMappedColumnNamesprefixedGets the type handler to use when reading the result set. Tries to get from the TypeHandlerRegistry by searchingfor the property type. If not found it gets the column JDBC type and tries to get a handler for it.the property typethe column name Replicate logic of UnknownTypeHandler#resolveTypeHandler See issue #59 comment 10 #699 className could be null/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/resultset/package-info.javaContains the result processing logic./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/statement/BaseStatementHandler.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/statementorg.apache.ibatis.executor.statementtransactionTimeout"Error preparing statement.  Cause: "Error preparing statement.  Cause: queryTimeout issue #435, get the key before calculating the statement/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/statement/CallableStatementHandler.javaregisterOutputParametersregisterOutputParameters(java.sql.CallableStatement)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/statement/CallableStatementHandler.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/statementrowsresultList"The JDBC Type must be specified for output parameter.  Parameter: "The JDBC Type must be specified for output parameter.  Parameter: /Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/statement/PreparedStatementHandler.javakeyColumnNames/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/statement/RoutingStatementHandler.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/statement/RoutingStatementHandler.class"Unknown statement type: "Unknown statement type: /Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/statement/SimpleStatementHandler.java N/A/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/statement/StatementHandler.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/statement/StatementUtil.javaStatementUtilStatementUtil()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/executor/statement/StatementUtil.classUtility for {@link java.sql.Statement}.Update a query timeout to apply a transaction timeout.a target statementa query timeouta transaction timeout/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/executor/statement/package-info.javaStatement handlers./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/io/ClassLoaderWrapper.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/ioClassLoader[]getClassLoadersgetClassLoaders(java.lang.ClassLoader)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/io/ClassLoaderWrapper.classclassForNameclassForName(java.lang.String,java.lang.ClassLoader[])getResourceAsURLgetResourceAsURL(java.lang.String,java.lang.ClassLoader[])getResourceAsStream(java.lang.String,java.lang.ClassLoader[])ClassLoaderWrapperClassLoaderWrapper()systemClassLoaderdefaultClassLoaderignoredclassLoadercl"Cannot find class: "Cannot find class: ? extends ClassLoaderWrapperClass<? extends ClassLoaderWrapper>Constructor<? extends ClassLoaderWrapper>ClassLoaderWrapper[]TypeVariable<Class<? extends ClassLoaderWrapper>>TypeVariable<Class<? extends ClassLoaderWrapper>>[]A class to wrap access to multiple class loaders making them work as one AccessControlException on Google App EngineGet a resource as a URL using the current class path- the resource to locatethe resource or nullGet a resource from the classpath, starting with a specific class loader- the resource to find- the first classloader to trythe stream or nullGet a resource from the classpath- the first class loader to tryFind a class on the classpath (or die trying)- the class to look for- the classClassNotFoundExceptionDuh.Find a class on the classpath, starting with a specific classloader (or die trying)Try to get a resource from a group of classloaders- the resource to get- the classloaders to examine try to find the resource as passed now, some class loaders want this leading "/", so we'll add it and try again if we didn't find the resource- the class loaders to examine look for the resource as passed in... ...but some class loaders want this leading "/", so we'll add it and try again if we didn't find the resource "It's always in the last place I look for it!" ... because only an idiot would keep looking for it after finding it, so stop looking already. didn't find it anywhere.Attempt to load a class from a group of classloaders- the class to load- the group of classloaders to examinethe class- Remember the wisdom of Judge Smails: Well, the world needs ditch diggers, too. we'll ignore this until all classloaders fail to locate the class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/io/DefaultVFS.javaJAR_MAGIC/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/io/DefaultVFS.classClass<DefaultVFS>'P'P'K'4isresourcesjarUrl"Listing "Listing jarInput"Jar entry: "Jar entry: linesline"Reader entry: "Reader entry: List<URL>Collection<URL>Iterable<URL>Spliterator<URL>? super URLConsumer<? super URL>Iterator<URL>Stream<URL>BaseStream<URL,Stream<URL>>Predicate<? super URL>? extends URLCollection<? extends URL>Iterable<? extends URL>add(java.net.URL)ListIterator<URL>add(int,java.net.URL)set(int,java.net.URL)Comparator<? super URL>UnaryOperator<URL>Function<URL,URL>file"file""Listing directory "Listing directory resourcePathchildUrljar"Found resource: "Found resource: continueLoop".jar".jar"Find JAR URL: "Find JAR URL: "Inner URL: "Inner URL: "Not a JAR: "Not a JAR: "Extracted JAR URL: "Extracted JAR URL: testUrl"Unsupported encoding?  UTF-8?  That's impossible."Unsupported encoding?  UTF-8?  That's impossible."Trying real file: "Trying real file: "Invalid JAR URL: "Invalid JAR URL: buffer"Found JAR: "Found JAR: A default implementation of {@link VFS} that works for most application servers.Ben GunterThe magic header that indicates a JAR (ZIP) file. First, try to find the URL of a JAR file containing the requested resource. If a JAR file is found, then we'll list child resources by reading the JAR. Some versions of JBoss VFS might give a JAR stream even if the resource referenced by the URL isn't actually a JARSome servlet containers allow reading from directory resources like a text file, listing the childresources one per line. However, there is no way to differentiate between directory and file resourcesjust by reading them. To work around that, as each line is read, try to look it up via the class loaderas a child of the current resource. If any line fails then we assume the current resource is not adirectory. #1974 #2598For file URLs the openStream() call might fail, depending on the servlet container, because directoriescan't be opened for reading. If that happens, then list the directory directly instead. No idea where the exception came from so rethrow it The URL prefix to use when recursively listing child resources Iterate over immediate children, adding files and recurring into directories IgnoreList the names of the entries in the given {@link JarInputStream} that begin with the specified {@code path}.Entries will match with or without a leading slash.The JAR input streamThe leading path to matchThe names of all the matching entriesIOExceptionIf I/O errors occur Include the leading and trailing slash when matching names Iterate over the entries and collect those that begin with the requested path Add leading slash if it's missing Check file name Trim leading slashAttempts to deconstruct the given URL to find a JAR file containing the resource referenced by the URL. That is,assuming the URL references a JAR entry, this method will return a URL that references the JAR file containing theentry. If the JAR cannot be located, then this method returns null.The URL of the JAR entry.The URL of the JAR file, if one is found. Null if not.MalformedURLExceptionthe malformed URL exception If the file part of the URL is itself a URL, then that URL probably points to the JAR This will happen at some point and serves as a break in the loop Look for the .jar extension and chop off everything after that Try to open and test it WebLogic fix: check if the URL's file exists in the filesystem. File name might be URL-encodedConverts a Java package name to a path that can be looked up with a call to{@link ClassLoader#getResources(String)}.The Java package name to convert to a paththe package pathReturns true if the resource located at the given URL is a JAR file.The URL of the resource to test.true, if is jarA buffer into which the first few bytes of the resource are read. The buffer must be at least the size of{@link #JAR_MAGIC}. (The same buffer may be reused for multiple calls as an optimization.) Failure to read the stream means this is not a JAR/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/io/ExternalResources.javaExternalResourcesExternalResources()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/io/ExternalResources.classClass<ExternalResources>sourceFiledestFiledestinationtemplatePathtemplatePropertytemplateNamemigrationProperties/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/io/JBoss6VFS.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/io/JBoss6VFS.classClass<JBoss6VFS>List<VirtualFile>Collection<VirtualFile>Iterable<VirtualFile>getChildrengetChildren()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/io/JBoss6VFS$VirtualFile.classgetPathNameRelativeTogetPathNameRelativeTo(org.apache.ibatis.io.JBoss6VFS.VirtualFile)VirtualFileVirtualFile(java.lang.Object)virtualFilegetChildrenRecursively"This should not be possible. VirtualFile.getPathNameRelativeTo() threw IOException."This should not be possible. VirtualFile.getPathNameRelativeTo() threw IOException.ArrayList<VirtualFile>AbstractList<VirtualFile>AbstractCollection<VirtualFile>ArrayList<VirtualFile>(int)Spliterator<VirtualFile>? super VirtualFileConsumer<? super VirtualFile>Iterator<VirtualFile>Stream<VirtualFile>BaseStream<VirtualFile,Stream<VirtualFile>>Predicate<? super VirtualFile>? extends VirtualFileCollection<? extends VirtualFile>Iterable<? extends VirtualFile>add(org.apache.ibatis.io.JBoss6VFS.VirtualFile)AbstractCollection<VirtualFile>()ListIterator<VirtualFile>add(int,org.apache.ibatis.io.JBoss6VFS.VirtualFile)set(int,org.apache.ibatis.io.JBoss6VFS.VirtualFile)Comparator<? super VirtualFile>UnaryOperator<VirtualFile>Function<VirtualFile,VirtualFile>AbstractList<VirtualFile>()ArrayList<VirtualFile>(java.util.Collection)ArrayList<VirtualFile>()getChildgetChild(java.net.URL)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/io/JBoss6VFS$VFS.classVFSVFS()"org.jboss.vfs.VFS"org.jboss.vfs.VFS"org.jboss.vfs.VirtualFile"org.jboss.vfs.VirtualFileClass<URL>"getChild""getChildrenRecursively""getPathNameRelativeTo"expected"Method "Method Class<? extends Method>Constructor<? extends Method>TypeVariable<Class<? extends Method>>TypeVariable<Class<? extends Method>>[]"(..) should return "(..) should return " but returns " but returns " instead." instead."JBoss 6 VFS API is not available in this environment."JBoss 6 VFS API is not available in this environment.directoryvfA {@link VFS} implementation that works with the VFS API provided by JBoss 6.A class that mimics a tiny subset of the JBoss VirtualFile class. This exception is not thrown by the called methodA class that mimics a tiny subset of the JBoss VFS class.Flag that indicates if this VFS is valid for the current environment.Find all the classes and methods that are required to access the JBoss 6 VFS. Assume valid. It will get flipped later if something goes wrong. Look up and verify required classes Look up and verify required methods Verify that the API has not changedVerifies that the provided object reference is null. If it is null, then this VFS is marked as invalid for thecurrent environment.<T>the generic typeThe object reference to check for null.the tVerifies that the return type of method is what it is expected to be. If it is not, then this VFS is marked asinvalid for the current environment.The method whose return type is to be checked.A type to which the method's return type must be assignable.Class#isAssignableFrom(Class)Mark this {@link VFS} as invalid for the current environment./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/io/ResolverUtil.javaclassloadermatchesHashSet<Class<? extends T>>AbstractSet<Class<? extends T>>AbstractCollection<Class<? extends T>>HashSet<Class<? extends T>>()Spliterator<Class<? extends T>>? super Class<? extends T>Consumer<? super Class<? extends T>>Iterator<Class<? extends T>>Stream<Class<? extends T>>BaseStream<Class<? extends T>,Stream<Class<? extends T>>>Predicate<? super Class<? extends T>>? extends Class<? extends T>Collection<? extends Class<? extends T>>Iterable<? extends Class<? extends T>>AbstractCollection<Class<? extends T>>()AbstractSet<Class<? extends T>>()HashSet<Class<? extends T>>(int)HashSet<Class<? extends T>>(int,float)HashSet<Class<? extends T>>(java.util.Collection)Class<ResolverUtil<>>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/io/ResolverUtil$IsA.classparentType"is assignable to "is assignable to /Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/io/ResolverUtil$AnnotatedWith.class"annotated with @"annotated with @packageNamespkg".class".classioe"Could not read package: "Could not read package: fqnexternalNameloader"Checking to see if class "Checking to see if class " matches criteria [" matches criteria ["Could not examine class '"Could not examine class '"'" + " due to a "' due to a ? extends ThrowableClass<? extends Throwable>Constructor<? extends Throwable>Throwable[]TypeVariable<Class<? extends Throwable>>TypeVariable<Class<? extends Throwable>>[]" with message: " with message: ResolverUtil is used to locate classes that are available in the/a class path and meet arbitrary conditions. The twomost common conditions are that a class implements/extends another class, or that is it annotated with a specificannotation. However, through the use of the {@link Test} class it is possible to search using arbitrary conditions.A ClassLoader is used to locate all locations (directories and jar files) in the class path that contain classeswithin certain packages, and then to load those classes and check them. By default the ClassLoader returned by{@code Thread.currentThread().getContextClassLoader()} is used, but this can be overridden by calling{@link #setClassLoader(ClassLoader)} prior to invoking any of the {@code find()} methods.General searches are initiated by calling the {@link #find(Test, String)} and supplying a package name and a Testinstance. This will cause the named package <b>and all sub-packages</b> to be scanned for classes that meet the test.There are also utility methods for the common use cases of scanning multiple packages for extensions of particularclasses, or classes annotated with a specific annotation.The standard usage pattern for the ResolverUtil class is as follows:ResolverUtil&lt;ActionBean&gt; resolver = new ResolverUtil&lt;ActionBean&gt;();resolver.findImplementation(ActionBean.class, pkg1, pkg2);resolver.find(new CustomTest(), pkg1);resolver.find(new CustomTest(), pkg2);Collection&lt;ActionBean&gt; beans = resolver.getClasses();Tim FennellAn instance of Log to use for logging in this class.A simple interface that specifies how to test classes to determine if they are to be included in the resultsproduced by the ResolverUtil.Will be called repeatedly with candidate classes. Must return True if a class is to be included in the results,false otherwise.the typetrue, if successfulA Test that checks to see if each class is assignable to the provided class. Note that this test will match theparent type itself if it is presented for matching.The parent.Constructs an IsA test using the supplied Class as the parent class/interface.the parent typeReturns true if type is assignable to the parent type supplied in the constructor.A Test that checks to see if each class is annotated with a specific annotation. If it is, then the test returnstrue, otherwise false.The annotation.Constructs an AnnotatedWith test for the specified annotation type.the annotationReturns true if the type is annotated with the class provided to the constructor.The set of matches being accumulated.The ClassLoader to use when looking for classes. If null then the ClassLoader returned byThread.currentThread().getContextClassLoader() will be used.Provides access to the classes discovered so far. If no calls have been made to any of the {@code find()} methods,this set will be empty.the set of classes that have been discovered.Returns the classloader that will be used for scanning for classes. If no explicit ClassLoader has been set by thecalling, the context class loader will be used.the ClassLoader that will be used to scan for classesSets an explicit ClassLoader that should be used when scanning for classes. If none is set then the contextclassloader will be used.a ClassLoader to use when scanning for classesAttempts to discover classes that are assignable to the type provided. In the case that an interface is providedthis method will collect implementations. In the case of a non-interface class, subclasses will be collected.Accumulated classes can be accessed by calling {@link #getClasses()}.the class of interface to find subclasses or implementations ofone or more package names to scan (including subpackages) for classesthe resolver utilAttempts to discover classes that are annotated with the annotation. Accumulated classes can be accessed by calling{@link #getClasses()}.the annotation that should be present on matching classesScans for classes starting at the package provided and descending into subpackages. Each class is offered up to theTest as it is discovered, and if the Test returns true the class is retained. Accumulated classes can be fetched bycalling {@link #getClasses()}.an instance of {@link Test} that will be used to filter classesthe name of the package from which to start scanning for classes, e.g. {@code net.sourceforge.stripes}Add the class designated by the fully qualified class name provided to the set of resolved classes if and only ifit is approved by the Test supplied.the test used to determine if the class matchesthe fully qualified name of a class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/io/Resources.javaResourcesResources()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/io/Resources.classcharsetclassLoaderWrapper"Could not find resource "Could not find resource urlStringA class to simplify access to resources through the classloader.Charset to use when calling getResourceAsReader. null means use the system default.Returns the default classloader (may be null).The default classloaderSets the default classloader- the new default ClassLoaderReturns the URL of the resource on the classpathThe resource to findThe resourcejava.io.IOExceptionIf the resource cannot be found or read issue #625The classloader used to fetch the resourceReturns a resource on the classpath as a Stream objectReturns a resource on the classpath as a Properties objectReturns a resource on the classpath as a Reader objectReturns a resource on the classpath as a File object- the classloader used to fetch the resourceGets a URL as an input stream- the URL to getAn input stream with the data from the URLGets a URL as a ReaderA Reader with the data from the URLGets a URL as a Properties objectA Properties object with the data from the URLLoads a class- the class to fetchThe loaded classIf the class cannot be found (duh!)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/io/SerialFilterChecker.javaSerialFilterCheckerSerialFilterChecker()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/io/SerialFilterChecker.classfirstInvocationSERIAL_FILTER_MISSINGJDK_SERIAL_FILTERClass<SerialFilterChecker>"jdk.serialFilter"jdk.serialFilterserialFilterobjectFilterConfig"java.io.ObjectInputFilter$Config"java.io.ObjectInputFilter$Config"getSerialFilter"getSerialFilter"As you are using functionality that deserializes object streams, it is recommended to define the JEP-290 serial filter. "
              + "Please refer to https://docs.oracle.com/pls/topic/lookup?ctx=javase15&id=GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66"As you are using functionality that deserializes object streams, it is recommended to define the JEP-290 serial filter. Please refer to https://docs.oracle.com/pls/topic/lookup?ctx=javase15&id=GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66Property key for the JEP-290 serialization filters Java 1.8/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/io/VFS.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/io/VFS.classClass<VFS>List<Class<? extends VFS>>Collection<Class<? extends VFS>>Iterable<Class<? extends VFS>>ArrayList<Class<? extends VFS>>AbstractList<Class<? extends VFS>>AbstractCollection<Class<? extends VFS>>ArrayList<Class<? extends VFS>>()Spliterator<Class<? extends VFS>>? super Class<? extends VFS>Consumer<? super Class<? extends VFS>>Iterator<Class<? extends VFS>>Stream<Class<? extends VFS>>BaseStream<Class<? extends VFS>,Stream<Class<? extends VFS>>>Predicate<? super Class<? extends VFS>>? extends Class<? extends VFS>Collection<? extends Class<? extends VFS>>Iterable<? extends Class<? extends VFS>>AbstractCollection<Class<? extends VFS>>()ListIterator<Class<? extends VFS>>Comparator<? super Class<? extends VFS>>UnaryOperator<Class<? extends VFS>>Function<Class<? extends VFS>,Class<? extends VFS>>AbstractList<Class<? extends VFS>>()ArrayList<Class<? extends VFS>>(java.util.Collection)ArrayList<Class<? extends VFS>>(int)VFSHolderVFSHolder()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/io/VFS$VFSHolder.classcreateVFScreateVFS()INSTANCEimplsvfsClass<? extends VFS>[]implConstructor<? extends VFS>TypeVariable<Constructor<? extends VFS>>TypeVariable<Constructor<? extends VFS>>[]VFS[]TypeVariable<Class<? extends VFS>>TypeVariable<Class<? extends VFS>>[]"VFS implementation "VFS implementation " is not valid in this environment." is not valid in this environment."Failed to instantiate "Failed to instantiate "Using VFS adapter "Using VFS adapter "Class not found: "Class not found: "Security exception looking for method "Security exception looking for method ".  Cause: ".  Cause: "Method not found "Method not found parametersArrayList<URL>AbstractList<URL>AbstractCollection<URL>Enumeration<URL>forPathProvides a very simple API for accessing resources within an application server.The built-in implementations.The list to which implementations are added by {@link #addImplClass(Class)}.Singleton instance holder. Try the user implementations first, then the built-ins Try each implementation class until a valid one is foundGet the singleton {@link VFS} instance. If no {@link VFS} implementation can be found for the current environment,then this method returns null.single instance of VFSAdds the specified class to the list of {@link VFS} implementations. Classes added in this manner are tried in theorder they are added and before any of the built-in implementations.The {@link VFS} implementation class to add.Get a class by name. If the class is not found then return null.the class name return ReflectUtil.findClass(className);Get a method by name and parameter types. If the method is not found then return null.The class to which the method belongs.The name of the method.The types of the parameters accepted by the method.the methodInvoke a method on an object and return whatever it returns.The method to invoke.The instance or class (for static methods) on which to invoke the method.The parameters to pass to the method.Whatever the method returns.RuntimeExceptionIf anything else goes wrongGet a list of {@link URL}s from the context classloader for all the resources found at the specified path.The resource path.A list of {@link URL}s, as returned by {@link ClassLoader#getResources(String)}.Return true if the {@link VFS} implementation is valid for the current environment.true, if is validRecursively list the full resource path of all the resources that are children of the resource identified by a URL.The URL that identifies the resource to list.The path to the resource that is identified by the URL. Generally, this is the value passed to{@link #getResources(String)} to get the resource URL.A list containing the names of the child resources.Recursively list the full resource path of all the resources that are children of all the resources found at thespecified path.The path of the resource(s) to list./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/io/package-info.javaUtilities to read resources./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/jdbc/AbstractSQL.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/jdbcorg.apache.ibatis.jdbcsql()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/jdbc/AbstractSQL.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/jdbcORAND") \nAND (") 
AND (") \nOR (") 
OR (tablesetstableNameList<List<String>>Spliterator<List<String>>Consumer<? super List<String>>Iterator<List<String>>Stream<List<String>>BaseStream<List<String>,Stream<List<String>>>Predicate<? super List<String>>Collection<? extends List<String>>Iterable<? extends List<String>>add(java.util.List)ListIterator<List<String>>add(int,java.util.List)set(int,java.util.List)Comparator<? super List<String>>UnaryOperator<List<String>>Function<List<String>,List<String>>tablesjoinjoinsconditionsvariableaapplyConditionsqlConsumerselfapplyConditionSupplierForEachConsumer<>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/jdbc/AbstractSQL$ForEachConsumer.classiterableForEachConsumer<T,E>forEachSqlConsumerelementIndexaccept(java.lang.Object,java.lang.Object,int)sb/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/jdbc/AbstractSQL$SafeAppendable.classappendableupdateSQLupdateSQL(org.apache.ibatis.jdbc.AbstractSQL.SafeAppendable)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/jdbc/AbstractSQL$SQLStatement.classdeleteSQLdeleteSQL(org.apache.ibatis.jdbc.AbstractSQL.SafeAppendable)insertSQLinsertSQL(org.apache.ibatis.jdbc.AbstractSQL.SafeAppendable)joins(org.apache.ibatis.jdbc.AbstractSQL.SafeAppendable)selectSQLselectSQL(org.apache.ibatis.jdbc.AbstractSQL.SafeAppendable)sqlClausesqlClause(org.apache.ibatis.jdbc.AbstractSQL.SafeAppendable,java.lang.String,java.util.List,java.lang.String,java.lang.String,java.lang.String)limitingRowsStrategyoffsetvaluesListlastListorderBygroupByhavingwhererightOuterJoinleftOuterJoinouterJoininnerJoinArrayList<List<String>>AbstractList<List<String>>AbstractCollection<List<String>>ArrayList<List<String>>()AbstractCollection<List<String>>()AbstractList<List<String>>()ArrayList<List<String>>(java.util.Collection)ArrayList<List<String>>(int)StatementTypeStatementType()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/jdbc/AbstractSQL$SQLStatement$StatementType.classLimitingRowsStrategyLimitingRowsStrategy()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/jdbc/AbstractSQL$SQLStatement$LimitingRowsStrategy.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/jdbc/AbstractSQL$SQLStatement$LimitingRowsStrategy$1.classappendClauseappendClause(org.apache.ibatis.jdbc.AbstractSQL.SafeAppendable,java.lang.String,java.lang.String)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/jdbc/AbstractSQL$SQLStatement$LimitingRowsStrategy$2.class" OFFSET " OFFSET " ROWS" ROWS" FETCH FIRST " FETCH FIRST " ROWS ONLY" ROWS ONLY/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/jdbc/AbstractSQL$SQLStatement$LimitingRowsStrategy$3.class" LIMIT " LIMIT keywordopenconjunction"________"________"\n"part"SELECT DISTINCT"SELECT DISTINCT", ", "SELECT"SELECT"FROM"FROM"WHERE"WHERE"("" AND " AND "GROUP BY"GROUP BY"HAVING"HAVING"ORDER BY"ORDER BY"JOIN"JOIN"\nJOIN "
JOIN "INNER JOIN"INNER JOIN"\nINNER JOIN "
INNER JOIN "OUTER JOIN"OUTER JOIN"\nOUTER JOIN "
OUTER JOIN "LEFT OUTER JOIN"LEFT OUTER JOIN"\nLEFT OUTER JOIN "
LEFT OUTER JOIN "RIGHT OUTER JOIN"RIGHT OUTER JOIN"\nRIGHT OUTER JOIN "
RIGHT OUTER JOIN "INSERT INTO"INSERT INTO"VALUES"VALUES"DELETE FROM"DELETE FROM"UPDATE"UPDATE"SET"SETSets the.the setsInto columns.the columnsInto values.the valuesSelect.Select distinct.From.the tablesJoin.the joinsInner join.Left outer join.Right outer join.Outer join.Where.the conditionsGroup by.Having.Order by.Set the limit variable string(e.g. {@code "#{limit}"}).a limit variable stringa self instance#OFFSET(String)Set the limit value.an offset value#OFFSET(long)Set the offset variable string(e.g. {@code "#{offset}"}).a offset variable string#LIMIT(String)Set the offset value.#LIMIT(int)Set the fetch first rows variable string(e.g. {@code "#{fetchFirstRows}"}).a fetch first rows variable string#OFFSET_ROWS(String)Set the fetch first rows value.a fetch first rows value#OFFSET_ROWS(long)Set the offset rows variable string(e.g. {@code "#{offset}"}).a offset rows variable string#FETCH_FIRST_ROWS_ONLY(String)Set the offset rows value.an offset rows value#FETCH_FIRST_ROWS_ONLY(int)used to add a new inserted row while do multi-row insert.Apply sql phrases that provide by SQL consumer if condition is matches.if {@code true} apply sql phrasesa consumer that append sql phrase to SQL instance#applyIf(BooleanSupplier, Consumer)3.5.15if supplier return {@code true} apply sql phrases#applyIf(boolean, Consumer)Apply sql phrases that provide by SQL consumer for iterable.an iterable<E>element type of iterable Prevent Synthetic AccessConsumer for 'forEach' operation.SQL typeElement type of iterableAccept an iterable element with index.SQL instancean iterable elementan element index/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/jdbc/Null.javaNullNull(org.apache.ibatis.type.TypeHandler,org.apache.ibatis.type.JdbcType)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/jdbc/Null.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/jdbc/RuntimeSqlException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/jdbc/RuntimeSqlException.class5224696788505678598L5224696788505678598/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/jdbc/SQL.javaAbstractSQL<SQL>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/jdbc/ScriptRunner.javaprintlnErrorprintlnError(java.lang.Object)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/jdbc/ScriptRunner.classprintlnprintln(java.lang.Object)printprint(java.lang.Object)printResultsprintResults(java.sql.Statement,boolean)checkWarningscheckWarnings(java.sql.Statement)executeStatementexecuteStatement(java.lang.String)commandReadyToExecutecommandReadyToExecute(java.lang.String)lineIsCommentlineIsComment(java.lang.String)handleLinehandleLine(java.lang.StringBuilder,java.lang.String)checkForMissingLineTerminatorcheckForMissingLineTerminator(java.lang.StringBuilder)rollbackConnectionrollbackConnection()commitConnectioncommitConnection()setAutoCommitsetAutoCommit()executeLineByLineexecuteLineByLine(java.io.Reader)executeFullScriptexecuteFullScript(java.io.Reader)fullLineDelimiterdelimitererrorLogWriterescapeProcessingremoveCRssendFullScriptthrowWarningstopOnErrorDELIMITER_PATTERNDEFAULT_DELIMITER";";"^\\s*((--)|(//))?\\s*(//)?\\s*@DELIMITER\\s+([^\\s]+)"^\s*((--)|(//))?\s*(//)?\s*@DELIMITER\s+([^\s]+)scriptlineReader"Error executing: "Error executing: "Could not set AutoCommit to "Could not set AutoCommit to ". Cause: ". Cause: "Could not commit transaction. Cause: "Could not commit transaction. Cause: "Line missing end-of-line terminator ("Line missing end-of-line terminator (") => ") => trimmedLinematcher"//"//"--"--"\r\n"
hasResultswarningmdcols"\t""Error printing results: "Error printing results: This is an internal testing utility.<br>You are welcome to use this class for your own purposes,<br>but if there is some feature/enhancement you need for your own usage,<br>please make and modify your own copy instead of sending us an enhancement request.<br>Sets the escape processing.the new escape processing3.1.1Since 3.5.4, this method is deprecated. Please close the {@link Connection} outside of this class. issue #561 remove anything after the delimiter In Oracle, CREATE PROCEDURE, FUNCTION, etc. returns warning instead of throwing exception if there is compilation error./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/jdbc/SelectBuilder.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/jdbc/SelectBuilder.classSelectBuilderSelectBuilder()ThreadLocal<SQL>localSQLThreadLocal<SQL>()set(org.apache.ibatis.jdbc.SQL)SELECT(java.lang.String)applyForEachapplyForEach(java.lang.Iterable,org.apache.ibatis.jdbc.AbstractSQL.ForEachConsumer)ForEachConsumer<SQL,E>applyIfapplyIf(java.util.function.BooleanSupplier,java.util.function.Consumer)Consumer<SQL>applyIf(boolean,java.util.function.Consumer)usingAppenderusingAppender(java.lang.Appendable)ADD_ROWADD_ROW()OFFSET_ROWSOFFSET_ROWS(long)OFFSET_ROWS(java.lang.String)FETCH_FIRST_ROWS_ONLYFETCH_FIRST_ROWS_ONLY(int)FETCH_FIRST_ROWS_ONLY(java.lang.String)OFFSETOFFSET(long)OFFSET(java.lang.String)LIMITLIMIT(int)LIMIT(java.lang.String)ORDER_BYORDER_BY(java.lang.String[])ORDER_BY(java.lang.String)HAVING(java.lang.String[])HAVING(java.lang.String)GROUP_BYGROUP_BY(java.lang.String[])GROUP_BY(java.lang.String)AND()OR()WHERE(java.lang.String[])WHERE(java.lang.String)OUTER_JOINOUTER_JOIN(java.lang.String[])OUTER_JOIN(java.lang.String)RIGHT_OUTER_JOINRIGHT_OUTER_JOIN(java.lang.String[])RIGHT_OUTER_JOIN(java.lang.String)LEFT_OUTER_JOINLEFT_OUTER_JOIN(java.lang.String[])LEFT_OUTER_JOIN(java.lang.String)INNER_JOININNER_JOIN(java.lang.String[])INNER_JOIN(java.lang.String)JOIN(java.lang.String[])JOIN(java.lang.String)FROM(java.lang.String[])FROM(java.lang.String)DELETE_FROMDELETE_FROM(java.lang.String)SELECT_DISTINCTSELECT_DISTINCT(java.lang.String[])SELECT_DISTINCT(java.lang.String)SELECT(java.lang.String[])INTO_VALUESINTO_VALUES(java.lang.String[])INTO_COLUMNSINTO_COLUMNS(java.lang.String[])VALUES(java.lang.String,java.lang.String)INSERT_INTOINSERT_INTO(java.lang.String)SET(java.lang.String[])SET(java.lang.String)UPDATE(java.lang.String)getSelfgetSelf()AbstractSQLAbstractSQL()AbstractSQL<SQL>()Use the {@link SQL} Class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/jdbc/SqlBuilder.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/jdbc/SqlBuilder.classSqlBuilderSqlBuilder()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/jdbc/SqlRunner.javaList<Map<String,Object>>Collection<Map<String,Object>>Iterable<Map<String,Object>>getResultsgetResults(java.sql.ResultSet)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/jdbc/SqlRunner.classsetParameterssetParameters(java.sql.PreparedStatement,java.lang.Object[])useGeneratedKeySupport1001Spliterator<Map<String,Object>>? super Map<String,Object>Consumer<? super Map<String,Object>>Iterator<Map<String,Object>>Stream<Map<String,Object>>BaseStream<Map<String,Object>,Stream<Map<String,Object>>>Predicate<? super Map<String,Object>>? extends Map<String,Object>Collection<? extends Map<String,Object>>Iterable<? extends Map<String,Object>>add(java.util.Map)ListIterator<Map<String,Object>>add(int,java.util.Map)set(int,java.util.Map)Comparator<? super Map<String,Object>>UnaryOperator<Map<String,Object>>Function<Map<String,Object>,Map<String,Object>>"Statement returned "Statement returned " results where exactly one (1) was expected." results where exactly one (1) was expected.generatedKeysgenkey"SqlRunner requires an instance of Null to represent typed null values for JDBC compatibility"SqlRunner requires an instance of Null to represent typed null values for JDBC compatibilityTypeHandler<? extends Object>"SqlRunner could not find a TypeHandler instance for "SqlRunner could not find a TypeHandler instance for ArrayList<Map<String,Object>>AbstractList<Map<String,Object>>AbstractCollection<Map<String,Object>>ArrayList<Map<String,Object>>()AbstractCollection<Map<String,Object>>()AbstractList<Map<String,Object>>()ArrayList<Map<String,Object>>(java.util.Collection)ArrayList<Map<String,Object>>(int)List<TypeHandler<?>>ArrayList<TypeHandler<?>>AbstractList<TypeHandler<?>>AbstractCollection<TypeHandler<?>>ArrayList<TypeHandler<?>>()Spliterator<TypeHandler<?>>Consumer<? super TypeHandler<?>>Iterator<TypeHandler<?>>Stream<TypeHandler<?>>BaseStream<TypeHandler<?>,Stream<TypeHandler<?>>>Predicate<? super TypeHandler<?>>Collection<? extends TypeHandler<?>>Iterable<? extends TypeHandler<?>>add(org.apache.ibatis.type.TypeHandler)AbstractCollection<TypeHandler<?>>()ListIterator<TypeHandler<?>>add(int,org.apache.ibatis.type.TypeHandler)set(int,org.apache.ibatis.type.TypeHandler)Comparator<? super TypeHandler<?>>UnaryOperator<TypeHandler<?>>Function<TypeHandler<?>,TypeHandler<?>>AbstractList<TypeHandler<?>>()ArrayList<TypeHandler<?>>(java.util.Collection)ArrayList<TypeHandler<?>>(int)rowExecutes a SELECT statement that returns one row.The SQLThe arguments to be set on the statement.The row expected.If less or more than one row is returnedExecutes a SELECT statement that returns multiple rows.The list of rows expected.If statement preparation or execution failsExecutes an INSERT statement.The number of rows impacted or BATCHED_RESULTS if the statements are being batched. ignore, no numeric key supportExecutes an UPDATE statement.Executes a DELETE statement.Executes any string as a JDBC Statement. Good for DDL/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/jdbc/package-info.javaUtilities for JDBC./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/lang/UsesJava7.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/langorg.apache.ibatis.langIndicates that the element uses Java 7 API./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/lang/UsesJava8.javaIndicates that the element uses Java 8 API./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/lang/package-info.javaJava Language Package./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/Log.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/loggingorg.apache.ibatis.logging/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/LogException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/LogException.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging1022924004852350942L1022924004852350942/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/LogFactory.javasetImplementationsetImplementation(java.lang.Class)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/LogFactory.classtryImplementationtryImplementation(java.lang.Runnable)LogFactoryLogFactory()Constructor<? extends Log>logConstructor"MYBATIS"MYBATISloggerTypeVariable<Constructor<? extends Log>>TypeVariable<Constructor<? extends Log>>[]"Error creating logger for logger "Error creating logger for logger Class<Slf4jImpl>Class<JakartaCommonsLoggingImpl>Class<Log4jImpl>Class<Log4j2Impl>Class<Jdk14LoggingImpl>Class<StdOutImpl>Class<NoLoggingImpl>runnableimplClasscandidateLog[]TypeVariable<Class<? extends Log>>TypeVariable<Class<? extends Log>>[]Class<LogFactory>? super LogFactoryClass<? super LogFactory>Constructor<LogFactory>LogFactory[]TypeVariable<Class<LogFactory>>TypeVariable<Class<LogFactory>>[]"Logging initialized using '"Logging initialized using '"' adapter."' adapter."Error setting Log implementation.  Cause: "Error setting Log implementation.  Cause: Marker to be used by logging implementations that support markers. disable constructionSince 3.5.9 - See https://github.com/mybatis/mybatis-3/issues/1223. This method will remove future./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/commons/JakartaCommonsLoggingImpl.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/commonsorg.apache.ibatis.logging.commons/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/commons/JakartaCommonsLoggingImpl.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/commons/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/commons/package-info.javalogger using Commons Logging feature./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/jdbc/BaseJdbcLogger.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/jdbcorg.apache.ibatis.logging.jdbcprefix(boolean)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/jdbc/BaseJdbcLogger.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/jdbccolumnValuescolumnMapCollector<String,?,Set<String>>Function<Method,String>Class<PreparedStatement>? super PreparedStatementClass<? super PreparedStatement>Constructor<PreparedStatement>PreparedStatement[]TypeVariable<Class<PreparedStatement>>TypeVariable<Class<PreparedStatement>>[]"set""execute"execute"executeUpdate"executeUpdate"executeQuery"executeQuery"addBatch"addBatchqueryStacktypeListtextinputisInputchar[]'>'>'<'<Base class for proxies to do logging.Default constructor Intentialy fall through to return value.toString()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/jdbc/ConnectionLogger.javaConnectionLoggerConnectionLogger(java.sql.Connection,org.apache.ibatis.logging.Log,int)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/jdbc/ConnectionLogger.class"prepareStatement""prepareCall"prepareCall" Preparing: " Preparing: "createStatement"createStatementConnection proxy to add logging.Creates a logging version of a connection.the original connectionthe statement logthe query stackthe connection with loggingreturn the wrapped connection.the connection/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/jdbc/PreparedStatementLogger.javaPreparedStatementLoggerPreparedStatementLogger(java.sql.PreparedStatement,org.apache.ibatis.logging.Log,int)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/jdbc/PreparedStatementLogger.class"Parameters: "Parameters: "setNull"setNull"getResultSet"getResultSet"getUpdateCount"getUpdateCountupdateCount"   Updates: "   Updates: Class<CallableStatement>PreparedStatement proxy to add logging.Creates a logging version of a PreparedStatement.- the statement- the statement log- the query stack- the proxyReturn the wrapped prepared statement.the PreparedStatement/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/jdbc/ResultSetLogger.javaprintColumnValuesprintColumnValues(int)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/jdbc/ResultSetLogger.classprintColumnHeadersprintColumnHeaders(java.sql.ResultSetMetaData,int)ResultSetLoggerResultSetLogger(java.sql.ResultSet,org.apache.ibatis.logging.Log,int)Set<Integer>Collection<Integer>Iterable<Integer>blobColumnsfirstBLOB_TYPESHashSet<Integer>AbstractSet<Integer>AbstractCollection<Integer>HashSet<Integer>()Spliterator<Integer>? super IntegerConsumer<? super Integer>Iterator<Integer>Stream<Integer>BaseStream<Integer,Stream<Integer>>Predicate<? super Integer>? extends IntegerCollection<? extends Integer>Iterable<? extends Integer>add(java.lang.Integer)AbstractCollection<Integer>()AbstractSet<Integer>()HashSet<Integer>(int)HashSet<Integer>(int,float)HashSet<Integer>(java.util.Collection)"next""     Total: "     Total: "   Columns: "   Columns: "       Row: "       Row: "<<BLOB>>"<<BLOB>>"<<Cannot Display>>"<<Cannot Display>>? super ResultSetClass<? super ResultSet>Constructor<ResultSet>ResultSet[]TypeVariable<Class<ResultSet>>TypeVariable<Class<ResultSet>>[]ResultSet proxy to add logging. generally can't call getString() on a BLOB columnCreates a logging version of a ResultSet.the ResultSet to proxythe ResultSet with loggingGet the wrapped result set.the resultSet/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/jdbc/StatementLogger.javaStatementLoggerStatementLogger(java.sql.Statement,org.apache.ibatis.logging.Log,int)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/jdbc/StatementLogger.class" Executing: " Executing: Class<Statement>Class<? super Statement>Constructor<Statement>Statement[]TypeVariable<Class<Statement>>TypeVariable<Class<Statement>>[]Statement proxy to add logging.Creates a logging version of a Statement.the statementthe proxyreturn the wrapped statement./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/jdbc/package-info.javaLogging proxies that logs any JDBC statement./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/jdk14/Jdk14LoggingImpl.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/jdk14org.apache.ibatis.logging.jdk14/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/jdk14/Jdk14LoggingImpl.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/jdk14/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/jdk14/package-info.javalogger using JDK logging feature./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/log4j/Log4jImpl.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/log4jorg.apache.ibatis.logging.log4j/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/log4j/Log4jImpl.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/log4jFQCN? super Log4jImplClass<? super Log4jImpl>Constructor<Log4jImpl>Log4jImpl[]TypeVariable<Class<Log4jImpl>>TypeVariable<Class<Log4jImpl>>[]Since 3.5.9 - See https://github.com/mybatis/mybatis-3/issues/1223. This class will remove future./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/log4j/package-info.javalogger using Log4J feature.Since 3.5.9 - See https://github.com/mybatis/mybatis-3/issues/1223. This package will remove future./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/log4j2/Log4j2AbstractLoggerImpl.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/log4j2org.apache.ibatis.logging.log4j2/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/log4j2/Log4j2AbstractLoggerImpl.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/log4j2MARKER? super Log4j2ImplClass<? super Log4j2Impl>Constructor<Log4j2Impl>Log4j2Impl[]TypeVariable<Class<Log4j2Impl>>TypeVariable<Class<Log4j2Impl>>[]abstractLogger/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/log4j2/Log4j2Impl.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/log4j2/Log4j2Impl.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/log4j2/Log4j2LoggerImpl.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/log4j2/Log4j2LoggerImpl.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/log4j2/package-info.javalogger using Log4J 2 feature./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/nologging/NoLoggingImpl.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/nologgingorg.apache.ibatis.logging.nologging/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/nologging/package-info.javalogger for no operation./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/package-info.javaBase package for logging./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/slf4j/Slf4jImpl.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/slf4jorg.apache.ibatis.logging.slf4j/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/slf4j/Slf4jImpl.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/slf4j? extends LoggerClass<? extends Logger>Constructor<? extends Logger>Logger[]TypeVariable<Class<? extends Logger>>TypeVariable<Class<? extends Logger>>[]Class<Marker>Class<Object[]>Class<Throwable>"log" check for slf4j >= 1.6 method signature fail-back to Slf4jLoggerImpl Logger is not LocationAwareLogger or slf4j version < 1.6/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/slf4j/Slf4jLocationAwareLoggerImpl.javaSlf4jLocationAwareLoggerImplSlf4jLocationAwareLoggerImpl(org.slf4j.spi.LocationAwareLogger)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/slf4j/Slf4jLocationAwareLoggerImpl.class? super Slf4jImplClass<? super Slf4jImpl>Constructor<Slf4jImpl>Slf4jImpl[]TypeVariable<Class<Slf4jImpl>>TypeVariable<Class<Slf4jImpl>>[]/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/slf4j/Slf4jLoggerImpl.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/logging/slf4j/Slf4jLoggerImpl.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/slf4j/package-info.javalogger using SLF4J feature./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/stdout/StdOutImpl.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/stdoutorg.apache.ibatis.logging.stdout/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/logging/stdout/package-info.javalogger using standard out./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/BoundSql.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mappingorg.apache.ibatis.mapping/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/BoundSql.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mappingAn actual SQL String got from an {@link SqlSource} after having processed any dynamic content. The SQL may have SQLplaceholders "?" and a list (ordered) of a parameter mappings with the additional information for each parameter (atleast the property name of the input object to read the value from).Can also have additional parameters that are created by the dynamic language (for loops, bind...)./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/CacheBuilder.javaConstructor<? extends Cache>getCacheDecoratorConstructorgetCacheDecoratorConstructor(java.lang.Class)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/CacheBuilder.classnewCacheDecoratorInstancenewCacheDecoratorInstance(java.lang.Class,org.apache.ibatis.cache.Cache)getBaseCacheConstructorgetBaseCacheConstructor(java.lang.Class)newBaseCacheInstancenewBaseCacheInstance(java.lang.Class,java.lang.String)setCachePropertiessetCacheProperties(org.apache.ibatis.cache.Cache)setStandardDecoratorssetStandardDecorators(org.apache.ibatis.cache.Cache)setDefaultImplementationssetDefaultImplementations()List<Class<? extends Cache>>Collection<Class<? extends Cache>>Iterable<Class<? extends Cache>>decoratorsimplementationArrayList<Class<? extends Cache>>AbstractList<Class<? extends Cache>>AbstractCollection<Class<? extends Cache>>ArrayList<Class<? extends Cache>>()Spliterator<Class<? extends Cache>>? super Class<? extends Cache>Consumer<? super Class<? extends Cache>>Iterator<Class<? extends Cache>>Stream<Class<? extends Cache>>BaseStream<Class<? extends Cache>,Stream<Class<? extends Cache>>>Predicate<? super Class<? extends Cache>>? extends Class<? extends Cache>Collection<? extends Class<? extends Cache>>Iterable<? extends Class<? extends Cache>>AbstractCollection<Class<? extends Cache>>()ListIterator<Class<? extends Cache>>Comparator<? super Class<? extends Cache>>UnaryOperator<Class<? extends Cache>>Function<Class<? extends Cache>,Class<? extends Cache>>AbstractList<Class<? extends Cache>>()ArrayList<Class<? extends Cache>>(java.util.Collection)ArrayList<Class<? extends Cache>>(int)decoratorClass<LoggingCache>? super LoggingCacheClass<? super LoggingCache>Constructor<LoggingCache>LoggingCache[]TypeVariable<Class<LoggingCache>>TypeVariable<Class<LoggingCache>>[]metaCache"Error building standard cache decorators.  Cause: "Error building standard cache decorators.  Cause: Class<Short>Class<Byte>Class<Float>Class<Double>"Unsupported property type for cache: '"Unsupported property type for cache: '"' of type "' of type Class<InitializingObject>? super InitializingObjectClass<? super InitializingObject>Constructor<InitializingObject>InitializingObject[]TypeVariable<Class<InitializingObject>>TypeVariable<Class<InitializingObject>>[]"Failed cache initialization for '"Failed cache initialization for '"' on '"' on 'Cache[]TypeVariable<Class<? extends Cache>>TypeVariable<Class<? extends Cache>>[]cacheClasscacheConstructorTypeVariable<Constructor<? extends Cache>>TypeVariable<Constructor<? extends Cache>>[]"Could not instantiate cache implementation ("Could not instantiate cache implementation ("). Cause: "). Cause: "Invalid base cache implementation ("Invalid base cache implementation (").  "
          + "Base cache implementations must have a constructor that takes a String id as a parameter.  Cause: ").  Base cache implementations must have a constructor that takes a String id as a parameter.  Cause: "Could not instantiate cache decorator ("Could not instantiate cache decorator ("Invalid cache decorator ("Invalid cache decorator (").  "
          + "Cache decorators must have a constructor that takes a Cache instance as a parameter.  Cause: ").  Cache decorators must have a constructor that takes a Cache instance as a parameter.  Cause:  issue #352, do not apply decorators to custom caches/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/DatabaseIdProvider.javaShould return an id to identify the type of this database. That id can be used later on to build different queriesfor each database type This mechanism enables supporting multiple vendors or versions/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/DefaultDatabaseIdProvider.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/Discriminator.javaDiscriminatorDiscriminator()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/Discriminator.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/Discriminator$Builder.class lock down map/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/Environment.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/Environment.class"Parameter 'id' must not be null"Parameter 'id' must not be null"Parameter 'transactionFactory' must not be null"Parameter 'transactionFactory' must not be null"Parameter 'dataSource' must not be null"Parameter 'dataSource' must not be null/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/Environment$Builder.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/FetchType.javaFetchTypeFetchType()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/FetchType.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/MappedStatement.javadelimitedStringToArraydelimitedStringToArray(java.lang.String)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/MappedStatement.classMappedStatementMappedStatement()hasNestedResultMapsflushCacheRequired/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/MappedStatement$Builder.classlogId"defaultParameterMap"defaultParameterMappmrmIdrm constructor disabledResul sets.the result setthe builderUse {@link #resultSets}Gets the resul sets.the resul setsUse {@link #getResultSets()} check for nested result maps in parameter mappings (issue #30)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/ParameterMap.javaParameterMapParameterMap()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/ParameterMap.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/ParameterMap$Builder.class lock down collections/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/ParameterMapping.javaParameterMappingParameterMapping()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/ParameterMapping.classresolveTypeHandlerresolveTypeHandler()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/ParameterMapping$Builder.classvalidatevalidate()"Missing resultmap in property '"Missing resultmap in property '"'.  "
              + "Parameters of type java.sql.ResultSet require a resultmap."'.  Parameters of type java.sql.ResultSet require a resultmap."Type handler was null on parameter mapping for property '"Type handler was null on parameter mapping for property '"'. It was either not specified and/or could not be found for the javaType ("'. It was either not specified and/or could not be found for the javaType (") : jdbcType (") : jdbcType (") combination.") combination."ParameterMapping{"ParameterMapping{"property='"property=''\''", mode=", mode=", javaType=", javaType=", jdbcType=", jdbcType=", numericScale=", numericScale=", resultMapId='", resultMapId='", jdbcTypeName='", jdbcTypeName='", expression='", expression=''}'Used for handling output of callable statements.the modeUsed in the UnknownTypeHandler in case there is no handler for the property type.the numeric scaleUsed when setting parameters to the PreparedStatement.the jdbc type nameExpression 'Not used'.the expression sb.append("configuration=").append(configuration); // configuration doesn't have a useful .toString() sb.append(", typeHandler=").append(typeHandler); // typeHandler also doesn't have a useful .toString()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/ParameterMode.javaParameterModeParameterMode()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/ParameterMode.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/ResultFlag.javaResultFlagResultFlag()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/ResultFlag.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/ResultMap.javaResultMapResultMap()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/ResultMap.classhasNestedQueriesmappedPropertiespropertyResultMappingsconstructorResultMappingsidResultMappingsgetArgNamesgetArgNames(java.lang.reflect.Constructor)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/ResultMap$Builder.classargTypesMatchargTypesMatch(java.util.List,java.lang.Class[],java.util.List)argNamesOfMatchingConstructorargNamesOfMatchingConstructor(java.util.List)Class<Builder>constructorArgNames"ResultMaps must have an id"ResultMaps must have an idcompositeResultMappingcompositeColumnactualArgNames"Error in result map '"Error in result map '"'. Failed to find a constructor in '"'. Failed to find a constructor in '"' with arg names "' with arg names ". Note that 'javaType' is required when there is no writable property with the same name ('name' is optional, BTW). There might be more info in debug log.". Note that 'javaType' is required when there is no writable property with the same name ('name' is optional, BTW). There might be more info in debug log.Comparator<ResultMapping>ToDoubleFunction<>Comparator<T>comparingDoublecomparingDouble(java.util.function.ToDoubleFunction)ToLongFunction<>comparingLongcomparingLong(java.util.function.ToLongFunction)ToIntFunction<>comparingIntcomparingInt(java.util.function.ToIntFunction)Comparable<? super U>comparingcomparing(java.util.function.Function)comparing(java.util.function.Function,java.util.Comparator)Comparator<? super U>nullsLastnullsLast(java.util.Comparator)nullsFirstnullsFirst(java.util.Comparator)Comparable<? super T>naturalOrdernaturalOrder()reverseOrderreverseOrder()thenComparingDoublethenComparingDouble(java.util.function.ToDoubleFunction)ToDoubleFunction<? super ResultMapping>thenComparingLongthenComparingLong(java.util.function.ToLongFunction)ToLongFunction<? super ResultMapping>thenComparingIntthenComparingInt(java.util.function.ToIntFunction)ToIntFunction<? super ResultMapping>thenComparingthenComparing(java.util.function.Function)Function<? super ResultMapping,? extends U>thenComparing(java.util.function.Function,java.util.Comparator)thenComparing(java.util.Comparator)reversedreversed()comparecompare(java.lang.Object,java.lang.Object)compare(org.apache.ibatis.mapping.ResultMapping,org.apache.ibatis.mapping.ResultMapping)o1o2paramIdx1paramIdx2paramTypesparamNamesactualTypespecifiedType"While building result map '"While building result map '"', found a constructor with arg names "', found a constructor with arg names ", but the type of '", but the type of '"' did not match. Specified: ["' did not match. Specified: ["] Declared: ["] Declared: [actualParamNamesparamAnnotationsparamCountparamIndex"arg"/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/ResultMapping.javaResultMappingResultMapping()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/ResultMapping.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/ResultMapping$Builder.class"Cannot define both nestedQueryId and nestedResultMapId in property "Cannot define both nestedQueryId and nestedResultMapId in property "No typehandler found for property "No typehandler found for property "Mapping is missing column attribute for property "Mapping is missing column attribute for property numColumnsnumForeignColumns"There should be the same number of columns and foreignColumns in property "There should be the same number of columns and foreignColumns in property thatClass<? extends ResultMapping>"ResultMapping{"ResultMapping{", column='", column='", nestedResultMapId='", nestedResultMapId='", nestedQueryId='", nestedQueryId='", notNullColumns=", notNullColumns=", columnPrefix='", columnPrefix='", flags=", flags=", composites=", composites=", resultSet='", resultSet='", foreignColumn='", foreignColumn='", lazy=", lazy= Issue #697: cannot define both nestedQueryId and nestedResultMapId Issue #5: there should be no mappings without typehandler Issue #4 and GH #39: column is optional only in nested resultmaps but not in the rest/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/ResultSetType.javaResultSetTypeResultSetType(int)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/ResultSetType.classbehavior with same as unset (driver dependent)./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/SqlCommandType.javaSqlCommandTypeSqlCommandType()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/SqlCommandType.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/SqlSource.javaRepresents the content of a mapped statement read from an XML file or an annotation. It creates the SQL that will bepassed to the database out of the input parameter received from the user./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/StatementType.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/StatementType.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/VendorDatabaseIdProvider.javagetDatabaseProductNamegetDatabaseProductName(javax.sql.DataSource)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/mapping/VendorDatabaseIdProvider.classgetDatabaseNamegetDatabaseName(javax.sql.DataSource)"dataSource cannot be null"dataSource cannot be null"Error occurred when getting DB product name."Error occurred when getting DB product name.productNameorElse(java.lang.String)Optional<? extends String>? extends Optional<? extends String>Supplier<? extends Optional<? extends String>>Function<? super String,? extends Optional<? extends U>>Supplier<? extends String>Stream<Entry<Object,Object>>BaseStream<Entry<Object,Object>,Stream<Entry<Object,Object>>>? super Entry<Object,Object>Function<? super Entry<Object,Object>,? extends R>Spliterator<Entry<Object,Object>>Iterator<Entry<Object,Object>>List<Entry<Object,Object>>BiConsumer<? super Entry<Object,Object>,? super DoubleConsumer>BiConsumer<? super Entry<Object,Object>,? super LongConsumer>BiConsumer<? super Entry<Object,Object>,? super IntConsumer>BiConsumer<? super Entry<Object,Object>,? super Consumer<R>>Predicate<? super Entry<Object,Object>>Optional<Entry<Object,Object>>Comparator<? super Entry<Object,Object>>Collector<? super Entry<Object,Object>,A,R>BiConsumer<R,? super Entry<Object,Object>>BiFunction<U,? super Entry<Object,Object>,U>BinaryOperator<Entry<Object,Object>>BiFunction<Entry<Object,Object>,Entry<Object,Object>,Entry<Object,Object>>reduce(java.util.Map.Entry,java.util.function.BinaryOperator)Consumer<? super Entry<Object,Object>>Function<? super Entry<Object,Object>,? extends DoubleStream>Function<? super Entry<Object,Object>,? extends LongStream>Function<? super Entry<Object,Object>,? extends IntStream>Function<? super Entry<Object,Object>,? extends Stream<? extends R>>ToDoubleFunction<? super Entry<Object,Object>>ToLongFunction<? super Entry<Object,Object>>ToIntFunction<? super Entry<Object,Object>>Function<Entry<Object,Object>,String>Predicate<Entry<Object,Object>>? extends Entry<Object,Object>Collection<? extends Entry<Object,Object>>Iterable<? extends Entry<Object,Object>>add(java.util.Map.Entry)test(java.util.Map.Entry)Function<Entry<Object,Object>,V>Function<? super V,? extends Entry<Object,Object>>apply(java.util.Map.Entry)conVendor DatabaseId provider.It returns database product name as a databaseId. If the user provides a properties it uses it to translate databaseproduct name key="Microsoft SQL Server", value="ms" will return "ms". It can return null, if no database product nameor a properties was specified and no translation was found./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/mapping/package-info.javaBase package for mapping./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/package-info.javaorg.apache.ibatisThe MyBatis data mapper framework makes it easier to use a relational database with object-oriented applications./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/parsing/GenericTokenParser.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/parsingorg.apache.ibatis.parsing/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/parsing/GenericTokenParser.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/parsingcloseTokenopenTokensrc'\\'\ search open token this open token is escaped. remove the backslash and continue. found open token. let's search close token. this close token is escaped. remove the backslash and continue. close token was not found./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/parsing/ParsingException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/parsing/ParsingException.class176685891441325943L176685891441325943/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/parsing/PropertyParser.javaPropertyParserPropertyParser()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/parsing/PropertyParser.classDEFAULT_VALUE_SEPARATORENABLE_DEFAULT_VALUEKEY_PREFIX"org.apache.ibatis.parsing.PropertyParser."org.apache.ibatis.parsing.PropertyParser."enable-default-value"enable-default-value"default-value-separator"default-value-separator"false"string"${"${getPropertyValuegetPropertyValue(java.lang.String,java.lang.String)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/parsing/PropertyParser$VariableTokenHandler.classVariableTokenHandlerVariableTokenHandler(java.util.Properties)defaultValueSeparatorenableDefaultValueseparatorIndexThe special property key that indicate whether enable a default value on placeholder.The default value is {@code false} (indicate disable a default value on placeholder) If you specify the{@code true}, you can specify key and default value on placeholder (e.g. {@code ${db.username:postgres}}).The special property key that specify a separator for key and default value on placeholder.The default separator is {@code ":"}./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/parsing/TokenHandler.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/parsing/XNode.javagetBodyDatagetBodyData(org.w3c.dom.Node)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/parsing/XNode.classparseBodyparseBody(org.w3c.dom.Node)parseAttributesparseAttributes(org.w3c.dom.Node)indentindent(java.lang.StringBuilder,int)buildToStringbuildToString(java.lang.StringBuilder,int)xpathParserbodycurrent'_'"["[defenumTypedefSupplierArrayList<XNode>AbstractList<XNode>AbstractCollection<XNode>ArrayList<XNode>()Spliterator<XNode>Consumer<? super XNode>Iterator<XNode>Stream<XNode>BaseStream<XNode,Stream<XNode>>Predicate<? super XNode>Collection<? extends XNode>Iterable<? extends XNode>add(org.apache.ibatis.parsing.XNode)AbstractCollection<XNode>()ListIterator<XNode>add(int,org.apache.ibatis.parsing.XNode)set(int,org.apache.ibatis.parsing.XNode)Comparator<? super XNode>UnaryOperator<XNode>Function<XNode,XNode>AbstractList<XNode>()ArrayList<XNode>(java.util.Collection)ArrayList<XNode>(int)nodeListindentLevel"<""=\""=""\"""" />\n" />
">\n">
nodeType"</"</level"  "  attributeNodesattributeReturn a attribute value as String.If attribute value is absent, return value that provided from supplier of default value.attribute namea supplier of default valuethe string attribute3.5.4/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/parsing/XPathParser.javacommonConstructorcommonConstructor(boolean,java.util.Properties,org.xml.sax.EntityResolver)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/parsing/XPathParser.classcreateDocumentcreateDocument(org.xml.sax.InputSource)evaluateevaluate(java.lang.String,java.lang.Object,javax.xml.namespace.QName)xpathentityResolvervalidationdocumentxmlxnodesnodes"Error evaluating XPath.  Cause: "Error evaluating XPath.  Cause: inputSource/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/parsing/XPathParser$1.classwarning(org.xml.sax.SAXParseException)fatalErrorfatalError(org.xml.sax.SAXParseException)errorerror(org.xml.sax.SAXParseException)exception"Error creating document instance.  Cause: "Error creating document instance.  Cause:  important: this must only be called AFTER common constructor/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/parsing/package-info.javaParsing utils./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/plugin/Interceptor.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/pluginorg.apache.ibatis.plugininvocation/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/plugin/InterceptorChain.javaList<Interceptor>Collection<Interceptor>Iterable<Interceptor>interceptors/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/plugin/InterceptorChain.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/pluginArrayList<Interceptor>AbstractList<Interceptor>AbstractCollection<Interceptor>ArrayList<Interceptor>()Spliterator<Interceptor>? super InterceptorConsumer<? super Interceptor>Iterator<Interceptor>Stream<Interceptor>BaseStream<Interceptor,Stream<Interceptor>>Predicate<? super Interceptor>? extends InterceptorCollection<? extends Interceptor>Iterable<? extends Interceptor>add(org.apache.ibatis.plugin.Interceptor)AbstractCollection<Interceptor>()ListIterator<Interceptor>add(int,org.apache.ibatis.plugin.Interceptor)set(int,org.apache.ibatis.plugin.Interceptor)Comparator<? super Interceptor>UnaryOperator<Interceptor>Function<Interceptor,Interceptor>AbstractList<Interceptor>()ArrayList<Interceptor>(java.util.Collection)ArrayList<Interceptor>(int)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/plugin/Intercepts.javaSignature[]The annotation that specify target methods to intercept.&#064;Intercepts({ &#064;Signature(type = Executor.class,method = "update",args = { MappedStatement.class, Object.class }) })public class ExamplePlugin implements Interceptor {&#064;Overridepublic Object intercept(Invocation invocation) throws Throwable {// implement pre-processing if neededObject returnObject = invocation.proceed();// implement post-processing if neededreturn returnObject;Returns method signatures to intercept.method signatures/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/plugin/Invocation.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/plugin/Invocation.classtargetClassesClass<Executor>Class<ParameterHandler>Class<ResultSetHandler>Class<StatementHandler>"Method '"Method '"' is not supported as a plugin target."' is not supported as a plugin target./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/plugin/Plugin.javaMap<Class<?>,Set<Method>>getAllInterfacesgetAllInterfaces(java.lang.Class,java.util.Map)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/plugin/Plugin.classgetSignatureMapgetSignatureMap(org.apache.ibatis.plugin.Interceptor)PluginPlugin(java.lang.Object,org.apache.ibatis.plugin.Interceptor,java.util.Map)signatureMapinterfacesmethods? super Set<Method>? extends Set<Method>BiFunction<? super Set<Method>,? super Set<Method>,? extends Set<Method>>merge(java.lang.Class,java.util.Set,java.util.function.BiFunction)BiFunction<? super Class<?>,? super Set<Method>,? extends Set<Method>>Function<? super Class<?>,? extends Set<Method>>replace(java.lang.Class,java.util.Set)replace(java.lang.Class,java.util.Set,java.util.Set)putIfAbsent(java.lang.Class,java.util.Set)BiConsumer<? super Class<?>,? super Set<Method>>Entry<Class<?>,Set<Method>>Set<Entry<Class<?>,Set<Method>>>Collection<Entry<Class<?>,Set<Method>>>Iterable<Entry<Class<?>,Set<Method>>>Collection<Set<Method>>Iterable<Set<Method>>Map<? extends Class<?>,? extends Set<Method>>put(java.lang.Class,java.util.Set)interceptsAnnotationClass<? extends Interceptor>Constructor<? extends Interceptor>Interceptor[]TypeVariable<Class<? extends Interceptor>>TypeVariable<Class<? extends Interceptor>>[]Class<Intercepts>sigsHashMap<Class<?>,Set<Method>>AbstractMap<Class<?>,Set<Method>>HashMap<Class<?>,Set<Method>>()AbstractMap<Class<?>,Set<Method>>()HashMap<Class<?>,Set<Method>>(java.util.Map)HashMap<Class<?>,Set<Method>>(int)HashMap<Class<?>,Set<Method>>(int,float)"No @Intercepts annotation was found in interceptor "No @Intercepts annotation was found in interceptor sigFunction<Class<?>,Set<Method>>Function<Class<?>,V>Function<? super Set<Method>,? extends V>Function<V,Set<Method>>Function<? super V,? extends Class<?>>HashSet<Method>AbstractSet<Method>AbstractCollection<Method>HashSet<E>AbstractSet<E>HashSet<E>()AbstractSet<E>()HashSet<E>(int)HashSet<E>(int,float)HashSet<E>(java.util.Collection)"Could not find method on "Could not find method on " named " named HashSet<Class<?>>AbstractSet<Class<?>>HashSet<Class<?>>()AbstractSet<Class<?>>()HashSet<Class<?>>(int)HashSet<Class<?>>(int,float)HashSet<Class<?>>(java.util.Collection)? super ?Class<? super ?> issue #251/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/plugin/PluginException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/plugin/PluginException.class8548771664564998595L8548771664564998595/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/plugin/Signature.javaThe annotation that indicate the method signature.InterceptsReturns the java type.Returns the method name.the method nameReturns java types for method argument.java types for method argument/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/plugin/package-info.javaBase package for handing plugins./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/ArrayUtil.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflectionorg.apache.ibatis.reflectionArrayUtilArrayUtil()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/ArrayUtil.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflectionlong[]short[]Class<Character>boolean[]float[]double[]thisObjthatObjProvides hashCode, equals and toString methods that can handle array.Returns a hash code for {@code obj}.The object to get a hash code for. May be an array or <code>null</code>.A hash code of {@code obj} or 0 if {@code obj} is <code>null</code> for consistency with Arrays#hashCode() and Objects#hashCode()Compares two objects. Returns <code>true</code> if<li>{@code thisObj} and {@code thatObj} are both <code>null</code></li><li>{@code thisObj} and {@code thatObj} are instances of the same type and {@link Object#equals(Object)} returns<code>true</code></li><li>{@code thisObj} and {@code thatObj} are arrays with the same component type and equals() method of{@link Arrays} returns <code>true</code> (not deepEquals())</li>The left hand object to compare. May be an array or <code>null</code>The right hand object to compare. May be an array or <code>null</code><code>true</code> if two objects are equal; <code>false</code> otherwise.If the {@code obj} is an array, toString() method of {@link Arrays} is called. Otherwise {@link Object#toString()}is called. Returns "null" if {@code obj} is <code>null</code>.An object. May be an array or <code>null</code>.String representation of the {@code obj}./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/DefaultReflectorFactory.javaConcurrentMap<Class<?>,Reflector>Map<Class<?>,Reflector>reflectorMap/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/DefaultReflectorFactory.classclassCacheEnabledConcurrentHashMap<Class<?>,Reflector>AbstractMap<Class<?>,Reflector>ConcurrentHashMap<Class<?>,Reflector>()? super Reflector? extends ReflectorBiFunction<? super Reflector,? super Reflector,? extends Reflector>merge(java.lang.Class,org.apache.ibatis.reflection.Reflector,java.util.function.BiFunction)BiFunction<? super Class<?>,? super Reflector,? extends Reflector>Function<? super Class<?>,? extends Reflector>replace(java.lang.Class,org.apache.ibatis.reflection.Reflector)replace(java.lang.Class,org.apache.ibatis.reflection.Reflector,org.apache.ibatis.reflection.Reflector)putIfAbsent(java.lang.Class,org.apache.ibatis.reflection.Reflector)BiConsumer<? super Class<?>,? super Reflector>getOrDefault(java.lang.Object,org.apache.ibatis.reflection.Reflector)Entry<Class<?>,Reflector>Set<Entry<Class<?>,Reflector>>Collection<Entry<Class<?>,Reflector>>Iterable<Entry<Class<?>,Reflector>>Collection<Reflector>Iterable<Reflector>Map<? extends Class<?>,? extends Reflector>put(java.lang.Class,org.apache.ibatis.reflection.Reflector)AbstractMap<Class<?>,Reflector>()ToIntFunction<Entry<Class<?>,Reflector>>ToLongFunction<Entry<Class<?>,Reflector>>ToDoubleFunction<Entry<Class<?>,Reflector>>Function<Entry<Class<?>,Reflector>,? extends U>? extends Entry<Class<?>,Reflector>BiFunction<Entry<Class<?>,Reflector>,Entry<Class<?>,Reflector>,? extends Entry<Class<?>,Reflector>>? super Entry<Class<?>,Reflector>Consumer<? super Entry<Class<?>,Reflector>>ToIntFunction<? super Reflector>ToLongFunction<? super Reflector>ToDoubleFunction<? super Reflector>Function<? super Reflector,? extends U>Consumer<? super Reflector>ToIntBiFunction<? super Class<?>,? super Reflector>ToLongBiFunction<? super Class<?>,? super Reflector>ToDoubleBiFunction<? super Class<?>,? super Reflector>BiFunction<? super Class<?>,? super Reflector,? extends U>KeySetView<Class<?>,Reflector>CollectionView<Class<?>,Reflector,Class<?>>keySet(org.apache.ibatis.reflection.Reflector)Enumeration<Reflector>ConcurrentHashMap<Class<?>,Reflector>(int,float,int)ConcurrentHashMap<Class<?>,Reflector>(int,float)ConcurrentHashMap<Class<?>,Reflector>(java.util.Map)ConcurrentHashMap<Class<?>,Reflector>(int)Function<Class<?>,Reflector>Function<? super Reflector,? extends V>Function<V,Reflector> synchronized (type) removed see issue #461/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/ExceptionUtil.javaExceptionUtilExceptionUtil()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/ExceptionUtil.classwrappedunwrapped/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/Jdk.javaJdkJdk()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/Jdk.classavailable"java.lang.reflect.Parameter"java.lang.reflect.Parameter"java.time.Clock"java.time.Clock"java.util.Optional"java.util.OptionalTo check the existence of version dependent classes.<code>true</code> if <code>java.lang.reflect.Parameter</code> is available.Since 3.5.0, Will remove this field at feature(next major version up)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/MetaClass.javabuildPropertybuildProperty(java.lang.String,java.lang.StringBuilder)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/MetaClass.classgetGenericGetterTypegetGenericGetterType(java.lang.String)getGetterTypegetGetterType(org.apache.ibatis.reflection.property.PropertyTokenizer)metaClassForPropertymetaClassForProperty(org.apache.ibatis.reflection.property.PropertyTokenizer)MetaClassMetaClass(java.lang.Class,org.apache.ibatis.reflection.ReflectorFactory)reflectorpropuseCamelCaseMappingmetaPropinvokerdeclaredMethodClass<MethodInvoker>? super MethodInvokerClass<? super MethodInvoker>Constructor<MethodInvoker>MethodInvoker[]TypeVariable<Class<MethodInvoker>>TypeVariable<Class<MethodInvoker>>[]declaredFieldClass<GetFieldInvoker>? super GetFieldInvokerClass<? super GetFieldInvoker>Constructor<GetFieldInvoker>GetFieldInvoker[]TypeVariable<Class<GetFieldInvoker>>TypeVariable<Class<GetFieldInvoker>>[]"field"field issue #506. Resolve the type inside a Collection Object Ignored/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/MetaObject.javaMetaObjectMetaObject(java.lang.Object,org.apache.ibatis.reflection.factory.ObjectFactory,org.apache.ibatis.reflection.wrapper.ObjectWrapperFactory,org.apache.ibatis.reflection.ReflectorFactory)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/MetaObject.classobjectWrapperoriginalObjectpropName/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/OptionalUtil.javaOptionalUtilOptionalUtil()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/OptionalUtil.classSince 3.5.0, Will remove this class at future(next major version up)./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/ParamNameResolver.javaisSpecialParameterisSpecialParameter(java.lang.Class)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/ParamNameResolver.classgetActualParamNamegetActualParamName(java.lang.reflect.Method,int)hasParamAnnotationSortedMap<Integer,String>/BCDEFGHIJK/java.base/java/util/SortedMap.sigMap<Integer,String>"param"TreeMap<Integer,String>/FGHIJK/java.base/java/util/TreeMap.sig/FGHIJK/java.base/java/util/FGHIJK/java.base/java/FGHIJK/java.base/FGHIJKAbstractMap<Integer,String>NavigableMap<Integer,String>/BCDEFGHIJK/java.base/java/util/NavigableMap.sigTreeMap<Integer,String>()merge(java.lang.Integer,java.lang.String,java.util.function.BiFunction)BiFunction<? super Integer,? super String,? extends String>compute(java.lang.Integer,java.util.function.BiFunction)computeIfPresent(java.lang.Integer,java.util.function.BiFunction)Function<? super Integer,? extends String>computeIfAbsent(java.lang.Integer,java.util.function.Function)replace(java.lang.Integer,java.lang.String)replace(java.lang.Integer,java.lang.String,java.lang.String)putIfAbsent(java.lang.Integer,java.lang.String)BiConsumer<? super Integer,? super String>Entry<Integer,String>Set<Entry<Integer,String>>Collection<Entry<Integer,String>>Iterable<Entry<Integer,String>>Map<? extends Integer,? extends String>put(java.lang.Integer,java.lang.String)AbstractMap<Integer,String>()lastKeylastKey()firstKeyfirstKey()SortedMap<>tailMaptailMap(java.lang.Object)tailMap(java.lang.Integer)headMapheadMap(java.lang.Object)headMap(java.lang.Integer)subMapsubMap(java.lang.Object,java.lang.Object)subMap(java.lang.Integer,java.lang.Integer)comparatorcomparator()Comparator<? super Integer>SortedMap<K,V>NavigableMap<>tailMap(java.lang.Object,boolean)tailMap(java.lang.Integer,boolean)headMap(java.lang.Object,boolean)headMap(java.lang.Integer,boolean)subMap(java.lang.Object,boolean,java.lang.Object,boolean)subMap(java.lang.Integer,boolean,java.lang.Integer,boolean)NavigableSet<>/BCDEFGHIJK/java.base/java/util/NavigableSet.sigSortedSet<>/89ABCDEFGHIJK/java.base/java/util/SortedSet.sigNavigableSet<K>SortedSet<K>descendingKeySetdescendingKeySet()NavigableSet<Integer>SortedSet<Integer>navigableKeySetnavigableKeySet()descendingMapdescendingMap()pollLastEntrypollLastEntry()pollFirstEntrypollFirstEntry()lastEntrylastEntry()firstEntryfirstEntry()higherKeyhigherKey(java.lang.Object)higherKey(java.lang.Integer)higherEntryhigherEntry(java.lang.Object)higherEntry(java.lang.Integer)ceilingKeyceilingKey(java.lang.Object)ceilingKey(java.lang.Integer)ceilingEntryceilingEntry(java.lang.Object)ceilingEntry(java.lang.Integer)floorKeyfloorKey(java.lang.Object)floorKey(java.lang.Integer)floorEntryfloorEntry(java.lang.Object)floorEntry(java.lang.Integer)lowerKeylowerKey(java.lang.Object)lowerKey(java.lang.Integer)lowerEntrylowerEntry(java.lang.Object)lowerEntry(java.lang.Integer)NavigableMap<K,V>SortedMap<K,? extends V>Map<K,? extends V>TreeMapTreeMap(java.util.SortedMap)SortedMap<Integer,? extends String>Map<Integer,? extends String>TreeMap<Integer,String>(java.util.SortedMap)TreeMap(java.util.Map)TreeMap<Integer,String>(java.util.Map)TreeMap(java.util.Comparator)TreeMap<Integer,String>(java.util.Comparator)TreeMap()ParamMap<Object>ParamMap<Object>()genericParamNameactualParamName"list""array"The key is the index and the value is the name of the parameter.<br />The name is obtained from {@link Param} if specified. When {@link Param} is not specified, the parameter index isused. Note that this index could be different from the actual index when the method has special parameters (i.e.{@link RowBounds} or {@link ResultHandler}).<li>aMethod(@Param("M") int a, @Param("N") int b) -&gt; {{0, "M"}, {1, "N"}}</li><li>aMethod(int a, int b) -&gt; {{0, "0"}, {1, "1"}}</li><li>aMethod(int a, RowBounds rb, int b) -&gt; {{0, "0"}, {2, "1"}}</li> get names from @Param annotations skip special parameters @Param was not specified. use the parameter index as the name ("0", "1", ...) gcode issue #71Returns parameter names referenced by SQL providers.the namesA single non-special parameter is returned without a name. Multiple parameters are named using the naming rule. Inaddition to the default names, this method also adds the generic names (param1, param2, ...).the argsthe named params add generic param names (param1, param2, ...) ensure not to overwrite parameter named with @ParamWrap to a {@link ParamMap} if object is {@link Collection} or array.a parameter objectan actual parameter name (If specify a name, set an object to {@link ParamMap} with specified name)a {@link ParamMap}/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/ParamNameUtil.javaParamNameUtilParamNameUtil()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/ParamNameUtil.classgetParameterNamesgetParameterNames(java.lang.reflect.Executable)executableCollector<String,?,List<String>>Stream<Parameter>BaseStream<Parameter,Stream<Parameter>>? super ParameterFunction<? super Parameter,? extends R>Spliterator<Parameter>Iterator<Parameter>List<Parameter>Collection<Parameter>Iterable<Parameter>BiConsumer<? super Parameter,? super DoubleConsumer>BiConsumer<? super Parameter,? super LongConsumer>BiConsumer<? super Parameter,? super IntConsumer>BiConsumer<? super Parameter,? super Consumer<R>>Predicate<? super Parameter>Optional<Parameter>Comparator<? super Parameter>Collector<? super Parameter,A,R>BiConsumer<R,? super Parameter>BiFunction<U,? super Parameter,U>BinaryOperator<Parameter>BiFunction<Parameter,Parameter,Parameter>reduce(java.lang.reflect.Parameter,java.util.function.BinaryOperator)Consumer<? super Parameter>Function<? super Parameter,? extends DoubleStream>Function<? super Parameter,? extends LongStream>Function<? super Parameter,? extends IntStream>Function<? super Parameter,? extends Stream<? extends R>>ToDoubleFunction<? super Parameter>ToLongFunction<? super Parameter>ToIntFunction<? super Parameter>Function<Parameter,String>Function<Parameter,V>? extends ParameterFunction<? super V,? extends Parameter>apply(java.lang.reflect.Parameter)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/ReflectionException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/ReflectionException.class7642570221267566591L7642570221267566591/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/Reflector.javagetIsRecordMethodHandlegetIsRecordMethodHandle()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/Reflector.classisRecord(java.lang.Class)getSignaturegetSignature(java.lang.reflect.Method)Map<String,Method>addUniqueMethodsaddUniqueMethods(java.util.Map,java.lang.reflect.Method[])getClassMethodsgetClassMethods(java.lang.Class)isValidPropertyNameisValidPropertyName(java.lang.String)addGetFieldaddGetField(java.lang.reflect.Field)addSetFieldaddSetField(java.lang.reflect.Field)addFieldsaddFields(java.lang.Class)typeToClasstypeToClass(java.lang.reflect.Type)addSetMethodaddSetMethod(java.lang.String,java.lang.reflect.Method)pickBetterSetterpickBetterSetter(java.lang.reflect.Method,java.lang.reflect.Method,java.lang.String)Map<String,List<Method>>resolveSetterConflictsresolveSetterConflicts(java.util.Map)addMethodConflictaddMethodConflict(java.util.Map,java.lang.String,java.lang.reflect.Method)addSetMethodsaddSetMethods(java.lang.reflect.Method[])addGetMethodaddGetMethod(java.lang.String,java.lang.reflect.Method,boolean)resolveGetterConflictsresolveGetterConflicts(java.util.Map)addGetMethodsaddGetMethods(java.lang.reflect.Method[])addDefaultConstructoraddDefaultConstructor(java.lang.Class)addRecordGetMethodsaddRecordGetMethods(java.lang.reflect.Method[])caseInsensitivePropertyMapdefaultConstructorMap<String,Class<?>>getTypessetTypesMap<String,Invoker>setMethodswritablePropertyNamesreadablePropertyNamesisRecordMethodHandleHashMap<String,Invoker>AbstractMap<String,Invoker>HashMap<String,Invoker>()? super Invoker? extends InvokerBiFunction<? super Invoker,? super Invoker,? extends Invoker>merge(java.lang.String,org.apache.ibatis.reflection.invoker.Invoker,java.util.function.BiFunction)BiFunction<? super String,? super Invoker,? extends Invoker>Function<? super String,? extends Invoker>replace(java.lang.String,org.apache.ibatis.reflection.invoker.Invoker)replace(java.lang.String,org.apache.ibatis.reflection.invoker.Invoker,org.apache.ibatis.reflection.invoker.Invoker)putIfAbsent(java.lang.String,org.apache.ibatis.reflection.invoker.Invoker)BiConsumer<? super String,? super Invoker>getOrDefault(java.lang.Object,org.apache.ibatis.reflection.invoker.Invoker)Entry<String,Invoker>Set<Entry<String,Invoker>>Collection<Entry<String,Invoker>>Iterable<Entry<String,Invoker>>Collection<Invoker>Iterable<Invoker>Map<? extends String,? extends Invoker>put(java.lang.String,org.apache.ibatis.reflection.invoker.Invoker)AbstractMap<String,Invoker>()HashMap<String,Invoker>(java.util.Map)HashMap<String,Invoker>(int)HashMap<String,Invoker>(int,float)HashMap<String,Class<?>>AbstractMap<String,Class<?>>HashMap<String,Class<?>>()merge(java.lang.String,java.lang.Class,java.util.function.BiFunction)BiFunction<? super String,? super Class<?>,? extends Class<?>>Function<? super String,? extends Class<?>>replace(java.lang.String,java.lang.Class)replace(java.lang.String,java.lang.Class,java.lang.Class)putIfAbsent(java.lang.String,java.lang.Class)BiConsumer<? super String,? super Class<?>>getOrDefault(java.lang.Object,java.lang.Class)Entry<String,Class<?>>Set<Entry<String,Class<?>>>Collection<Entry<String,Class<?>>>Iterable<Entry<String,Class<?>>>Map<? extends String,? extends Class<?>>put(java.lang.String,java.lang.Class)AbstractMap<String,Class<?>>()HashMap<String,Class<?>>(java.util.Map)HashMap<String,Class<?>>(int)HashMap<String,Class<?>>(int,float)classMethodsConsumer<Method>accept(java.lang.reflect.Method)Consumer<Constructor<?>>accept(java.lang.reflect.Constructor)conflictingGettersHashMap<String,List<Method>>AbstractMap<String,List<Method>>HashMap<String,List<Method>>()? super List<Method>? extends List<Method>BiFunction<? super List<Method>,? super List<Method>,? extends List<Method>>BiFunction<? super String,? super List<Method>,? extends List<Method>>Function<? super String,? extends List<Method>>BiConsumer<? super String,? super List<Method>>Entry<String,List<Method>>Set<Entry<String,List<Method>>>Collection<Entry<String,List<Method>>>Iterable<Entry<String,List<Method>>>Collection<List<Method>>Iterable<List<Method>>Map<? extends String,? extends List<Method>>AbstractMap<String,List<Method>>()HashMap<String,List<Method>>(java.util.Map)HashMap<String,List<Method>>(int)HashMap<String,List<Method>>(int,float)winnerisAmbiguouswinnerTypecandidateType"is""Illegal overloaded getter method with ambiguous type for property ''{0}'' in class ''{1}''. This breaks the JavaBeans specification and can cause unpredictable results."Illegal overloaded getter method with ambiguous type for property ''{0}'' in class ''{1}''. This breaks the JavaBeans specification and can cause unpredictable results.conflictingSettersconflictingMethodsFunction<String,List<Method>>Function<? super List<Method>,? extends V>Function<V,List<Method>>ArrayList<Method>AbstractList<Method>settersgetterTypeisGetterAmbiguousisSetterAmbiguoussettersetter1setter2paramType1paramType2"Ambiguous setters defined for property ''{0}'' in class ''{1}'' with types ''{2}'' and ''{3}''."Ambiguous setters defined for property ''{0}'' in class ''{1}'' with types ''{2}'' and ''{3}''.componentClassfieldsmodifiersfieldType"$"$"serialVersionUID"uniqueMethodsHashMap<String,Method>AbstractMap<String,Method>HashMap<String,Method>()merge(java.lang.String,java.lang.reflect.Method,java.util.function.BiFunction)BiFunction<? super String,? super Method,? extends Method>Function<? super String,? extends Method>replace(java.lang.String,java.lang.reflect.Method)replace(java.lang.String,java.lang.reflect.Method,java.lang.reflect.Method)putIfAbsent(java.lang.String,java.lang.reflect.Method)BiConsumer<? super String,? super Method>getOrDefault(java.lang.Object,java.lang.reflect.Method)Entry<String,Method>Set<Entry<String,Method>>Collection<Entry<String,Method>>Iterable<Entry<String,Method>>Map<? extends String,? extends Method>put(java.lang.String,java.lang.reflect.Method)AbstractMap<String,Method>()HashMap<String,Method>(java.util.Map)HashMap<String,Method>(int)HashMap<String,Method>(int,float)currentClassanInterfacecurrentMethodsignature'#'#securityManager"suppressAccessChecks"suppressAccessChecks"There is no default constructor for "There is no default constructor for "There is no setter for property named '"There is no setter for property named '"There is no getter for property named '"There is no getter for property named '"Failed to invoke 'Class.isRecord()'."Failed to invoke 'Class.isRecord()'.mt"isRecord"This class represents a cached set of class definition information that allows for easy mapping between propertynames and getter/setter methods. OK getter type is descendant should be the best match issue #379 - removed the check for final because JDK 1.5 allows modification of final fields through reflection (JSR-133). (JGB) pr #16 - final static can only be set by the classloaderThis method returns an array containing all methods declared in this class and any superclass. We use this method,instead of the simpler <code>Class.getMethods()</code>, because we want to look for private methods as well.The classAn array containing all methods in this class we also need to look for interface methods - because the class may be abstract check to see if the method is already known if it is known, then an extended class must have overridden a methodChecks whether can control member accessible.If can control member accessible, it return {@literal true}Gets the name of the class the instance provides information for.The class nameGets the type for a property setter.- the name of the propertyThe Class of the property setterGets the type for a property getter.The Class of the property getterGets an array of the readable properties for an object.The arrayGets an array of the writable properties for an object.Check to see if a class has a writable property by name.- the name of the property to checkTrue if the object has a writable property by the nameCheck to see if a class has a readable property by name.True if the object has a readable property by the nameClass.isRecord() alternative for Java 15 and older./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/ReflectorFactory.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/SystemMetaObject.javaSystemMetaObjectSystemMetaObject()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/SystemMetaObject.classNullObjectNullObject()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/SystemMetaObject$NullObject.class Prevent Instantiation of Static Class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/TypeParameterResolver.javaTypeParameterResolverTypeParameterResolver()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/TypeParameterResolver.classtranslateParentTypeVarstranslateParentTypeVars(java.lang.reflect.ParameterizedType,java.lang.Class,java.lang.reflect.ParameterizedType)TypeVariable<?>scanSuperTypesscanSuperTypes(java.lang.reflect.TypeVariable,java.lang.reflect.Type,java.lang.Class,java.lang.Class,java.lang.reflect.Type)resolveTypeVarresolveTypeVar(java.lang.reflect.TypeVariable,java.lang.reflect.Type,java.lang.Class)resolveWildcardTypeBoundsresolveWildcardTypeBounds(java.lang.reflect.Type[],java.lang.reflect.Type,java.lang.Class)resolveWildcardTyperesolveWildcardType(java.lang.reflect.WildcardType,java.lang.reflect.Type,java.lang.Class)resolveParameterizedTyperesolveParameterizedType(java.lang.reflect.ParameterizedType,java.lang.reflect.Type,java.lang.Class)resolveGenericArrayTyperesolveGenericArrayType(java.lang.reflect.GenericArrayType,java.lang.reflect.Type,java.lang.Class)resolveTyperesolveType(java.lang.reflect.Type,java.lang.reflect.Type,java.lang.Class)srcTypegenericArrayTyperesolvedComponentTypetypeArgswildcardTypelowerBoundsupperBoundsboundstypeVarsuperclasssuperInterfaces? extends TypeClass<? extends Type>"The 2nd arg must be Class or ParameterizedType, but was: "The 2nd arg must be Class or ParameterizedType, but was: getBoundsgetBounds()getAnnotatedBoundsgetAnnotatedBounds()getGenericDeclarationgetGenericDeclaration()parentAsTypeparentAsClassTypeVariable<?>[]parentTypeVarssrcClassparentTypeArgssrcTypeArgssrcTypeVarsnewParentArgsnoChangej/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/TypeParameterResolver$ParameterizedTypeImpl.classownerType"ParameterizedTypeImpl [rawType="ParameterizedTypeImpl [rawType=", ownerType=", ownerType=", actualTypeArguments=", actualTypeArguments=WildcardTypeImplWildcardTypeImpl(java.lang.reflect.Type[],java.lang.reflect.Type[])/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/TypeParameterResolver$WildcardTypeImpl.classGenericArrayTypeImplGenericArrayTypeImpl(java.lang.reflect.Type)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/TypeParameterResolver$GenericArrayTypeImpl.classgenericComponentTypeResolve field type.the fieldthe src typeThe field type as {@link Type}. If it has type parameters in the declaration,<br>they will be resolved to the actual runtime {@link Type}s.Resolve return type.The return type of the method as {@link Type}. If it has type parameters in the declaration,<br>Resolve param types.The parameter types of the method as an array of {@link Type}s. If they have type parameters in thedeclaration,<br>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/factory/DefaultObjectFactory.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/factoryorg.apache.ibatis.reflection.factory/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/factory/DefaultObjectFactory.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/factoryinstantiateClassinstantiateClass(java.lang.Class,java.util.List,java.util.List)8855120656740914948L8855120656740914948classToCreateTypeVariable<Constructor<T>>TypeVariable<Constructor<T>>[]Collector<CharSequence,?,String>Function<? super Class<?>,? extends R>BiConsumer<? super Class<?>,? super DoubleConsumer>BiConsumer<? super Class<?>,? super LongConsumer>BiConsumer<? super Class<?>,? super IntConsumer>BiConsumer<? super Class<?>,? super Consumer<R>>Optional<Class<?>>Collector<? super Class<?>,A,R>BiConsumer<R,? super Class<?>>BiFunction<U,? super Class<?>,U>BinaryOperator<Class<?>>BiFunction<Class<?>,Class<?>,Class<?>>Function<? super Class<?>,? extends DoubleStream>Function<? super Class<?>,? extends LongStream>Function<? super Class<?>,? extends IntStream>Function<? super Class<?>,? extends Stream<? extends R>>Function<Class<?>,String>Optional<List<Class<?>>>? extends List<Class<?>>Supplier<? extends List<Class<?>>>Stream<List<Class<?>>>BaseStream<List<Class<?>>,Stream<List<Class<?>>>>Optional<? extends List<Class<?>>>? extends Optional<? extends List<Class<?>>>Supplier<? extends Optional<? extends List<Class<?>>>>? super List<Class<?>>Function<? super List<Class<?>>,? extends Optional<? extends U>>Consumer<? super List<Class<?>>>orElse(java.util.List)Function<? super List<Class<?>>,? extends U>Predicate<? super List<Class<?>>>Supplier<List<Class<?>>>argValuesOptional<List<Object>>? extends List<Object>Supplier<? extends List<Object>>Stream<List<Object>>BaseStream<List<Object>,Stream<List<Object>>>Optional<? extends List<Object>>? extends Optional<? extends List<Object>>Supplier<? extends Optional<? extends List<Object>>>? super List<Object>Function<? super List<Object>,? extends Optional<? extends U>>Consumer<? super List<Object>>Function<? super List<Object>,? extends U>Predicate<? super List<Object>>Supplier<List<Object>>"Error instantiating "Error instantiating " with invalid types (" with invalid types (") or values (") or values (Class<Iterable<>>Class<ArrayList<>>Class<HashMap<>>Class<SortedSet<>>TreeSet<>/G/java.base/java/util/TreeSet.sigAbstractSet<>Class<TreeSet<>>Class<Set<>>HashSet<>Class<HashSet<>> we know types are assignable issue #510 Collections Support/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/factory/ObjectFactory.javaMyBatis uses an ObjectFactory to create all needed new Objects.Sets configuration properties.configuration propertiesCreates a new object with default constructor.Object typeCreates a new object with the specified constructor and params.Constructor argument typesConstructor argument valuesReturns true if this object can have a set of other objects. It's main purpose is to supportnon-java.util.Collection objects like Scala collections.whether it is a collection or not3.1.0/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/factory/package-info.javaObject factory./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/invoker/AmbiguousMethodInvoker.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/invokerorg.apache.ibatis.reflection.invokerexceptionMessage/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/invoker/AmbiguousMethodInvoker.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/invoker/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/invoker/GetFieldInvoker.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/invoker/GetFieldInvoker.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/invoker/Invoker.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/invoker/MethodInvoker.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/invoker/MethodInvoker.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/invoker/SetFieldInvoker.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/invoker/SetFieldInvoker.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/invoker/package-info.javaUnused./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/package-info.javaReflection utils./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/property/PropertyCopier.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/propertyorg.apache.ibatis.reflection.propertyPropertyCopierPropertyCopier()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/property/PropertyCopier.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/propertysourceBeandestinationBean Nothing useful to do, will only fail on final fields, which will be ignored./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/property/PropertyNamer.javaPropertyNamerPropertyNamer()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/property/PropertyNamer.class"get""Error parsing property name '"Error parsing property name '"'.  Didn't start with 'is', 'get' or 'set'."'.  Didn't start with 'is', 'get' or 'set'./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/property/PropertyTokenizer.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/property/PropertyTokenizer.classindexedNameIterator<PropertyTokenizer>fullnamedelim'['"Remove is not supported, as it has no meaning in the context of properties."Remove is not supported, as it has no meaning in the context of properties./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/property/package-info.javaTools for getting/setting properties./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/wrapper/BaseWrapper.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/wrapperorg.apache.ibatis.reflection.wrapper"Cannot get the value '"Cannot get the value '"' because the property '"' because the property '"' is null."' is null."' is not Map, List or Array."' is not Map, List or Array."Cannot set the value '"Cannot set the value 'metaValue don't instantiate child path if value is null/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/wrapper/BeanWrapper.javasetBeanPropertysetBeanProperty(org.apache.ibatis.reflection.property.PropertyTokenizer,java.lang.Object,java.lang.Object)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/wrapper/BeanWrapper.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/wrappergetBeanPropertygetBeanProperty(org.apache.ibatis.reflection.property.PropertyTokenizer,java.lang.Object)"Cannot set value of property '"Cannot set value of property '"' because '"' because '"' is null and cannot be instantiated on instance of "' is null and cannot be instantiated on instance of ". Cause:". Cause:"Could not get property '"Could not get property '"' from "' from "Could not set property '"Could not set property '"' of '"' of '"' with value '"' with value '"' Cause: "' Cause: /Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/wrapper/CollectionWrapper.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/reflection/wrapper/CollectionWrapper.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/wrapper/DefaultObjectWrapperFactory.java"The DefaultObjectWrapperFactory should never be called to provide an ObjectWrapper."The DefaultObjectWrapperFactory should never be called to provide an ObjectWrapper./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/wrapper/MapWrapper.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/wrapper/ObjectWrapper.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/wrapper/ObjectWrapperFactory.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/reflection/wrapper/package-info.javaObject wrappers./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/LanguageDriver.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scriptingorg.apache.ibatis.scriptingCreates a {@link ParameterHandler} that passes the actual parameters to the the JDBC statement.The mapped statement that is being executedThe input parameter object (can be null)The resulting SQL once the dynamic language has been executed.the parameter handlerDefaultParameterHandlerCreates an {@link SqlSource} that will hold the statement read from a mapper xml file. It is called during startup,when the mapped statement is read from a class or an xml file.The MyBatis configurationXNode parsed from a XML fileinput parameter type got from a mapper method or specified in the parameterType xml attribute. Can benull.Creates an {@link SqlSource} that will hold the statement read from an annotation. It is called during startup,The content of the annotation/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/LanguageDriverRegistry.javadefaultDriverClass/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/LanguageDriverRegistry.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scriptingMap<Class<? extends LanguageDriver>,LanguageDriver>LANGUAGE_DRIVER_MAPHashMap<Class<? extends LanguageDriver>,LanguageDriver>AbstractMap<Class<? extends LanguageDriver>,LanguageDriver>HashMap<Class<? extends LanguageDriver>,LanguageDriver>()? super LanguageDriverBiFunction<? super LanguageDriver,? super LanguageDriver,? extends LanguageDriver>merge(java.lang.Class,org.apache.ibatis.scripting.LanguageDriver,java.util.function.BiFunction)? super Class<? extends LanguageDriver>BiFunction<? super Class<? extends LanguageDriver>,? super LanguageDriver,? extends LanguageDriver>Function<? super Class<? extends LanguageDriver>,? extends LanguageDriver>replace(java.lang.Class,org.apache.ibatis.scripting.LanguageDriver)replace(java.lang.Class,org.apache.ibatis.scripting.LanguageDriver,org.apache.ibatis.scripting.LanguageDriver)putIfAbsent(java.lang.Class,org.apache.ibatis.scripting.LanguageDriver)BiConsumer<? super Class<? extends LanguageDriver>,? super LanguageDriver>getOrDefault(java.lang.Object,org.apache.ibatis.scripting.LanguageDriver)Entry<Class<? extends LanguageDriver>,LanguageDriver>Set<Entry<Class<? extends LanguageDriver>,LanguageDriver>>Collection<Entry<Class<? extends LanguageDriver>,LanguageDriver>>Iterable<Entry<Class<? extends LanguageDriver>,LanguageDriver>>Collection<LanguageDriver>Iterable<LanguageDriver>Set<Class<? extends LanguageDriver>>Collection<Class<? extends LanguageDriver>>Iterable<Class<? extends LanguageDriver>>? extends Class<? extends LanguageDriver>Map<? extends Class<? extends LanguageDriver>,? extends LanguageDriver>put(java.lang.Class,org.apache.ibatis.scripting.LanguageDriver)AbstractMap<Class<? extends LanguageDriver>,LanguageDriver>()HashMap<Class<? extends LanguageDriver>,LanguageDriver>(java.util.Map)HashMap<Class<? extends LanguageDriver>,LanguageDriver>(int)HashMap<Class<? extends LanguageDriver>,LanguageDriver>(int,float)cls"null is not a valid Language Driver"null is not a valid Language DriverFunction<Class<? extends LanguageDriver>,LanguageDriver>Function<Class<? extends LanguageDriver>,V>Function<? super LanguageDriver,? extends V>Function<V,LanguageDriver>Function<? super V,? extends Class<? extends LanguageDriver>>Constructor<? extends LanguageDriver>TypeVariable<Constructor<? extends LanguageDriver>>TypeVariable<Constructor<? extends LanguageDriver>>[]LanguageDriver[]TypeVariable<Class<? extends LanguageDriver>>TypeVariable<Class<? extends LanguageDriver>>[]"Failed to load language driver for "Failed to load language driver for instance/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/ScriptingException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/ScriptingException.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/defaults/DefaultParameterHandler.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/defaultsorg.apache.ibatis.scripting.defaults/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/defaults/DefaultParameterHandler.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/defaults"setting parameters"setting parameters"Could not set parameters for mapping: "Could not set parameters for mapping:  issue #448 ask first for additional params/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/defaults/RawLanguageDriver.javacheckIsNotDynamiccheckIsNotDynamic(org.apache.ibatis.mapping.SqlSource)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/defaults/RawLanguageDriver.classClass<RawSqlSource>? extends SqlSourceClass<? extends SqlSource>"Dynamic content is not allowed when using RAW language"Dynamic content is not allowed when using RAW languageAs of 3.2.4 the default XML language is able to identify static statements and create a {@link RawSqlSource}. Sothere is no need to use RAW unless you want to make sure that there is not any dynamic tag for any reason./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/defaults/RawSqlSource.javagetSqlgetSql(org.apache.ibatis.session.Configuration,org.apache.ibatis.scripting.xmltags.SqlNode)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/defaults/RawSqlSource.classrootSqlNodesqlSourceParserStatic SqlSource. It is faster than {@link DynamicSqlSource} because mappings are calculated during startup./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/defaults/package-info.javaDefault beans for languages./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/package-info.javaBase package for languages./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/ChooseSqlNode.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltagsorg.apache.ibatis.scripting.xmltagsList<SqlNode>Collection<SqlNode>Iterable<SqlNode>ifSqlNodes/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/ChooseSqlNode.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltagsdefaultSqlNodesqlNode/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/DynamicContext.javauniqueNumber/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/DynamicContext.classsqlBuilderbindings"_parameter"_parameter"_databaseId"_databaseIdClass<ContextMap>existsTypeHandlerfallbackParameterObject/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/DynamicContext$ContextMap.classparameterMetaObject2977601501966151582L2977601501966151582strKeyContextAccessorContextAccessor()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/DynamicContext$ContextAccessor.class issue #61 do not modify the context when reading/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/DynamicSqlSource.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/DynamicSqlSource.classBiConsumer<String,Object>BiConsumer<? super T,? super U>andThen(java.util.function.BiConsumer)accept(java.lang.Object,java.lang.Object)accept(java.lang.String,java.lang.Object)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/ExpressionEvaluator.javanullable"The expression '"The expression '"' evaluated to a null value."' evaluated to a null value."Error evaluating expression '"Error evaluating expression '"'.  Return value ("'.  Return value (") was not iterable.") was not iterable.Since 3.5.9, use the {@link #evaluateIterable(String, Object, boolean)}.3.5.9 the array may be primitive, so Arrays.asList() may throw a ClassCastException (issue 209). Do the work manually Curse primitives! :) (JGB)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/ForEachSqlNode.javaitemizeItemitemizeItem(java.lang.String,int)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/ForEachSqlNode.classapplyCloseapplyClose(org.apache.ibatis.scripting.xmltags.DynamicContext)applyOpenapplyOpen(org.apache.ibatis.scripting.xmltags.DynamicContext)applyItemapplyItem(org.apache.ibatis.scripting.xmltags.DynamicContext,java.lang.Object,int)applyIndexapplyIndex(org.apache.ibatis.scripting.xmltags.DynamicContext,java.lang.Object,int)itemseparatorcontentscollectionExpressionevaluator"__frch_"__frch_Optional<Boolean>? extends BooleanSupplier<? extends Boolean>Stream<Boolean>BaseStream<Boolean,Stream<Boolean>>Optional<? extends Boolean>? extends Optional<? extends Boolean>Supplier<? extends Optional<? extends Boolean>>? super BooleanFunction<? super Boolean,? extends Optional<? extends U>>Consumer<? super Boolean>orElse(java.lang.Boolean)Function<? super Boolean,? extends U>Predicate<? super Boolean>Supplier<Boolean>oldContextmapEntry/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/ForEachSqlNode$FilteredDynamicContext.classitemIndexhandleTokenhandleToken(java.lang.String)newContent"^\\s*"^\s*"(?![^.,:\\s])"(?![^.,:\s])prefixApplied/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/ForEachSqlNode$PrefixedContext.classSince 3.5.9, use the{@link #ForEachSqlNode(Configuration, SqlNode, String, Boolean, String, String, String, String, String)}. Issue #709/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/IfSqlNode.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/IfSqlNode.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/MixedSqlNode.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/MixedSqlNode.class? super SqlNodeConsumer<? super SqlNode>Spliterator<SqlNode>Iterator<SqlNode>Consumer<SqlNode>accept(org.apache.ibatis.scripting.xmltags.SqlNode)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/OgnlCache.javaparseExpressionparseExpression(java.lang.String)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/OgnlCache.classOgnlCacheOgnlCache()expressionCacheCLASS_RESOLVERMEMBER_ACCESSConcurrentHashMap<String,Object>ConcurrentMap<String,Object>ConcurrentHashMap<String,Object>()ToIntFunction<Entry<String,Object>>ToLongFunction<Entry<String,Object>>ToDoubleFunction<Entry<String,Object>>Function<Entry<String,Object>,? extends U>? extends Entry<String,Object>BiFunction<Entry<String,Object>,Entry<String,Object>,? extends Entry<String,Object>>? super Entry<String,Object>Consumer<? super Entry<String,Object>>ToIntBiFunction<? super String,? super Object>ToLongBiFunction<? super String,? super Object>ToDoubleBiFunction<? super String,? super Object>BiFunction<? super String,? super Object,? extends U>KeySetView<String,Object>CollectionView<String,Object,String>ConcurrentHashMap<String,Object>(int,float,int)ConcurrentHashMap<String,Object>(int,float)ConcurrentHashMap<String,Object>(java.util.Map)ConcurrentHashMap<String,Object>(int)Caches OGNL parsed expressions.<a href='https://github.com/mybatis/old-google-code-issues/issues/342'>Issue 342</a>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/OgnlClassResolver.javaCustom ognl {@code ClassResolver} which behaves same like ognl's {@code DefaultClassResolver}. But uses the{@code Resources} utility class to find the target class instead of {@code Class#forName(String)}.Daniel Guggi<a href='https://github.com/mybatis/mybatis-3/issues/161'>Issue 161</a>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/OgnlMemberAccess.javaOgnlMemberAccessOgnlMemberAccess()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/OgnlMemberAccess.classcanControlMemberAccessiblememberaccessibleThe {@link MemberAccess} class that based on <a href='https://github.com/jkuhnert/ognl/blob/OGNL_3_2_1/src/java/ognl/DefaultMemberAccess.java'>DefaultMemberAccess</a>.<a href='https://github.com/jkuhnert/ognl/blob/OGNL_3_2_1/src/java/ognl/DefaultMemberAccess.java'>DefaultMemberAccess</a><a href='https://github.com/jkuhnert/ognl/issues/47'>#47 of ognl</a> Flipping accessible flag is not thread safe. See #1648/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/SetSqlNode.javaCOMMA/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/SetSqlNode.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/SqlNode.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/StaticTextSqlNode.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/StaticTextSqlNode.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/TextSqlNode.javacreateParsercreateParser(org.apache.ibatis.parsing.TokenHandler)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/TextSqlNode.classinjectionFiltercheckercheckInjectioncheckInjection(java.lang.String)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/TextSqlNode$BindingTokenParser.classsrtValue"Invalid input. Please conform to regex"Invalid input. Please conform to regexisDynamic/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/TextSqlNode$DynamicCheckerTokenParser.class issue #274 return "" instead of "null"/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/TrimSqlNode.javaparseOverridesparseOverrides(java.lang.String)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/TrimSqlNode.classsuffixesToOverrideprefixesToOverridefilteredDynamicContextoverrides"|"|applySuffixapplySuffix(java.lang.StringBuilder,java.lang.String)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/TrimSqlNode$FilteredDynamicContext.classapplyPrefixapplyPrefix(java.lang.StringBuilder,java.lang.String)sqlBuffersuffixAppliedtrimmedUppercaseSqlPredicate<String>test(java.lang.String)toRemove/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/VarDeclSqlNode.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/VarDeclSqlNode.classexp/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/WhereSqlNode.javaprefixList/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/WhereSqlNode.class"AND "AND "OR "OR "AND\n"AND
"OR\n"OR
"AND\r"AND"OR\r"OR"AND\t"AND	"OR\t"OR	/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/XMLLanguageDriver.javatextSqlNode"<script>"<script>"/script"/script issue #3 issue #127/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/XMLScriptBuilder.javainitNodeHandlerMapinitNodeHandlerMap()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/XMLScriptBuilder.classMap<String,NodeHandler>nodeHandlerMapHashMap<String,NodeHandler>AbstractMap<String,NodeHandler>HashMap<String,NodeHandler>()? super NodeHandler? extends NodeHandlerBiFunction<? super NodeHandler,? super NodeHandler,? extends NodeHandler>merge(java.lang.String,org.apache.ibatis.scripting.xmltags.XMLScriptBuilder.NodeHandler,java.util.function.BiFunction)BiFunction<? super String,? super NodeHandler,? extends NodeHandler>Function<? super String,? extends NodeHandler>replace(java.lang.String,org.apache.ibatis.scripting.xmltags.XMLScriptBuilder.NodeHandler)replace(java.lang.String,org.apache.ibatis.scripting.xmltags.XMLScriptBuilder.NodeHandler,org.apache.ibatis.scripting.xmltags.XMLScriptBuilder.NodeHandler)putIfAbsent(java.lang.String,org.apache.ibatis.scripting.xmltags.XMLScriptBuilder.NodeHandler)BiConsumer<? super String,? super NodeHandler>getOrDefault(java.lang.Object,org.apache.ibatis.scripting.xmltags.XMLScriptBuilder.NodeHandler)Entry<String,NodeHandler>Set<Entry<String,NodeHandler>>Collection<Entry<String,NodeHandler>>Iterable<Entry<String,NodeHandler>>Collection<NodeHandler>Iterable<NodeHandler>Map<? extends String,? extends NodeHandler>put(java.lang.String,org.apache.ibatis.scripting.xmltags.XMLScriptBuilder.NodeHandler)AbstractMap<String,NodeHandler>()HashMap<String,NodeHandler>(java.util.Map)HashMap<String,NodeHandler>(int)HashMap<String,NodeHandler>(int,float)"trim"trim"where""foreach"foreach"if"if"choose"choose"when"when"otherwise"otherwise"bind"bindArrayList<SqlNode>AbstractList<SqlNode>AbstractCollection<SqlNode>ArrayList<SqlNode>()Stream<SqlNode>BaseStream<SqlNode,Stream<SqlNode>>Predicate<? super SqlNode>? extends SqlNodeCollection<? extends SqlNode>Iterable<? extends SqlNode>add(org.apache.ibatis.scripting.xmltags.SqlNode)AbstractCollection<SqlNode>()ListIterator<SqlNode>add(int,org.apache.ibatis.scripting.xmltags.SqlNode)set(int,org.apache.ibatis.scripting.xmltags.SqlNode)Comparator<? super SqlNode>UnaryOperator<SqlNode>Function<SqlNode,SqlNode>AbstractList<SqlNode>()ArrayList<SqlNode>(java.util.Collection)ArrayList<SqlNode>(int)"Unknown element <"Unknown element <"> in SQL statement."> in SQL statement.targetContentsmixedSqlNode"prefix"prefixOverrides"prefixOverrides""suffix"suffixOverrides"suffixOverrides""nullable""item""index""open""separator"forEachSqlNode"test"ifSqlNodegetDefaultSqlNodegetDefaultSqlNode(java.util.List)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/scripting/xmltags/XMLScriptBuilder$ChooseHandler.classhandleWhenOtherwiseNodeshandleWhenOtherwiseNodes(org.apache.ibatis.parsing.XNode,java.util.List,java.util.List)whenSqlNodesotherwiseSqlNodeschooseSqlNodedefaultSqlNodes"Too many default (otherwise) elements in choose statement."Too many default (otherwise) elements in choose statement. issue #628/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/scripting/xmltags/package-info.javaDefault XML MyBatis language./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/AutoMappingBehavior.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/sessionAutoMappingBehaviorAutoMappingBehavior()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/AutoMappingBehavior.classSpecifies if and how MyBatis should automatically map columns to fields/properties.Disables auto-mapping.Will only auto-map results with no nested result mappings defined inside.Will auto-map result mappings of any complexity (containing nested or otherwise)./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/AutoMappingUnknownColumnBehavior.javabuildMessagebuildMessage(org.apache.ibatis.mapping.MappedStatement,java.lang.String,java.lang.String,java.lang.Class)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/AutoMappingUnknownColumnBehavior.classAutoMappingUnknownColumnBehaviorAutoMappingUnknownColumnBehavior()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/AutoMappingUnknownColumnBehavior$1.classdoActiondoAction(org.apache.ibatis.mapping.MappedStatement,java.lang.String,java.lang.String,java.lang.Class)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/AutoMappingUnknownColumnBehavior$2.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/AutoMappingUnknownColumnBehavior$3.class"Unknown column is detected on '"Unknown column is detected on '"' auto-mapping. Mapping parameters are "' auto-mapping. Mapping parameters are "columnName="columnName="propertyName="propertyName="propertyType="propertyType=/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/AutoMappingUnknownColumnBehavior$LogHolder.classClass<AutoMappingUnknownColumnBehavior>Specify the behavior when detects an unknown column (or unknown property type) of automatic mapping target.Do nothing (Default).Output warning log. Note: The log level of {@code 'org.apache.ibatis.session.AutoMappingUnknownColumnBehavior'}must be set to {@code WARN}.Fail mapping. Note: throw {@link SqlSessionException}.Perform the action when detects an unknown column (or unknown property type) of automatic mapping target.current mapped statementcolumn name for mapping targetproperty name for mapping targetproperty type for mapping target (If this argument is not null, {@link org.apache.ibatis.type.TypeHandler}for property type is not registered)build error message./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/Configuration.javaincompleteMethodsLock/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/Configuration.classincompleteStatementsLockincompleteCacheRefsLockincompleteResultMapsLock"equals""clone""hashCode""toString"Map<String,MappedStatement>StrictMap<MappedStatement>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/Configuration$StrictMap.classConcurrentHashMap<String,MappedStatement>AbstractMap<String,MappedStatement>ConcurrentMap<String,MappedStatement>BiFunction<MappedStatement,MappedStatement,String>ConcurrentHashMap<>ConcurrentMap<>BiFunction<V,V,String>conflictMessageProducerconflictMessageProducer(java.util.function.BiFunction)? super MappedStatement? extends MappedStatementBiFunction<? super MappedStatement,? super MappedStatement,? extends MappedStatement>merge(java.lang.String,org.apache.ibatis.mapping.MappedStatement,java.util.function.BiFunction)BiFunction<? super String,? super MappedStatement,? extends MappedStatement>Function<? super String,? extends MappedStatement>replace(java.lang.String,org.apache.ibatis.mapping.MappedStatement)replace(java.lang.String,org.apache.ibatis.mapping.MappedStatement,org.apache.ibatis.mapping.MappedStatement)putIfAbsent(java.lang.String,org.apache.ibatis.mapping.MappedStatement)BiConsumer<? super String,? super MappedStatement>getOrDefault(java.lang.Object,org.apache.ibatis.mapping.MappedStatement)Entry<String,MappedStatement>Set<Entry<String,MappedStatement>>Collection<Entry<String,MappedStatement>>Iterable<Entry<String,MappedStatement>>Collection<MappedStatement>Iterable<MappedStatement>Map<? extends String,? extends MappedStatement>put(java.lang.String,org.apache.ibatis.mapping.MappedStatement)AbstractMap<String,MappedStatement>()ToIntFunction<Entry<String,MappedStatement>>ToLongFunction<Entry<String,MappedStatement>>ToDoubleFunction<Entry<String,MappedStatement>>Function<Entry<String,MappedStatement>,? extends U>? extends Entry<String,MappedStatement>BiFunction<Entry<String,MappedStatement>,Entry<String,MappedStatement>,? extends Entry<String,MappedStatement>>? super Entry<String,MappedStatement>Consumer<? super Entry<String,MappedStatement>>ToIntFunction<? super MappedStatement>ToLongFunction<? super MappedStatement>ToDoubleFunction<? super MappedStatement>Function<? super MappedStatement,? extends U>Consumer<? super MappedStatement>ToIntBiFunction<? super String,? super MappedStatement>ToLongBiFunction<? super String,? super MappedStatement>ToDoubleBiFunction<? super String,? super MappedStatement>BiFunction<? super String,? super MappedStatement,? extends U>KeySetView<String,MappedStatement>CollectionView<String,MappedStatement,String>keySet(org.apache.ibatis.mapping.MappedStatement)Enumeration<MappedStatement>ConcurrentHashMap<String,MappedStatement>(int,float,int)ConcurrentHashMap<String,MappedStatement>(int,float)ConcurrentHashMap<String,MappedStatement>(java.util.Map)ConcurrentHashMap<String,MappedStatement>(int)ConcurrentHashMap<String,MappedStatement>()Map<String,? extends V>StrictMapStrictMap(java.lang.String,java.util.Map)Map<String,? extends MappedStatement>StrictMap<MappedStatement>(java.lang.String,java.util.Map)StrictMap(java.lang.String)StrictMap<MappedStatement>(java.lang.String)StrictMap(java.lang.String,int)StrictMap<MappedStatement>(java.lang.String,int)StrictMap(java.lang.String,int,float)StrictMap<MappedStatement>(java.lang.String,int,float)"Mapped Statements collection"Mapped Statements collectionBiFunction<MappedStatement,MappedStatement,V>apply(org.apache.ibatis.mapping.MappedStatement,org.apache.ibatis.mapping.MappedStatement)savedValuetargetValue". please check ". please check " and " and Map<String,Cache>StrictMap<Cache>ConcurrentHashMap<String,Cache>AbstractMap<String,Cache>ConcurrentMap<String,Cache>StrictMap<Cache>(java.lang.String)BiFunction<? super Cache,? super Cache,? extends Cache>merge(java.lang.String,org.apache.ibatis.cache.Cache,java.util.function.BiFunction)BiFunction<? super String,? super Cache,? extends Cache>Function<? super String,? extends Cache>replace(java.lang.String,org.apache.ibatis.cache.Cache)replace(java.lang.String,org.apache.ibatis.cache.Cache,org.apache.ibatis.cache.Cache)putIfAbsent(java.lang.String,org.apache.ibatis.cache.Cache)BiConsumer<? super String,? super Cache>getOrDefault(java.lang.Object,org.apache.ibatis.cache.Cache)Entry<String,Cache>Set<Entry<String,Cache>>Collection<Entry<String,Cache>>Iterable<Entry<String,Cache>>Map<? extends String,? extends Cache>put(java.lang.String,org.apache.ibatis.cache.Cache)AbstractMap<String,Cache>()ToIntFunction<Entry<String,Cache>>ToLongFunction<Entry<String,Cache>>ToDoubleFunction<Entry<String,Cache>>Function<Entry<String,Cache>,? extends U>? extends Entry<String,Cache>BiFunction<Entry<String,Cache>,Entry<String,Cache>,? extends Entry<String,Cache>>? super Entry<String,Cache>Consumer<? super Entry<String,Cache>>ToIntFunction<? super Cache>ToLongFunction<? super Cache>ToDoubleFunction<? super Cache>Function<? super Cache,? extends U>Consumer<? super Cache>ToIntBiFunction<? super String,? super Cache>ToLongBiFunction<? super String,? super Cache>ToDoubleBiFunction<? super String,? super Cache>BiFunction<? super String,? super Cache,? extends U>KeySetView<String,Cache>CollectionView<String,Cache,String>keySet(org.apache.ibatis.cache.Cache)Enumeration<Cache>ConcurrentHashMap<String,Cache>(int,float,int)ConcurrentHashMap<String,Cache>(int,float)ConcurrentHashMap<String,Cache>(java.util.Map)ConcurrentHashMap<String,Cache>(int)ConcurrentHashMap<String,Cache>()BiFunction<Cache,Cache,String>Map<String,? extends Cache>StrictMap<Cache>(java.lang.String,java.util.Map)StrictMap<Cache>(java.lang.String,int)StrictMap<Cache>(java.lang.String,int,float)"Caches collection"Caches collectionMap<String,ResultMap>StrictMap<ResultMap>ConcurrentHashMap<String,ResultMap>AbstractMap<String,ResultMap>ConcurrentMap<String,ResultMap>StrictMap<ResultMap>(java.lang.String)BiFunction<? super ResultMap,? super ResultMap,? extends ResultMap>merge(java.lang.String,org.apache.ibatis.mapping.ResultMap,java.util.function.BiFunction)BiFunction<? super String,? super ResultMap,? extends ResultMap>Function<? super String,? extends ResultMap>replace(java.lang.String,org.apache.ibatis.mapping.ResultMap)replace(java.lang.String,org.apache.ibatis.mapping.ResultMap,org.apache.ibatis.mapping.ResultMap)putIfAbsent(java.lang.String,org.apache.ibatis.mapping.ResultMap)BiConsumer<? super String,? super ResultMap>getOrDefault(java.lang.Object,org.apache.ibatis.mapping.ResultMap)Entry<String,ResultMap>Set<Entry<String,ResultMap>>Collection<Entry<String,ResultMap>>Iterable<Entry<String,ResultMap>>Map<? extends String,? extends ResultMap>put(java.lang.String,org.apache.ibatis.mapping.ResultMap)AbstractMap<String,ResultMap>()ToIntFunction<Entry<String,ResultMap>>ToLongFunction<Entry<String,ResultMap>>ToDoubleFunction<Entry<String,ResultMap>>Function<Entry<String,ResultMap>,? extends U>? extends Entry<String,ResultMap>BiFunction<Entry<String,ResultMap>,Entry<String,ResultMap>,? extends Entry<String,ResultMap>>? super Entry<String,ResultMap>Consumer<? super Entry<String,ResultMap>>ToIntFunction<? super ResultMap>ToLongFunction<? super ResultMap>ToDoubleFunction<? super ResultMap>Function<? super ResultMap,? extends U>ToIntBiFunction<? super String,? super ResultMap>ToLongBiFunction<? super String,? super ResultMap>ToDoubleBiFunction<? super String,? super ResultMap>BiFunction<? super String,? super ResultMap,? extends U>KeySetView<String,ResultMap>CollectionView<String,ResultMap,String>keySet(org.apache.ibatis.mapping.ResultMap)Enumeration<ResultMap>ConcurrentHashMap<String,ResultMap>(int,float,int)ConcurrentHashMap<String,ResultMap>(int,float)ConcurrentHashMap<String,ResultMap>(java.util.Map)ConcurrentHashMap<String,ResultMap>(int)ConcurrentHashMap<String,ResultMap>()BiFunction<ResultMap,ResultMap,String>Map<String,? extends ResultMap>StrictMap<ResultMap>(java.lang.String,java.util.Map)StrictMap<ResultMap>(java.lang.String,int)StrictMap<ResultMap>(java.lang.String,int,float)"Result Maps collection"Result Maps collectionMap<String,ParameterMap>StrictMap<ParameterMap>ConcurrentHashMap<String,ParameterMap>AbstractMap<String,ParameterMap>ConcurrentMap<String,ParameterMap>StrictMap<ParameterMap>(java.lang.String)? super ParameterMap? extends ParameterMapBiFunction<? super ParameterMap,? super ParameterMap,? extends ParameterMap>merge(java.lang.String,org.apache.ibatis.mapping.ParameterMap,java.util.function.BiFunction)BiFunction<? super String,? super ParameterMap,? extends ParameterMap>Function<? super String,? extends ParameterMap>replace(java.lang.String,org.apache.ibatis.mapping.ParameterMap)replace(java.lang.String,org.apache.ibatis.mapping.ParameterMap,org.apache.ibatis.mapping.ParameterMap)putIfAbsent(java.lang.String,org.apache.ibatis.mapping.ParameterMap)BiConsumer<? super String,? super ParameterMap>getOrDefault(java.lang.Object,org.apache.ibatis.mapping.ParameterMap)Entry<String,ParameterMap>Set<Entry<String,ParameterMap>>Collection<Entry<String,ParameterMap>>Iterable<Entry<String,ParameterMap>>Collection<ParameterMap>Iterable<ParameterMap>Map<? extends String,? extends ParameterMap>put(java.lang.String,org.apache.ibatis.mapping.ParameterMap)AbstractMap<String,ParameterMap>()ToIntFunction<Entry<String,ParameterMap>>ToLongFunction<Entry<String,ParameterMap>>ToDoubleFunction<Entry<String,ParameterMap>>Function<Entry<String,ParameterMap>,? extends U>? extends Entry<String,ParameterMap>BiFunction<Entry<String,ParameterMap>,Entry<String,ParameterMap>,? extends Entry<String,ParameterMap>>? super Entry<String,ParameterMap>Consumer<? super Entry<String,ParameterMap>>ToIntFunction<? super ParameterMap>ToLongFunction<? super ParameterMap>ToDoubleFunction<? super ParameterMap>Function<? super ParameterMap,? extends U>Consumer<? super ParameterMap>ToIntBiFunction<? super String,? super ParameterMap>ToLongBiFunction<? super String,? super ParameterMap>ToDoubleBiFunction<? super String,? super ParameterMap>BiFunction<? super String,? super ParameterMap,? extends U>KeySetView<String,ParameterMap>CollectionView<String,ParameterMap,String>keySet(org.apache.ibatis.mapping.ParameterMap)Enumeration<ParameterMap>ConcurrentHashMap<String,ParameterMap>(int,float,int)ConcurrentHashMap<String,ParameterMap>(int,float)ConcurrentHashMap<String,ParameterMap>(java.util.Map)ConcurrentHashMap<String,ParameterMap>(int)ConcurrentHashMap<String,ParameterMap>()BiFunction<ParameterMap,ParameterMap,String>Map<String,? extends ParameterMap>StrictMap<ParameterMap>(java.lang.String,java.util.Map)StrictMap<ParameterMap>(java.lang.String,int)StrictMap<ParameterMap>(java.lang.String,int,float)"Parameter Maps collection"Parameter Maps collectionMap<String,KeyGenerator>StrictMap<KeyGenerator>ConcurrentHashMap<String,KeyGenerator>AbstractMap<String,KeyGenerator>ConcurrentMap<String,KeyGenerator>StrictMap<KeyGenerator>(java.lang.String)? super KeyGeneratorBiFunction<? super KeyGenerator,? super KeyGenerator,? extends KeyGenerator>merge(java.lang.String,org.apache.ibatis.executor.keygen.KeyGenerator,java.util.function.BiFunction)BiFunction<? super String,? super KeyGenerator,? extends KeyGenerator>Function<? super String,? extends KeyGenerator>replace(java.lang.String,org.apache.ibatis.executor.keygen.KeyGenerator)replace(java.lang.String,org.apache.ibatis.executor.keygen.KeyGenerator,org.apache.ibatis.executor.keygen.KeyGenerator)putIfAbsent(java.lang.String,org.apache.ibatis.executor.keygen.KeyGenerator)BiConsumer<? super String,? super KeyGenerator>getOrDefault(java.lang.Object,org.apache.ibatis.executor.keygen.KeyGenerator)Entry<String,KeyGenerator>Set<Entry<String,KeyGenerator>>Collection<Entry<String,KeyGenerator>>Iterable<Entry<String,KeyGenerator>>Collection<KeyGenerator>Iterable<KeyGenerator>Map<? extends String,? extends KeyGenerator>put(java.lang.String,org.apache.ibatis.executor.keygen.KeyGenerator)AbstractMap<String,KeyGenerator>()ToIntFunction<Entry<String,KeyGenerator>>ToLongFunction<Entry<String,KeyGenerator>>ToDoubleFunction<Entry<String,KeyGenerator>>Function<Entry<String,KeyGenerator>,? extends U>? extends Entry<String,KeyGenerator>BiFunction<Entry<String,KeyGenerator>,Entry<String,KeyGenerator>,? extends Entry<String,KeyGenerator>>? super Entry<String,KeyGenerator>Consumer<? super Entry<String,KeyGenerator>>ToIntFunction<? super KeyGenerator>ToLongFunction<? super KeyGenerator>ToDoubleFunction<? super KeyGenerator>Function<? super KeyGenerator,? extends U>Consumer<? super KeyGenerator>ToIntBiFunction<? super String,? super KeyGenerator>ToLongBiFunction<? super String,? super KeyGenerator>ToDoubleBiFunction<? super String,? super KeyGenerator>BiFunction<? super String,? super KeyGenerator,? extends U>KeySetView<String,KeyGenerator>CollectionView<String,KeyGenerator,String>keySet(org.apache.ibatis.executor.keygen.KeyGenerator)Enumeration<KeyGenerator>ConcurrentHashMap<String,KeyGenerator>(int,float,int)ConcurrentHashMap<String,KeyGenerator>(int,float)ConcurrentHashMap<String,KeyGenerator>(java.util.Map)ConcurrentHashMap<String,KeyGenerator>(int)ConcurrentHashMap<String,KeyGenerator>()BiFunction<KeyGenerator,KeyGenerator,String>Map<String,? extends KeyGenerator>StrictMap<KeyGenerator>(java.lang.String,java.util.Map)StrictMap<KeyGenerator>(java.lang.String,int)StrictMap<KeyGenerator>(java.lang.String,int,float)"Key Generators collection"Key Generators collectionStrictMap<XNode>ConcurrentHashMap<String,XNode>AbstractMap<String,XNode>ConcurrentMap<String,XNode>StrictMap<XNode>(java.lang.String)AbstractMap<String,XNode>()ToIntFunction<Entry<String,XNode>>ToLongFunction<Entry<String,XNode>>ToDoubleFunction<Entry<String,XNode>>Function<Entry<String,XNode>,? extends U>? extends Entry<String,XNode>BiFunction<Entry<String,XNode>,Entry<String,XNode>,? extends Entry<String,XNode>>? super Entry<String,XNode>Consumer<? super Entry<String,XNode>>ToIntFunction<? super XNode>ToLongFunction<? super XNode>ToDoubleFunction<? super XNode>Function<? super XNode,? extends U>ToIntBiFunction<? super String,? super XNode>ToLongBiFunction<? super String,? super XNode>ToDoubleBiFunction<? super String,? super XNode>BiFunction<? super String,? super XNode,? extends U>KeySetView<String,XNode>CollectionView<String,XNode,String>keySet(org.apache.ibatis.parsing.XNode)Enumeration<XNode>ConcurrentHashMap<String,XNode>(int,float,int)ConcurrentHashMap<String,XNode>(int,float)ConcurrentHashMap<String,XNode>(java.util.Map)ConcurrentHashMap<String,XNode>(int)ConcurrentHashMap<String,XNode>()BiFunction<XNode,XNode,String>Map<String,? extends XNode>StrictMap<XNode>(java.lang.String,java.util.Map)StrictMap<XNode>(java.lang.String,int)StrictMap<XNode>(java.lang.String,int,float)"XML fragments parsed from previous mappers"XML fragments parsed from previous mappersCollection<XMLStatementBuilder>Iterable<XMLStatementBuilder>LinkedList<XMLStatementBuilder>AbstractSequentialList<XMLStatementBuilder>AbstractList<XMLStatementBuilder>AbstractCollection<XMLStatementBuilder>List<XMLStatementBuilder>Deque<XMLStatementBuilder>Queue<XMLStatementBuilder>LinkedList<XMLStatementBuilder>()Spliterator<XMLStatementBuilder>? super XMLStatementBuilderConsumer<? super XMLStatementBuilder>Iterator<XMLStatementBuilder>Stream<XMLStatementBuilder>BaseStream<XMLStatementBuilder,Stream<XMLStatementBuilder>>Predicate<? super XMLStatementBuilder>? extends XMLStatementBuilderCollection<? extends XMLStatementBuilder>Iterable<? extends XMLStatementBuilder>add(org.apache.ibatis.builder.xml.XMLStatementBuilder)AbstractCollection<XMLStatementBuilder>()ListIterator<XMLStatementBuilder>add(int,org.apache.ibatis.builder.xml.XMLStatementBuilder)set(int,org.apache.ibatis.builder.xml.XMLStatementBuilder)Comparator<? super XMLStatementBuilder>UnaryOperator<XMLStatementBuilder>Function<XMLStatementBuilder,XMLStatementBuilder>AbstractList<XMLStatementBuilder>()AbstractSequentialList<XMLStatementBuilder>()offer(org.apache.ibatis.builder.xml.XMLStatementBuilder)push(org.apache.ibatis.builder.xml.XMLStatementBuilder)offerLast(org.apache.ibatis.builder.xml.XMLStatementBuilder)offerFirst(org.apache.ibatis.builder.xml.XMLStatementBuilder)addLast(org.apache.ibatis.builder.xml.XMLStatementBuilder)addFirst(org.apache.ibatis.builder.xml.XMLStatementBuilder)LinkedList<XMLStatementBuilder>(java.util.Collection)Collection<CacheRefResolver>Iterable<CacheRefResolver>LinkedList<CacheRefResolver>AbstractSequentialList<CacheRefResolver>AbstractList<CacheRefResolver>AbstractCollection<CacheRefResolver>List<CacheRefResolver>Deque<CacheRefResolver>Queue<CacheRefResolver>LinkedList<CacheRefResolver>()Spliterator<CacheRefResolver>? super CacheRefResolverConsumer<? super CacheRefResolver>Iterator<CacheRefResolver>Stream<CacheRefResolver>BaseStream<CacheRefResolver,Stream<CacheRefResolver>>Predicate<? super CacheRefResolver>? extends CacheRefResolverCollection<? extends CacheRefResolver>Iterable<? extends CacheRefResolver>add(org.apache.ibatis.builder.CacheRefResolver)AbstractCollection<CacheRefResolver>()ListIterator<CacheRefResolver>add(int,org.apache.ibatis.builder.CacheRefResolver)set(int,org.apache.ibatis.builder.CacheRefResolver)Comparator<? super CacheRefResolver>UnaryOperator<CacheRefResolver>Function<CacheRefResolver,CacheRefResolver>AbstractList<CacheRefResolver>()AbstractSequentialList<CacheRefResolver>()offer(org.apache.ibatis.builder.CacheRefResolver)push(org.apache.ibatis.builder.CacheRefResolver)offerLast(org.apache.ibatis.builder.CacheRefResolver)offerFirst(org.apache.ibatis.builder.CacheRefResolver)addLast(org.apache.ibatis.builder.CacheRefResolver)addFirst(org.apache.ibatis.builder.CacheRefResolver)LinkedList<CacheRefResolver>(java.util.Collection)Collection<ResultMapResolver>Iterable<ResultMapResolver>LinkedList<ResultMapResolver>AbstractSequentialList<ResultMapResolver>AbstractList<ResultMapResolver>AbstractCollection<ResultMapResolver>List<ResultMapResolver>Deque<ResultMapResolver>Queue<ResultMapResolver>LinkedList<ResultMapResolver>()Spliterator<ResultMapResolver>? super ResultMapResolverConsumer<? super ResultMapResolver>Iterator<ResultMapResolver>Stream<ResultMapResolver>BaseStream<ResultMapResolver,Stream<ResultMapResolver>>Predicate<? super ResultMapResolver>? extends ResultMapResolverCollection<? extends ResultMapResolver>Iterable<? extends ResultMapResolver>add(org.apache.ibatis.builder.ResultMapResolver)AbstractCollection<ResultMapResolver>()ListIterator<ResultMapResolver>add(int,org.apache.ibatis.builder.ResultMapResolver)set(int,org.apache.ibatis.builder.ResultMapResolver)Comparator<? super ResultMapResolver>UnaryOperator<ResultMapResolver>Function<ResultMapResolver,ResultMapResolver>AbstractList<ResultMapResolver>()AbstractSequentialList<ResultMapResolver>()offer(org.apache.ibatis.builder.ResultMapResolver)push(org.apache.ibatis.builder.ResultMapResolver)offerLast(org.apache.ibatis.builder.ResultMapResolver)offerFirst(org.apache.ibatis.builder.ResultMapResolver)addLast(org.apache.ibatis.builder.ResultMapResolver)addFirst(org.apache.ibatis.builder.ResultMapResolver)LinkedList<ResultMapResolver>(java.util.Collection)Collection<MethodResolver>Iterable<MethodResolver>LinkedList<MethodResolver>AbstractSequentialList<MethodResolver>AbstractList<MethodResolver>AbstractCollection<MethodResolver>List<MethodResolver>Deque<MethodResolver>Queue<MethodResolver>LinkedList<MethodResolver>()Spliterator<MethodResolver>? super MethodResolverConsumer<? super MethodResolver>Iterator<MethodResolver>Stream<MethodResolver>BaseStream<MethodResolver,Stream<MethodResolver>>Predicate<? super MethodResolver>? extends MethodResolverCollection<? extends MethodResolver>Iterable<? extends MethodResolver>add(org.apache.ibatis.builder.annotation.MethodResolver)AbstractCollection<MethodResolver>()ListIterator<MethodResolver>add(int,org.apache.ibatis.builder.annotation.MethodResolver)set(int,org.apache.ibatis.builder.annotation.MethodResolver)Comparator<? super MethodResolver>UnaryOperator<MethodResolver>Function<MethodResolver,MethodResolver>AbstractList<MethodResolver>()AbstractSequentialList<MethodResolver>()offer(org.apache.ibatis.builder.annotation.MethodResolver)push(org.apache.ibatis.builder.annotation.MethodResolver)offerLast(org.apache.ibatis.builder.annotation.MethodResolver)offerFirst(org.apache.ibatis.builder.annotation.MethodResolver)addLast(org.apache.ibatis.builder.annotation.MethodResolver)addFirst(org.apache.ibatis.builder.annotation.MethodResolver)LinkedList<MethodResolver>(java.util.Collection)Class<JdbcTransactionFactory>"JDBC"JDBCClass<ManagedTransactionFactory>"MANAGED"MANAGEDClass<JndiDataSourceFactory>"JNDI"JNDIClass<PooledDataSourceFactory>"POOLED"POOLEDClass<UnpooledDataSourceFactory>"UNPOOLED"UNPOOLEDClass<FifoCache>"FIFO"FIFOClass<SoftCache>"SOFT"SOFTClass<WeakCache>"WEAK"WEAKClass<VendorDatabaseIdProvider>Class<XMLLanguageDriver>"XML"XMLClass<RawLanguageDriver>"RAW"RAW"SLF4J"SLF4J"COMMONS_LOGGING"COMMONS_LOGGING"LOG4J"LOG4J"LOG4J2"LOG4J2"JDK_LOGGING"JDK_LOGGING"STDOUT_LOGGING"STDOUT_LOGGING"NO_LOGGING"NO_LOGGING"CGLIB"CGLIB"JAVASSIST"JAVASSISTreturnEmptyInstancestatementHandlerexecutorTypeincompleteStatementincompleteCacheRefvalidateIncompleteStatementsstatementNamereferencedNamespacereportUnresolvedPredicate<MethodResolver>test(org.apache.ibatis.builder.annotation.MethodResolver)Predicate<XMLStatementBuilder>test(org.apache.ibatis.builder.xml.XMLStatementBuilder)Predicate<CacheRefResolver>test(org.apache.ibatis.builder.CacheRefResolver)resolvedlastPeriodresultMapObjectentryResultMapdiscriminatedResultMapNamesdiscriminatedResultMapNamegetShortNamegetShortName(java.lang.String)ConcurrentHashMap<String,V>ConcurrentMap<String,V>4950446264854982944L4950446264854982944initialCapacityloadFactor" already contains key " already contains key BiFunction<V,V,V>ToIntFunction<Entry<String,V>>ToLongFunction<Entry<String,V>>ToDoubleFunction<Entry<String,V>>Function<Entry<String,V>,? extends U>? extends Entry<String,V>BiFunction<Entry<String,V>,Entry<String,V>,? extends Entry<String,V>>? super Entry<String,V>Consumer<? super Entry<String,V>>ToIntBiFunction<? super String,? super V>ToLongBiFunction<? super String,? super V>ToDoubleBiFunction<? super String,? super V>BiFunction<? super String,? super V,? extends U>KeySetView<String,V>CollectionView<String,V,String>ConcurrentHashMap<String,V>(int,float,int)ConcurrentHashMap<String,V>(int,float)ConcurrentHashMap<String,V>(java.util.Map)ConcurrentHashMap<String,V>(int)ConcurrentHashMap<String,V>()shortKey" does not contain value for " does not contain value for " is ambiguous in " is ambiguous in " (try using the full name including the namespace, or rename one of the entries)" (try using the full name including the namespace, or rename one of the entries)subject/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/Configuration$StrictMap$Ambiguity.classkeyParts #224 Using internal Javassist instead of OGNLConfiguration factory class. Used to create Configuration for loading deserialized unread properties.<a href='https://github.com/mybatis/old-google-code-issues/issues/300'>Issue 300 (google code)</a>A map holds cache-ref relationship. The key is the namespace that references a cache bound to another namespace andthe value is the namespace which the actual cache is bound to.Gets an applying type when omit a type on sql provider annotation(e.g.{@link org.apache.ibatis.annotations.SelectProvider}).the default type for sql provider annotation3.5.6Sets an applying type when omit a type on sql provider annotation(e.g.Sets the default value of 'nullable' attribute on 'foreach' tag.If nullable, set to {@code true}Returns the default value of 'nullable' attribute on 'foreach' tag.Default is {@code false}.Gets the auto mapping unknown column behavior.the auto mapping unknown column behaviorSets the auto mapping unknown column behavior.the new auto mapping unknown column behaviorGets the default fetch size.the default fetch sizeSets the default fetch size.the new default fetch sizeGets the default result set type.the default result set typeSets the default result set type.the new default result set typeSet a default {@link TypeHandler} class for {@link Enum}. A default {@link TypeHandler} is{@link org.apache.ibatis.type.EnumTypeHandler}.a type handler class for {@link Enum}Gets the mapper registry.the mapper registryGets the interceptors.the interceptorsGets the default scripting language instance.the default scripting language instanceUse {@link #getDefaultScriptingLanguageInstance()}call {@link #parsePendingStatements(boolean)}call {@link #parsePendingCacheRefs(boolean)}call {@link #parsePendingResultMaps(boolean)}call {@link #parsePendingMethods(boolean)}Parses all the unprocessed statement nodes in the cache. It is recommended to call this method once all the mappersare added as it provides fail-fast statement validation. At least one result map is unresolvable.Extracts namespace from fully qualified statement id.namespace or null when id does not contain period. Slow but a one time cost. A better solution is welcome.Assign a function for producing a conflict error message when contains value with the same key.function arguments are 1st is saved value and 2nd is target value.A function for producing a conflict error messagea conflict error message/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/ExecutorType.javaExecutorTypeExecutorType()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/ExecutorType.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/LocalCacheScope.javaLocalCacheScopeLocalCacheScope()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/LocalCacheScope.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/ResultContext.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/ResultHandler.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/RowBounds.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/RowBounds.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/SqlSession.javaforceThe primary Java interface for working with MyBatis. Through this interface you can execute commands, get mappers andmanage transactions.Retrieve a single row mapped from the statement key.the returned object typeMapped objectRetrieve a single row mapped from the statement key and parameter.Unique identifier matching the statement to use.A parameter object to pass to the statement.Retrieve a list of mapped objects from the statement key.the returned list element typeList of mapped objectRetrieve a list of mapped objects from the statement key and parameter.Retrieve a list of mapped objects from the statement key and parameter, within the specified row bounds.Bounds to limit object retrievalThe selectMap is a special case in that it is designed to convert a list of results into a Map based on one of theproperties in the resulting objects. Eg. Return a of Map[Integer,Author] for selectMap("selectAuthors","id")<K>the returned Map keys type<V>the returned Map values typeThe property to use as key for each value in the list.Map containing key pair data.properties in the resulting objects.A Cursor offers the same results as a List, except it fetches data lazily using an Iterator.the returned cursor element type.Cursor of mapped objectsRetrieve a single row mapped from the statement key and parameter using a {@code ResultHandler}.ResultHandler that will handle each retrieved rowRetrieve a single row mapped from the statement using a {@code ResultHandler}.Retrieve a single row mapped from the statement key and parameter using a {@code ResultHandler} and{@code RowBounds}.the parameterRowBound instance to limit the query resultsExecute an insert statement.Unique identifier matching the statement to execute.int The number of rows affected by the insert.Execute an insert statement with the given parameter object. Any generated autoincrement values or selectKeyentries will modify the given parameter object properties. Only the number of rows affected will be returned.Execute an update statement. The number of rows affected will be returned.int The number of rows affected by the update.Execute a delete statement. The number of rows affected will be returned.int The number of rows affected by the delete.Flushes batch statements and commits database connection. Note that database connection will not be committed if noupdates/deletes/inserts were called. To force the commit call {@link SqlSession#commit(boolean)}Flushes batch statements and commits database connection.forces connection commitDiscards pending batch statements and rolls database connection back. Note that database connection will not berolled back if no updates/deletes/inserts were called. To force the rollback call{@link SqlSession#rollback(boolean)}rolled back if no updates/deletes/inserts were called.forces connection rollbackFlushes batch statements.BatchResult list of updated records3.0.6Closes the session.Clears local session cache.Retrieves current configuration.ConfigurationRetrieves a mapper.Mapper interface classa mapper bound to this SqlSessionRetrieves inner database connection.Connection/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/SqlSessionException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/SqlSessionException.class3833184690240265047L3833184690240265047/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/SqlSessionFactory.javaexecTypeCreates an {@link SqlSession} out of a connection or a DataSource/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/SqlSessionFactoryBuilder.java"Error building SqlSession."Error building SqlSession.Builds {@link SqlSession} instances. Intentionally ignore. Prefer previous error./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/SqlSessionManager.javaSqlSessionManagerSqlSessionManager(org.apache.ibatis.session.SqlSessionFactory)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/SqlSessionManager.classThreadLocal<SqlSession>localSqlSessionsqlSessionProxysqlSessionFactoryThreadLocal<SqlSession>()set(org.apache.ibatis.session.SqlSession)Class<SqlSessionFactory>? super SqlSessionFactoryClass<? super SqlSessionFactory>Constructor<SqlSessionFactory>SqlSessionFactory[]TypeVariable<Class<SqlSessionFactory>>TypeVariable<Class<SqlSessionFactory>>[]Class<SqlSession>"Error:  Cannot get connection.  No managed session is started."Error:  Cannot get connection.  No managed session is started."Error:  Cannot clear the cache.  No managed session is started."Error:  Cannot clear the cache.  No managed session is started."Error:  Cannot commit.  No managed session is started."Error:  Cannot commit.  No managed session is started."Error:  Cannot rollback.  No managed session is started."Error:  Cannot rollback.  No managed session is started."Error:  Cannot close.  No managed session is started."Error:  Cannot close.  No managed session is started.autoSqlSessionLarry Meadors/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/TransactionIsolationLevel.javaTransactionIsolationLevelTransactionIsolationLevel(int)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/TransactionIsolationLevel.class0x10004096A non-standard isolation level for Microsoft SQL Server. Defined in the SQL Server JDBC driver{@link com.microsoft.sqlserver.jdbc.ISQLServerConnection}/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/defaults/DefaultSqlSession.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/defaultswrapCollectionwrapCollection(java.lang.Object)isCommitOrRollbackRequiredisCommitOrRollbackRequired(boolean)registerCursorregisterCursor(org.apache.ibatis.cursor.Cursor)closeCursorscloseCursors()selectList(java.lang.String,java.lang.Object,org.apache.ibatis.session.RowBounds,org.apache.ibatis.session.ResultHandler)Cursor<?>List<Cursor<?>>Collection<Cursor<?>>Iterable<Cursor<?>>cursorListdirtyCollection<? extends T>Iterable<? extends T>ListIterator<T>"Expected one result (or null) to be returned by selectOne(), but found: "Expected one result (or null) to be returned by selectOne(), but found: List<? extends V>Collection<? extends V>Iterable<? extends V>List<V>DefaultMapResultHandler<K,V>mapResultHandlerDefaultMapResultHandler<K,V>(java.lang.String,org.apache.ibatis.reflection.factory.ObjectFactory,org.apache.ibatis.reflection.wrapper.ObjectWrapperFactory,org.apache.ibatis.reflection.ReflectorFactory)getMappedResultsgetMappedResults()DefaultMapResultHandlerDefaultMapResultHandler(java.lang.String,org.apache.ibatis.reflection.factory.ObjectFactory,org.apache.ibatis.reflection.wrapper.ObjectWrapperFactory,org.apache.ibatis.reflection.ReflectorFactory)DefaultResultContext<V>ResultContext<V>DefaultResultContext<V>()"Error querying database.  Cause: "Error querying database.  Cause: "Error updating database.  Cause: "Error updating database.  Cause: "Error committing transaction.  Cause: "Error committing transaction.  Cause: "Error rolling back transaction.  Cause: "Error rolling back transaction.  Cause: "Error flushing statements.  Cause: "Error flushing statements.  Cause: Spliterator<Cursor<?>>? super Cursor<?>Consumer<? super Cursor<?>>Iterator<Cursor<?>>Stream<Cursor<?>>BaseStream<Cursor<?>,Stream<Cursor<?>>>Predicate<? super Cursor<?>>? extends Cursor<?>Collection<? extends Cursor<?>>Iterable<? extends Cursor<?>>add(org.apache.ibatis.cursor.Cursor)ListIterator<Cursor<?>>add(int,org.apache.ibatis.cursor.Cursor)set(int,org.apache.ibatis.cursor.Cursor)Comparator<? super Cursor<?>>UnaryOperator<Cursor<?>>Function<Cursor<?>,Cursor<?>>"Error closing cursor.  Cause: "Error closing cursor.  Cause: "Error getting a new connection.  Cause: "Error getting a new connection.  Cause: ArrayList<Cursor<?>>AbstractList<Cursor<?>>AbstractCollection<Cursor<?>>ArrayList<Cursor<?>>()AbstractCollection<Cursor<?>>()AbstractList<Cursor<?>>()ArrayList<Cursor<?>>(java.util.Collection)ArrayList<Cursor<?>>(int)5741767162221585340L5741767162221585340The default implementation for {@link SqlSession}. Note that this class is not Thread-Safe. Popular vote was to return null on 0 results and throw exception on too many.Since 3.5.5/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/defaults/DefaultSqlSessionFactory.javacloseTransactioncloseTransaction(org.apache.ibatis.transaction.Transaction)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/session/defaults/DefaultSqlSessionFactory.classgetTransactionFactoryFromEnvironmentgetTransactionFactoryFromEnvironment(org.apache.ibatis.mapping.Environment)openSessionFromConnectionopenSessionFromConnection(org.apache.ibatis.session.ExecutorType,java.sql.Connection)openSessionFromDataSourceopenSessionFromDataSource(org.apache.ibatis.session.ExecutorType,org.apache.ibatis.session.TransactionIsolationLevel,boolean)"Error opening session.  Cause: "Error opening session.  Cause: ignore may have fetched a connection so lets call close() Failover to true, as most poor drivers or databases won't support transactions/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/defaults/package-info.javaDefault impl for SqlSession./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/session/package-info.javaBase package. Contains the SqlSession./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/transaction/Transaction.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/transactionorg.apache.ibatis.transactionWraps a database connection. Handles the connection lifecycle that comprises: its creation, preparation,commit/rollback and close.Retrieve inner database connection.DataBase connectionthe SQL exceptionCommit inner database connection.Rollback inner database connection.Close inner database connection.Get transaction timeout if set./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/transaction/TransactionException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/transaction/TransactionException.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/transaction433589569461084605L433589569461084605/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/transaction/TransactionFactory.javaCreates {@link Transaction} instances.Sets transaction factory custom properties.the new propertiesCreates a {@link Transaction} out of an existing connection.Existing database connectionTransactionCreates a {@link Transaction} out of a datasource.DataSource to take the connection fromDesired isolation levelDesired autocommit/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/transaction/jdbc/JdbcTransaction.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/transaction/jdbcorg.apache.ibatis.transaction.jdbc/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/transaction/jdbc/JdbcTransaction.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/transaction/jdbcClass<JdbcTransaction>desiredLeveldesiredAutoCommitskipSetAutoCommitOnClose"Committing JDBC Connection ["Committing JDBC Connection ["Rolling back JDBC Connection ["Rolling back JDBC Connection ["Closing JDBC Connection ["Closing JDBC Connection ["Setting autocommit to "Setting autocommit to " on JDBC Connection [" on JDBC Connection ["Error configuring AutoCommit.  " + "Your driver may not support getAutoCommit() or setAutoCommit(). "
              + "Requested setting: "Error configuring AutoCommit.  Your driver may not support getAutoCommit() or setAutoCommit(). Requested setting: "Resetting autocommit to true on JDBC Connection ["Resetting autocommit to true on JDBC Connection ["Error resetting autocommit to true " + "before closing the connection.  Cause: "Error resetting autocommit to true before closing the connection.  Cause: "Opening JDBC Connection"Opening JDBC Connection{@link Transaction} that makes use of the JDBC commit and rollback facilities directly. It relies on the connectionretrieved from the dataSource to manage the scope of the transaction. Delays connection retrieval untilgetConnection() is called. Ignores commit or rollback requests when autocommit is on.JdbcTransactionFactory Only a very poorly implemented driver would fail here, and there's not much we can do about that. MyBatis does not call commit/rollback on a connection if just selects were performed. Some databases start transactions with select statements and they mandate a commit/rollback before closing the connection. A workaround is setting the autocommit to true before closing the connection. Sybase throws an exception here./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/transaction/jdbc/JdbcTransactionFactory.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/transaction/jdbc/JdbcTransactionFactory.class"skipSetAutoCommitOnClose"Creates {@link JdbcTransaction} instances.JdbcTransaction/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/transaction/jdbc/package-info.javaJDBC transaction./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/transaction/managed/ManagedTransaction.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/transaction/managedorg.apache.ibatis.transaction.managedcloseConnection/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/transaction/managed/ManagedTransaction.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/transaction/managedClass<ManagedTransaction>{@link Transaction} that lets the container manage the full lifecycle of the transaction. Delays connection retrievaluntil getConnection() is called. Ignores all commit or rollback requests. By default, it closes the connection butcan be configured not to do it.ManagedTransactionFactory Does nothing/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/transaction/managed/ManagedTransactionFactory.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/transaction/managed/ManagedTransactionFactory.classcloseConnectionProperty"closeConnection"Creates {@link ManagedTransaction} instances.ManagedTransaction Silently ignores autocommit and isolation level, as managed transactions are entirely controlled by an external manager. It's silently ignored so that code remains portable between managed and unmanaged configurations./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/transaction/managed/package-info.javaExternal transaction./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/transaction/package-info.javaBase package for transactions./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/Alias.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/typeThe annotation that specify alias name.&#064;Alias("Email")public class UserEmail {Return the alias name.the alias name/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/ArrayTypeHandler.javaConcurrentHashMap<Class<?>,String>AbstractMap<Class<?>,String>Map<Class<?>,String>ConcurrentMap<Class<?>,String>STANDARD_MAPPING/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/ArrayTypeHandler.classBaseTypeHandler<Object>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/BaseTypeHandler.classTypeReference<Object>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/TypeReference.classConcurrentHashMap<Class<?>,String>()merge(java.lang.Class,java.lang.String,java.util.function.BiFunction)BiFunction<? super Class<?>,? super String,? extends String>Function<? super Class<?>,? extends String>replace(java.lang.Class,java.lang.String)replace(java.lang.Class,java.lang.String,java.lang.String)putIfAbsent(java.lang.Class,java.lang.String)BiConsumer<? super Class<?>,? super String>Entry<Class<?>,String>Set<Entry<Class<?>,String>>Collection<Entry<Class<?>,String>>Iterable<Entry<Class<?>,String>>Map<? extends Class<?>,? extends String>put(java.lang.Class,java.lang.String)AbstractMap<Class<?>,String>()ToIntFunction<Entry<Class<?>,String>>ToLongFunction<Entry<Class<?>,String>>ToDoubleFunction<Entry<Class<?>,String>>Function<Entry<Class<?>,String>,? extends U>? extends Entry<Class<?>,String>BiFunction<Entry<Class<?>,String>,Entry<Class<?>,String>,? extends Entry<Class<?>,String>>? super Entry<Class<?>,String>Consumer<? super Entry<Class<?>,String>>ToIntBiFunction<? super Class<?>,? super String>ToLongBiFunction<? super Class<?>,? super String>ToDoubleBiFunction<? super Class<?>,? super String>BiFunction<? super Class<?>,? super String,? extends U>KeySetView<Class<?>,String>CollectionView<Class<?>,String,Class<?>>keySet(java.lang.String)ConcurrentHashMap<Class<?>,String>(int,float,int)ConcurrentHashMap<Class<?>,String>(int,float)ConcurrentHashMap<Class<?>,String>(java.util.Map)ConcurrentHashMap<Class<?>,String>(int)Class<BigDecimal>Class<BigInteger>Class<byte[]>Class<Calendar>Class<Date>Class<LocalDate>Class<LocalDateTime>Class<LocalTime>Class<OffsetDateTime>Class<OffsetTime>Class<Time>Class<Timestamp>arrayTypeName"ArrayType Handler requires SQL array or java array parameter and does not support type "ArrayType Handler requires SQL array or java array parameter and does not support type columnIndex it's the user's responsibility to properly free() the Array instance/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/BaseTypeHandler.javaTypeReference<T>TypeHandler<T>"JDBC requires that the JdbcType must be specified for all nullable parameters."JDBC requires that the JdbcType must be specified for all nullable parameters."Error setting null for parameter #"Error setting null for parameter #" with JdbcType " with JdbcType " . "
            + "Try setting a different JdbcType for this parameter or a different jdbcTypeForNull configuration property. "
            + "Cause: " . Try setting a different JdbcType for this parameter or a different jdbcTypeForNull configuration property. Cause: "Error setting non null for parameter #"Error setting non null for parameter #" . "
            + "Try setting a different JdbcType for this parameter or a different configuration property. " + "Cause: " . Try setting a different JdbcType for this parameter or a different configuration property. Cause: "Error attempting to get column '"Error attempting to get column '"' from result set.  Cause: "' from result set.  Cause: "Error attempting to get column #"Error attempting to get column #" from result set.  Cause: " from result set.  Cause: " from callable statement.  Cause: " from callable statement.  Cause: The base {@link TypeHandler} for references a generic type.Important: Since 3.5.0, This class never call the {@link ResultSet#wasNull()} and {@link CallableStatement#wasNull()}method for handling the SQL {@code NULL} value. In other words, {@code null} value handling should be performed onsubclass.Simone TripodiKzuki ShimizuSince 3.5.0 - See https://github.com/mybatis/mybatis-3/issues/1203. This field will remove future.Sets the configuration.the new configurationSince 3.5.0 - See https://github.com/mybatis/mybatis-3/issues/1203. This property will remove future.Gets the nullable result.the rsColumn name, when configuration <code>useColumnLabel</code> is <code>false</code>the nullable result/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/BigDecimalTypeHandler.javaBaseTypeHandler<BigDecimal>TypeReference<BigDecimal>TypeHandler<BigDecimal>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/BigIntegerTypeHandler.javaBaseTypeHandler<BigInteger>TypeReference<BigInteger>TypeHandler<BigInteger>bigDecimal/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/BlobByteObjectArrayTypeHandler.javaByte[]getBytesgetBytes(java.sql.Blob)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/BlobByteObjectArrayTypeHandler.classBaseTypeHandler<Byte[]>TypeReference<Byte[]>TypeHandler<Byte[]>blob/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/BlobInputStreamTypeHandler.javatoInputStreamtoInputStream(java.sql.Blob)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/BlobInputStreamTypeHandler.classBaseTypeHandler<InputStream>TypeReference<InputStream>TypeHandler<InputStream>The {@link TypeHandler} for {@link Blob}/{@link InputStream} using method supported at JDBC 4.0.Set an {@link InputStream} into {@link PreparedStatement}.PreparedStatement#setBlob(int, InputStream)Get an {@link InputStream} that corresponds to a specified column name from {@link ResultSet}.ResultSet#getBlob(String)Get an {@link InputStream} that corresponds to a specified column index from {@link ResultSet}.ResultSet#getBlob(int)Get an {@link InputStream} that corresponds to a specified column index from {@link CallableStatement}.CallableStatement#getBlob(int)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/BlobTypeHandler.javaBaseTypeHandler<byte[]>TypeReference<byte[]>TypeHandler<byte[]>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/BooleanTypeHandler.javaBaseTypeHandler<Boolean>TypeReference<Boolean>TypeHandler<Boolean>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/ByteArrayTypeHandler.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/ByteArrayUtils.javaconvertToObjectArrayconvertToObjectArray(byte[])/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/ByteArrayUtils.classconvertToPrimitiveArrayconvertToPrimitiveArray(java.lang.Byte[])ByteArrayUtilsByteArrayUtils()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/ByteObjectArrayTypeHandler.javagetBytes(byte[])/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/ByteObjectArrayTypeHandler.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/ByteTypeHandler.javaBaseTypeHandler<Byte>TypeReference<Byte>TypeHandler<Byte>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/CharacterTypeHandler.javaBaseTypeHandler<Character>TypeReference<Character>TypeHandler<Character>columnValue/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/ClobReaderTypeHandler.javatoReadertoReader(java.sql.Clob)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/ClobReaderTypeHandler.classBaseTypeHandler<Reader>TypeReference<Reader>TypeHandler<Reader>clobThe {@link TypeHandler} for {@link Clob}/{@link Reader} using method supported at JDBC 4.0.Set a {@link Reader} into {@link PreparedStatement}.PreparedStatement#setClob(int, Reader)Get a {@link Reader} that corresponds to a specified column name from {@link ResultSet}.ResultSet#getClob(String)Get a {@link Reader} that corresponds to a specified column index from {@link ResultSet}.ResultSet#getClob(int)Get a {@link Reader} that corresponds to a specified column index from {@link CallableStatement}.CallableStatement#getClob(int)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/ClobTypeHandler.javatoString(java.sql.Clob)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/ClobTypeHandler.classBaseTypeHandler<String>TypeReference<String>TypeHandler<String>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/DateOnlyTypeHandler.javaBaseTypeHandler<Date>TypeReference<Date>TypeHandler<Date>sqlDate/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/DateTypeHandler.javasqlTimestamp/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/DoubleTypeHandler.javaBaseTypeHandler<Double>TypeReference<Double>TypeHandler<Double>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/EnumOrdinalTypeHandler.javatoOrdinalEnumtoOrdinalEnum(int)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/EnumOrdinalTypeHandler.classEnum[]Enum<E>Comparable<E>Enum<E>[]enumsBaseTypeHandler<E>TypeReference<E>TypeHandler<E>"Type argument cannot be null"Type argument cannot be nullEnum<>[]Class<? super E>Constructor<E>TypeVariable<Class<E>>TypeVariable<Class<E>>[]" does not represent an enum type." does not represent an enum type.Enum<E>(java.lang.String,int)"Cannot convert "Cannot convert " to " to " by ordinal value." by ordinal value./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/EnumTypeHandler.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/EnumTypeHandler.class see r3589/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/FloatTypeHandler.javaBaseTypeHandler<Float>TypeReference<Float>TypeHandler<Float>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/InstantTypeHandler.javagetInstantgetInstant(java.sql.Timestamp)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/InstantTypeHandler.classBaseTypeHandler<Instant>TypeReference<Instant>TypeHandler<Instant>Tomas Rohovsky/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/IntegerTypeHandler.javaBaseTypeHandler<Integer>TypeReference<Integer>TypeHandler<Integer>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/JapaneseDateTypeHandler.javagetJapaneseDategetJapaneseDate(java.sql.Date)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/JapaneseDateTypeHandler.classBaseTypeHandler<JapaneseDate>TypeReference<JapaneseDate>TypeHandler<JapaneseDate>dateType Handler for {@link JapaneseDate}./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/JdbcType.javaJdbcTypeJdbcType(int)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/JdbcType.classMap<Integer,JdbcType>codeLookup1000155HashMap<Integer,JdbcType>AbstractMap<Integer,JdbcType>HashMap<Integer,JdbcType>()BiFunction<? super JdbcType,? super JdbcType,? extends JdbcType>merge(java.lang.Integer,org.apache.ibatis.type.JdbcType,java.util.function.BiFunction)BiFunction<? super Integer,? super JdbcType,? extends JdbcType>Function<? super Integer,? extends JdbcType>replace(java.lang.Integer,org.apache.ibatis.type.JdbcType)replace(java.lang.Integer,org.apache.ibatis.type.JdbcType,org.apache.ibatis.type.JdbcType)putIfAbsent(java.lang.Integer,org.apache.ibatis.type.JdbcType)BiConsumer<? super Integer,? super JdbcType>getOrDefault(java.lang.Object,org.apache.ibatis.type.JdbcType)Entry<Integer,JdbcType>Set<Entry<Integer,JdbcType>>Collection<Entry<Integer,JdbcType>>Iterable<Entry<Integer,JdbcType>>Map<? extends Integer,? extends JdbcType>put(java.lang.Integer,org.apache.ibatis.type.JdbcType)AbstractMap<Integer,JdbcType>()HashMap<Integer,JdbcType>(java.util.Map)HashMap<Integer,JdbcType>(int)HashMap<Integer,JdbcType>(int,float)JdbcType[]codeThis is added to enable basic support for the ARRAY data type - but a custom type handler is still required Oracle JDK6 SQL Server 2008 JDBC 4.2 JDK8/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/LocalDateTimeTypeHandler.javaBaseTypeHandler<LocalDateTime>TypeReference<LocalDateTime>TypeHandler<LocalDateTime>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/LocalDateTypeHandler.javaBaseTypeHandler<LocalDate>TypeReference<LocalDate>TypeHandler<LocalDate>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/LocalTimeTypeHandler.javaBaseTypeHandler<LocalTime>TypeReference<LocalTime>TypeHandler<LocalTime>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/LongTypeHandler.javaBaseTypeHandler<Long>TypeReference<Long>TypeHandler<Long>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/MappedJdbcTypes.javaThe annotation that specify jdbc types to map {@link TypeHandler}.&#064;MappedJdbcTypes({ JdbcType.CHAR, JdbcType.VARCHAR })public class StringTrimmingTypeHandler implements TypeHandler&lt;String&gt; {Returns jdbc types to map {@link TypeHandler}.jdbc typesReturns whether map to jdbc null type.{@code true} if map, {@code false} if otherwise/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/MappedTypes.javaThe annotation that specify java types to map {@link TypeHandler}.&#064;MappedTypes(String.class)Returns java types to map {@link TypeHandler}.java types/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/MonthTypeHandler.javaBaseTypeHandler<Month>TypeReference<Month>TypeHandler<Month>monthBjörn Raupach/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/NClobTypeHandler.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/NClobTypeHandler.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/NStringTypeHandler.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/ObjectTypeHandler.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/OffsetDateTimeTypeHandler.javaBaseTypeHandler<OffsetDateTime>TypeReference<OffsetDateTime>TypeHandler<OffsetDateTime>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/OffsetTimeTypeHandler.javaBaseTypeHandler<OffsetTime>TypeReference<OffsetTime>TypeHandler<OffsetTime>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/ShortTypeHandler.javaBaseTypeHandler<Short>TypeReference<Short>TypeHandler<Short>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/SimpleTypeRegistry.javaSimpleTypeRegistrySimpleTypeRegistry()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/SimpleTypeRegistry.classSIMPLE_TYPE_SETTells us if the class passed in is a known common type@param clazz The class to check@return True if the class is known/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/SqlDateTypeHandler.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/SqlTimeTypeHandler.javaBaseTypeHandler<Time>TypeReference<Time>TypeHandler<Time>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/SqlTimestampTypeHandler.javaBaseTypeHandler<Timestamp>TypeReference<Timestamp>TypeHandler<Timestamp>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/SqlxmlTypeHandler.javasqlxmlConvert <code>String</code> to/from <code>SQLXML</code>./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/StringTypeHandler.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/TimeOnlyTypeHandler.javasqlTime/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/TypeAliasRegistry.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/TypeAliasRegistry.class"string""byte""char""character"character"long""short""int""integer"integer"double""float""boolean"Class<Byte[]>"byte[]"Character[]Class<Character[]>"char[]""character[]"character[]Long[]Class<Long[]>"long[]"Short[]Class<Short[]>"short[]"Integer[]Class<Integer[]>"int[]""integer[]"integer[]Double[]Class<Double[]>"double[]"Float[]Class<Float[]>"float[]"Boolean[]Class<Boolean[]>"boolean[]""_byte"_byte"_char"_char"_character"_character"_long"_long"_short"_short"_int"_int"_integer"_integer"_double"_double"_float"_float"_boolean"_boolean"_byte[]"_byte[]Class<char[]>"_char[]"_char[]"_character[]"_character[]Class<long[]>"_long[]"_long[]Class<short[]>"_short[]"_short[]Class<int[]>"_int[]"_int[]"_integer[]"_integer[]Class<double[]>"_double[]"_double[]Class<float[]>"_float[]"_float[]Class<boolean[]>"_boolean[]"_boolean[]"date""decimal"decimal"bigdecimal"bigdecimal"biginteger"biginteger"object"Date[]Class<Date[]>"date[]"date[]BigDecimal[]Class<BigDecimal[]>"decimal[]"decimal[]"bigdecimal[]"bigdecimal[]BigInteger[]Class<BigInteger[]>"biginteger[]"biginteger[]"object[]"object[]"map""hashmap"hashmap"arraylist"arraylistClass<Iterator<>>"iterator""ResultSet"ResultSet"Could not resolve type alias '"Could not resolve type alias 'typeSetaliasAnnotationClass<Alias>"The parameter alias cannot be null"The parameter alias cannot be null"The alias '"The alias '"' is already mapped to the value '"' is already mapped to the value '"Error registering type alias "Error registering type alias " for " for  throws class cast exception as well if types cannot be assigned issue #748 Ignore inner classes and interfaces (including package-info.java) Skip also inner classes. See issue #6Gets the type aliases.the type aliases/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/TypeException.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/TypeException.class8614420898975117130L8614420898975117130/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/TypeHandler.javaGets the result.the result/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/TypeHandlerRegistry.javaregisterregister(java.lang.reflect.Type,org.apache.ibatis.type.JdbcType,org.apache.ibatis.type.TypeHandler)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/TypeHandlerRegistry.classregister(java.lang.reflect.Type,org.apache.ibatis.type.TypeHandler)TypeHandler<? extends T>Map<JdbcType,TypeHandler<?>>pickSoleHandlerpickSoleHandler(java.util.Map)getJdbcHandlerMapForSuperclassgetJdbcHandlerMapForSuperclass(java.lang.Class)getJdbcHandlerMapForEnumInterfacesgetJdbcHandlerMapForEnumInterfaces(java.lang.Class,java.lang.Class)getJdbcHandlerMapgetJdbcHandlerMap(java.lang.reflect.Type)getTypeHandlergetTypeHandler(java.lang.reflect.Type,org.apache.ibatis.type.JdbcType)NULL_TYPE_HANDLER_MAPallTypeHandlersMapunknownTypeHandlerMap<Type,Map<JdbcType,TypeHandler<?>>>jdbcTypeHandlerMapEnumMap<JdbcType,TypeHandler<?>>/89ABCDEFGHIJK/java.base/java/util/EnumMap.sigAbstractMap<JdbcType,TypeHandler<?>>Class<K>EnumMap<JdbcType,TypeHandler<?>>(java.lang.Class)merge(org.apache.ibatis.type.JdbcType,org.apache.ibatis.type.TypeHandler,java.util.function.BiFunction)BiFunction<? super JdbcType,? super TypeHandler<?>,? extends TypeHandler<?>>compute(org.apache.ibatis.type.JdbcType,java.util.function.BiFunction)computeIfPresent(org.apache.ibatis.type.JdbcType,java.util.function.BiFunction)Function<? super JdbcType,? extends TypeHandler<?>>computeIfAbsent(org.apache.ibatis.type.JdbcType,java.util.function.Function)replace(org.apache.ibatis.type.JdbcType,org.apache.ibatis.type.TypeHandler)replace(org.apache.ibatis.type.JdbcType,org.apache.ibatis.type.TypeHandler,org.apache.ibatis.type.TypeHandler)putIfAbsent(org.apache.ibatis.type.JdbcType,org.apache.ibatis.type.TypeHandler)BiConsumer<? super JdbcType,? super TypeHandler<?>>Entry<JdbcType,TypeHandler<?>>Set<Entry<JdbcType,TypeHandler<?>>>Collection<Entry<JdbcType,TypeHandler<?>>>Iterable<Entry<JdbcType,TypeHandler<?>>>Set<JdbcType>Map<? extends JdbcType,? extends TypeHandler<?>>put(org.apache.ibatis.type.JdbcType,org.apache.ibatis.type.TypeHandler)AbstractMap<JdbcType,TypeHandler<?>>()EnumMap<>put(java.lang.Enum,java.lang.Object)EnumMapEnumMap(java.util.Map)Map<JdbcType,? extends TypeHandler<?>>EnumMap<JdbcType,TypeHandler<?>>(java.util.Map)EnumMap<K,? extends V>AbstractMap<K,? extends V>EnumMap(java.util.EnumMap)EnumMap<JdbcType,? extends TypeHandler<?>>AbstractMap<JdbcType,? extends TypeHandler<?>>EnumMap<JdbcType,TypeHandler<?>>(java.util.EnumMap)EnumMap(java.lang.Class)ConcurrentHashMap<Type,Map<JdbcType,TypeHandler<?>>>AbstractMap<Type,Map<JdbcType,TypeHandler<?>>>ConcurrentMap<Type,Map<JdbcType,TypeHandler<?>>>ConcurrentHashMap<Type,Map<JdbcType,TypeHandler<?>>>()? super Map<JdbcType,TypeHandler<?>>? extends Map<JdbcType,TypeHandler<?>>BiFunction<? super Map<JdbcType,TypeHandler<?>>,? super Map<JdbcType,TypeHandler<?>>,? extends Map<JdbcType,TypeHandler<?>>>merge(java.lang.reflect.Type,java.util.Map,java.util.function.BiFunction)? super TypeBiFunction<? super Type,? super Map<JdbcType,TypeHandler<?>>,? extends Map<JdbcType,TypeHandler<?>>>compute(java.lang.reflect.Type,java.util.function.BiFunction)computeIfPresent(java.lang.reflect.Type,java.util.function.BiFunction)Function<? super Type,? extends Map<JdbcType,TypeHandler<?>>>computeIfAbsent(java.lang.reflect.Type,java.util.function.Function)replace(java.lang.reflect.Type,java.util.Map)replace(java.lang.reflect.Type,java.util.Map,java.util.Map)putIfAbsent(java.lang.reflect.Type,java.util.Map)BiConsumer<? super Type,? super Map<JdbcType,TypeHandler<?>>>Entry<Type,Map<JdbcType,TypeHandler<?>>>Set<Entry<Type,Map<JdbcType,TypeHandler<?>>>>Collection<Entry<Type,Map<JdbcType,TypeHandler<?>>>>Iterable<Entry<Type,Map<JdbcType,TypeHandler<?>>>>Collection<Map<JdbcType,TypeHandler<?>>>Iterable<Map<JdbcType,TypeHandler<?>>>Set<Type>Collection<Type>Iterable<Type>Map<? extends Type,? extends Map<JdbcType,TypeHandler<?>>>put(java.lang.reflect.Type,java.util.Map)AbstractMap<Type,Map<JdbcType,TypeHandler<?>>>()ToIntFunction<Entry<Type,Map<JdbcType,TypeHandler<?>>>>ToLongFunction<Entry<Type,Map<JdbcType,TypeHandler<?>>>>ToDoubleFunction<Entry<Type,Map<JdbcType,TypeHandler<?>>>>Function<Entry<Type,Map<JdbcType,TypeHandler<?>>>,? extends U>? extends Entry<Type,Map<JdbcType,TypeHandler<?>>>BiFunction<Entry<Type,Map<JdbcType,TypeHandler<?>>>,Entry<Type,Map<JdbcType,TypeHandler<?>>>,? extends Entry<Type,Map<JdbcType,TypeHandler<?>>>>? super Entry<Type,Map<JdbcType,TypeHandler<?>>>Consumer<? super Entry<Type,Map<JdbcType,TypeHandler<?>>>>ToIntFunction<? super Map<JdbcType,TypeHandler<?>>>ToLongFunction<? super Map<JdbcType,TypeHandler<?>>>ToDoubleFunction<? super Map<JdbcType,TypeHandler<?>>>Function<? super Map<JdbcType,TypeHandler<?>>,? extends U>Consumer<? super Map<JdbcType,TypeHandler<?>>>ToIntFunction<? super Type>ToLongFunction<? super Type>ToDoubleFunction<? super Type>Function<? super Type,? extends U>BiFunction<? super Type,? super Type,? extends Type>Consumer<? super Type>ToIntBiFunction<? super Type,? super Map<JdbcType,TypeHandler<?>>>ToLongBiFunction<? super Type,? super Map<JdbcType,TypeHandler<?>>>ToDoubleBiFunction<? super Type,? super Map<JdbcType,TypeHandler<?>>>BiFunction<? super Type,? super Map<JdbcType,TypeHandler<?>>,? extends U>KeySetView<Type,Map<JdbcType,TypeHandler<?>>>CollectionView<Type,Map<JdbcType,TypeHandler<?>>,Type>keySet(java.util.Map)Enumeration<Map<JdbcType,TypeHandler<?>>>Enumeration<Type>ConcurrentHashMap<Type,Map<JdbcType,TypeHandler<?>>>(int,float,int)ConcurrentHashMap<Type,Map<JdbcType,TypeHandler<?>>>(int,float)ConcurrentHashMap<Type,Map<JdbcType,TypeHandler<?>>>(java.util.Map)ConcurrentHashMap<Type,Map<JdbcType,TypeHandler<?>>>(int)EnumTypeHandler<>BaseTypeHandler<>TypeReference<>Class<EnumTypeHandler<>>Class<Reader>Class<InputStream>Class<Instant>Class<ZonedDateTime>Class<Month>Class<Year>Class<YearMonth>Class<JapaneseDate>TypeReference<?>javaTypeReferencehandlerTypegetRawTypegetRawType()getSuperclassTypeParametergetSuperclassTypeParameter(java.lang.Class)TypeReferenceTypeReference()TypeReference<T>()jdbcHandlerMapClass<Enum<>>? super Enum<>Class<? super Enum<>>Constructor<Enum<>>TypeVariable<Class<Enum<>>>TypeVariable<Class<Enum<>>>[]enumClazzHashMap<JdbcType,TypeHandler<?>>newMapHashMap<JdbcType,TypeHandler<?>>()HashMap<JdbcType,TypeHandler<?>>(java.util.Map)HashMap<JdbcType,TypeHandler<?>>(int)HashMap<JdbcType,TypeHandler<?>>(int,float)setValue(org.apache.ibatis.type.TypeHandler)soleHandlermappedTypeFoundmappedTypesConstructor<? extends TypeHandler<>>TypeVariable<Class<? extends TypeHandler<>>>TypeVariable<Class<? extends TypeHandler<>>>[]Class<MappedTypes>handledTypetypeReferencemappedJdbcTypesClass<MappedJdbcTypes>handledJdbcType"cast"javaTypeClassNametypeHandlerClassName"Failed invoking constructor for handler "Failed invoking constructor for handler "Unable to find a usable constructor for "Unable to find a usable constructor for handlerSetThe default constructor.The constructor that pass the MyBatis configuration.a MyBatis configuration issue #273 #591 type drives generics here Found a type handler registered to a super interface Create a type handler instance with enum type as a constructor arg More than one type handlers registered. REGISTER INSTANCE Only handler @since 3.1.0 - try to auto-discover the mapped type maybe users define the TypeReference with a different type and are not assignable, so just ignore it java type + handler java type + jdbc type + handler Cast is required here REGISTER CLASS Only handler type java type + handler type java type + jdbc type + handler type Construct a handler (used also from Builders) ignored scan Ignore inner classes and interfaces (including package-info.java) and abstract classes get informationGets the type handlers.the type handlers/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/TypeReference.java? extends TypeReference<>Class<? extends TypeReference<>>genericSuperclassClass<TypeReference<>>"' extends TypeReference but misses the type parameter. "
          + "Remove the extension or add a type parameter to it."' extends TypeReference but misses the type parameter. Remove the extension or add a type parameter to it.References a generic type.the referenced type try to climb up the hierarchy until meet something useful TODO remove this when Reflector is fixed to return Types/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/UnknownTypeHandler.javasafeGetClassForColumnsafeGetClassForColumn(java.sql.ResultSetMetaData,java.lang.Integer)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/type/UnknownTypeHandler.classsafeGetJdbcTypeForColumnsafeGetJdbcTypeForColumn(java.sql.ResultSetMetaData,java.lang.Integer)resolveTypeHandler(java.sql.ResultSetMetaData,java.lang.Integer)resolveTypeHandler(java.sql.ResultSet,java.lang.String)resolveTypeHandler(java.lang.Object,org.apache.ibatis.type.JdbcType)Supplier<TypeHandlerRegistry>typeHandlerRegistrySupplierOBJECT_TYPE_HANDLERMap<String,Integer>columnIndexLookupBiFunction<? super Integer,? super Integer,? extends Integer>merge(java.lang.String,java.lang.Integer,java.util.function.BiFunction)BiFunction<? super String,? super Integer,? extends Integer>Function<? super String,? extends Integer>replace(java.lang.String,java.lang.Integer)replace(java.lang.String,java.lang.Integer,java.lang.Integer)putIfAbsent(java.lang.String,java.lang.Integer)BiConsumer<? super String,? super Integer>getOrDefault(java.lang.Object,java.lang.Integer)Entry<String,Integer>Set<Entry<String,Integer>>Collection<Entry<String,Integer>>Iterable<Entry<String,Integer>>Map<? extends String,? extends Integer>put(java.lang.String,java.lang.Integer)HashMap<String,Integer>AbstractMap<String,Integer>HashMap<String,Integer>()AbstractMap<String,Integer>()HashMap<String,Integer>(java.util.Map)HashMap<String,Integer>(int)HashMap<String,Integer>(int,float)"Error determining JDBC type for column "Error determining JDBC type for column  TODO Rename to 'configuration' after removing the 'configuration' property(deprecated property) on parent classThe constructor that pass a MyBatis configuration.The constructor that pass the type handler registry.a type handler registrySince 3.5.4, please use the {@link #UnknownTypeHandler(Configuration)}. check if handler is null (issue #270)/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/YearMonthTypeHandler.javaBaseTypeHandler<YearMonth>TypeReference<YearMonth>TypeHandler<YearMonth>yearMonthjtType Handler for {@link java.time.YearMonth}.YearMonthTypeHandler relies upon {@link java.time.YearMonth#parse YearMonth.parse}. Therefore column values areexpected as strings. The format must be uuuu-MM. Example: "2016-08"/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/YearTypeHandler.javaBaseTypeHandler<Year>TypeReference<Year>TypeHandler<Year>year/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/ZonedDateTimeTypeHandler.javaBaseTypeHandler<ZonedDateTime>TypeReference<ZonedDateTime>TypeHandler<ZonedDateTime>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/type/package-info.javaType handlers./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/util/MapUtil.java/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/main/java/org/apache/ibatis/utilorg.apache.ibatis.utilMapUtilMapUtil()/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/util/MapUtil.class/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/target/classes/org/apache/ibatis/utilFunction<K,V>mappingFunctionSimpleImmutableEntry<K,V>/BCDEFGHIJK/java.base/java/util/AbstractMap$SimpleImmutableEntry.sigSimpleImmutableEntry<K,V>(java.lang.Object,java.lang.Object)SimpleImmutableEntrySimpleImmutableEntry(java.util.Map.Entry)SimpleImmutableEntry<K,V>(java.util.Map.Entry)SimpleImmutableEntry(java.lang.Object,java.lang.Object)A temporary workaround for Java 8 specific performance issue JDK-8161372 .<br>This class should be removed once we drop Java 8 support."https://bugs.openjdk.java.net/browse/JDK-8161372">https://bugs.openjdk.java.net/browse/JDK-8161372</a>Map.entry(key, value) alternative for Java 8./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/es/xdoc/configuration.xml/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/es/xdoc/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/es/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/sitehttp://maven.apache.org/XDOC/2.0http://maven.apache.org/XDOC/2.0 https://maven.apache.org/xsd/xdoc-2.0.xsdtitleMyBatis 3 | Configuraciónauthorclinton.begin@gmail.comeduardo.macarron@gmail.comsectionConfiguraciónEl fichero de configuración XML contiene parámetros y configuraciones que tienen un efecto crucial en cómo se comporta MyBatis. A alto nivel contiene:ullihref#properties#settings#typeAliases#typeHandlers#objectFactory#plugins#environments
                  environment
                  #databaseIdProvider#mappers
          configuration
          subsectionContiene propiedades externalizables y sustituibles que se pueden configurar en un típico properties de Java o bien puede definirse su contenido directamente mediante subelementos property. Por ejemplo:
        <properties resource="org/mybatis/example/config.properties">
  <property name="username" value="dev_user"/>
  <property name="password" value="F2Fa3!33TYyg"/>
</properties>Las propiedades pueden usarse a lo largo del fichero de configuración para sustituir valores que deben configurarse dinámicamente. Por ejemplo:
        <dataSource type="POOLED">
  <property name="driver" value="${driver}"/>
  <property name="url" value="${url}"/>
  <property name="username" value="${username}"/>
  <property name="password" value="${password}"/>
</dataSource>El usuario y password de este ejemplo se reemplazarán por los valores de los elementos de tipo property. El driver y la url se reemplazarán por los valores contenidos en el fichero config.properties.  Esto aumenta mucho las posibilidades de configuración.
        Las propiedades también pueden pasarse como parámetro al método SqlSessionFactoryBuilder.build(). Por ejemplo:
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);

// ... or ...

SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props);
Si una propiedad existe en más de un lugar, MyBatis la carga en este orden:
        Primero se leen las propiedades especificadas en el elemento XML properties,
          Posteriormente se cargan las propiedades de recursos de tipo classpath o url del elementos properties, si hubiera una propiedad repetida sería sobrescrita,
          Y finalmente se leen las propiedades pasadas como parámetro, que en caso de duplicidad sobrescriben las propiedades que se hayan cargado del elemento properties o de recursos/url.
          Por tanto las properties más prioritarias son las pasadas como parámetro, seguidas de los atributos tipo classpath/url y finalmente las propiedades especificadas en el elemento properties..
        
          Since the MyBatis 3.4.2, your can specify a default value into placeholder as follow:
        
<dataSource type="POOLED">
  <!-- ... -->
  <property name="username" value="${username:ut_user}"/> <!-- If 'username' property not present, username become 'ut_user' -->
</dataSource>
          This feature is disabled by default. If you specify a default value into placeholder,
          you should be enable this feature by adding a special property as follow:
        
<properties resource="org/mybatis/example/config.properties">
  <!-- ... -->
  <property name="org.apache.ibatis.parsing.PropertyParser.enable-default-value" value="true"/> <!-- Enable this feature -->
</properties>spanlabel importantNOTEdb:username${tableName != null ? tableName : 'global_constants'} Also If you are used already the  as property key(e.g. )
          or you are used already the ternary operator of OGNL expression(e.g. ) on your sql definition,
          you should be change the character that separate key and default value by adding a special property as follow:
        
<properties resource="org/mybatis/example/config.properties">
  <!-- ... -->
  <property name="org.apache.ibatis.parsing.PropertyParser.default-value-separator" value="?:"/> <!-- Change default value of separator -->
</properties>
<dataSource type="POOLED">
  <!-- ... -->
  <property name="username" value="${db:username?:ut_user}"/>
</dataSource>Son muy importantes para definir cómo se comporta MyBatis en ejecución. La siguiente tabla describe las configuraciones (settings), sus significados y sus valores por defecto.theadtrDescripciónValores admitidosValor por defectotbodytd
                cacheEnabled
              Habilita o inhabilita globalmente todas las cachés definidas en el mapper
              
                true | false
              
                true
              
                lazyLoadingEnabled
              
                Habilita o inhabilita globalmente la carga diferida (lazy loading). Cuando está activo, todas las relaciones se cargan en modo diferido.
                Este valor se puede sobrescribir en cada relación usando el atributo .
              
                false
              
                aggressiveLazyLoading
              
                When enabled, any method call will load all the lazy properties of the object. Otherwise, each property is loaded on demand (see also ).
              
                false (true in ≤3.4.1)
              
                multipleResultSetsEnabled
              Habilita o inhabilita la obtención de múltiples ResultSets con una sola sentencia (se requiere un driver compatible)
              
                useColumnLabel
              Utiliza la etiqueta de columna (label) en lugar del nombre de conlumna. Algunos drivers se comportan distinto en lo que a esto respecta. Consulta la documentación del driver o prueba ambos modos para descubrir cómo funciona tu driver
              
                useGeneratedKeys
              Habilita el uso del soporte JDBC para claves autogeneradas. Se requiere un driver compatible. Este parámetro fuerza el uso de las claves autogeneradas si está habilitado. Algunos drivers indican que no son compatibles aunque funcionan correctamente (ej. Derby)
              
                False
              
                autoMappingBehavior
              Especifica cómo deben mapearse de forma automática las columnas a los campos/propiedades. NONE desactiva el mapeo automático. PARTIAL sólo mapea automáticamente los resultados que no contienen result maps anidados en su interior. FULL mapea resultados de cualquier complejidad (contengan anidados o no).
              
                NONE, PARTIAL, FULL
              
                PARTIAL
              
                autoMappingUnknownColumnBehavior
              : Do nothingWARNING'org.apache.ibatis.session.AutoMappingUnknownColumnBehavior'WARN: Output warning log (The log level of  must be set to FAILINGSqlSessionException: Fail mapping (Throw 
                Specify the behavior when detects an unknown column (or unknown property type) of automatic mapping target.
                
                Note that there could be false-positives when `autoMappingBehavior` is set to `FULL`.
              
                NONE, WARNING, FAILING
              
                NONE
              
                defaultExecutorType
              Configura el ejecutor (executor) por defecto. SIMPLE no hace nada especial. REUSE reúsa prepared statements. BATCH reúsa statements y ejecuta actualizaciones en batch.
                SIMPLE
                REUSE
                BATCH
              
                SIMPLE
              
                defaultStatementTimeout
              Establece el número de segundos que debe esperar el driver la respuesta de la base de datos.
              
                Cualquier entero positivo
              
                Sin valor (null)
              
                defaultFetchSize
              
                Sets the driver a hint as to control fetching size for return results.
                This parameter value can be override by a query setting.
              
                defaultResultSetType
              
                Specifies a scroll strategy when omit it per statement settings. (Since: 3.5.2)
              
                FORWARD_ONLY | SCROLL_SENSITIVE | SCROLL_INSENSITIVE | DEFAULT(same behavior with 'Not Set')
              
                Not Set (null)
              
                safeRowBoundsEnabled
              Habilita el uso de RowBounds en statements anidados.
                If allow, set the false.
              
                safeResultHandlerEnabled
              
                Habilita el uso de ResultHandler en statements anidados.
                If allow, set the false.
              
                True
              
                mapUnderscoreToCamelCase
              Mapea automáticamente los nombres clásicos de columnas de base de datos A_COLUMN a nombres clásicos de propiedades Java aColumn.
              
                localCacheScope
              
                MyBatis usa una cache local para evitar dependencias circulares y acelerar ejecuciones repeticas de queries anidadas.
                Por defecto (SESSION) todas las queries ejecutadas en una sesión se cachean. Si localCacheScope=STATEMENT
                la sesión local solo se usará durante la ejecución de un statement, no se comparten datos entre distintas llamadas
                a SqlSession.
              
                SESSION | STATEMENT
              
                SESSION
              
                jdbcTypeForNull
              
                Permite especificar el tipo JDBC que
                Especifica el tipo JDBC para valores nulos cuando no se ha especificado un tipo concreto para el parámetro.
                Algunos drivers requieren que se indique el tipo JDBC de la columna pero otros permite valores genéricos como NULL, VARCHAR or OTHER.
              
                JdbcType enumeration. Los más comunes son: NULL, VARCHAR and OTHER
              
                OTHER
              
                lazyLoadTriggerMethods
              
                Permite especificar qué métodos de Object disparan la carga diferida
              
                Lista de métodos separados por comas
              
                equals,clone,hashCode,toString
              
                defaultScriptingLanguage
              
                Permite especificar que lenguaje se usará en el SQL dinámico.
              
                Un type alias o una nombre de clase completamente cualificado
              
                org.apache.ibatis.scripting.xmltags.XMLLanguageDriver
              
                defaultEnumTypeHandler
              TypeHandler
                Specifies the  used by default for Enum. (Since: 3.4.5)
              
                A type alias or fully qualified class name.
              
                org.apache.ibatis.type.EnumTypeHandler
              
                callSettersOnNulls
              
                Permite especificar si se invocarán a los setters y a los métodos put de los mapas si el valor obtenido es null.
                Te en cuenta que si se activa las propiedades que puedan ser informadas con nulos no pueden ser de tipos primitivos.
              
                returnInstanceForEmptyRow
              
                MyBatis, by default, returns  when all the columns of a returned row are NULL.
                When this setting is enabled, MyBatis returns an empty instance instead.
                Note that it is also applied to nested results (i.e. collectioin and association). Since: 3.4.2
              
                logPrefix
              
                Permite especificar el prefijo que MyBatis añadirá a los nombres de logger.
              
                Cualquier cadena
              
                No informado
              
                logImpl
              
                Permite especificar qué implementación de logging utilizar. Si no está informado la impelmentación se descubrirá automaticamente.
              
                SLF4J | LOG4J(deprecated since 3.5.9) | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING
              
                proxyFactory
              
                Permite especificar qué herramienta de generación de proxys se usará para crear los objetos con capacidad de carga lazy.
              
                CGLIB (deprecated since 3.5.10) | JAVASSIST
              
                JAVASSIST (MyBatis 3.3 or above)
              
                vfsImpl
              
                Specifies VFS implementations
              
                Fully qualified class names of custom VFS implementation separated by commas.
              
                Not set
              
                useActualParamName
              -parameters
                Allow referencing statement parameters by their actual names declared in the method signature.
                To use this feature, your project must be compiled in Java 8 with  option. (Since: 3.4.1)
              
                configurationFactory
              static Configuration getConfiguration()
                Specifies the class that provides an instance of .
                The returned Configuration instance is used to load lazy properties of deserialized objects.
                This class must have a method with a signature . (Since: 3.2.3)
              
                shrinkWhitespacesInSql
              
                Removes extra whitespace characters from the SQL. Note that this also affects literal strings in SQL. (Since 3.5.5)
              
                defaultSqlProviderType
              @SelectProvider
                Specifies an sql provider class that holds provider method (Since 3.5.6).
                This class apply to the (or ) attribute on sql provider annotation(e.g. ),
                when these attribute was omitted.
              
                A type alias or fully qualified class name
              
                nullableOnForEach
              
                Specifies the default value of 'nullable' attribute on 'foreach' tag. (Since 3.5.9)
              
                argNameBasedConstructorAutoMapping
              
                When applying constructor auto-mapping, argument name is used to search the column to map instead of relying on the column order. (Since 3.5.10)
              
A continuación se muestra un ejemplo del elemento settings al completo:
        <settings>
  <setting name="cacheEnabled" value="true"/>
  <setting name="lazyLoadingEnabled" value="true"/>
  <setting name="aggressiveLazyLoading" value="true"/>
  <setting name="multipleResultSetsEnabled" value="true"/>
  <setting name="useColumnLabel" value="true"/>
  <setting name="useGeneratedKeys" value="false"/>
  <setting name="autoMappingBehavior" value="PARTIAL"/>
  <setting name="autoMappingUnknownColumnBehavior" value="WARNING"/>
  <setting name="defaultExecutorType" value="SIMPLE"/>
  <setting name="defaultStatementTimeout" value="25"/>
  <setting name="defaultFetchSize" value="100"/>
  <setting name="safeRowBoundsEnabled" value="false"/>
  <setting name="safeResultHandlerEnabled" value="true"/>
  <setting name="mapUnderscoreToCamelCase" value="false"/>
  <setting name="localCacheScope" value="SESSION"/>
  <setting name="jdbcTypeForNull" value="OTHER"/>
  <setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/>
  <setting name="defaultScriptingLanguage" value="org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"/>
  <setting name="defaultEnumTypeHandler" value="org.apache.ibatis.type.EnumTypeHandler"/>
  <setting name="callSettersOnNulls" value="false"/>
  <setting name="returnInstanceForEmptyRow" value="false"/>
  <setting name="logPrefix" value="exampleLogPreFix_"/>
  <setting name="logImpl" value="SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING"/>
  <setting name="proxyFactory" value="CGLIB | JAVASSIST"/>
  <setting name="vfsImpl" value="org.mybatis.example.YourselfVfsImpl"/>
  <setting name="useActualParamName" value="true"/>
  <setting name="configurationFactory" value="org.mybatis.example.ConfigurationFactory"/>
</settings>Un type alias es simplemente un alias (un nombre más corto) para un tipo Java. Solo es importante para la configuración XML y existe para reducir la cantidad de texto al teclear nombres de clase cualificados (fully qualified). Por ejemplo:
        <typeAliases>
  <typeAlias alias="Author" type="domain.blog.Author"/>
  <typeAlias alias="Blog" type="domain.blog.Blog"/>
  <typeAlias alias="Comment" type="domain.blog.Comment"/>
  <typeAlias alias="Post" type="domain.blog.Post"/>
  <typeAlias alias="Section" type="domain.blog.Section"/>
  <typeAlias alias="Tag" type="domain.blog.Tag"/>
</typeAliases>
Blogdomain.blog.Blog
        Con esta configuración, puede usarse  en lugar de 
        Tambien puedes indicar un paquete para que MyBatis busque beans de tipo alias. Por ejemplo:
        <typeAliases>
  <package name="domain.blog"/>
</typeAliases>
domain.blogdomain.blog.Author@Alias
        Cada bean encontrado en , en caso de que no contenga ninguna anotación,
        se registrará como alias usando su nombre no cualificado en minúsculas. Es decir, 
        se registrará como will be registered as .
        Si se encuentra la anotación  se usará su valor como alias. Mira el ejemplo a continuación:
        @Alias("author")
public class Author {
    ...
}
Hay muchos type aliases pre construidos. No son sensibles a mayúsculas/minúsculas. Observa los nombres especiales de los tipos primitivos dadas las colisiones de nombres.
        
                Alias
              
                Tipo mapeado
              
                _byte
              
                byte
              
                _char (since 3.5.10)
              
                char
              
                _character (since 3.5.10)
              
                _long
              
                long
              
                _short
              
                short
              
                _int
              
                int
              
                _integer
              
                _double
              
                double
              
                _float
              
                float
              
                _boolean
              
                boolean
              
                string
              
                String
              
                Byte
              
                char (since 3.5.10)
              
                Character
              
                character (since 3.5.10)
              
                Long
              
                Short
              
                Integer
              
                integer
              
                Double
              
                Float
              
                Boolean
              
                date
              
                Date
              
                decimal
              
                BigDecimal
              
                bigdecimal
              
                biginteger
              
                BigInteger
              
                object
              
                Object
              
                date[]
              
                Date[]
              
                decimal[]
              
                BigDecimal[]
              
                bigdecimal[]
              
                biginteger[]
              
                BigInteger[]
              
                object[]
              
                Object[]
              
                map
              
                Map
              
                hashmap
              
                HashMap
              
                list
              
                List
              
                arraylist
              
                ArrayList
              
                collection
              
                Collection
              
                iterator
              
                Iterator
              Cuando MyBatis establece el valor de un parámetro de un PreparedStatement u obtiene un valor de un ResultSet, se utiliza un TypeHandler para convertir el valor al tipo Java apropiado. La siguiente tabla recoge los TypeHandlers predefinidos.
        
          Since version 3.4.5, The MyBatis has been supported JSR-310(Date and Time API) by default.
        
                Type Handler
              
                Tipos Java
              
                Tipos JDBC
              BooleanTypeHandlerjava.lang.BooleanBOOLEAN
                Cualquiera compatible con ByteTypeHandlerjava.lang.ByteNUMERICBYTE o ShortTypeHandlerjava.lang.ShortSMALLINTIntegerTypeHandlerjava.lang.IntegerINTEGERLongTypeHandlerjava.lang.LongBIGINTFloatTypeHandlerjava.lang.FloatFLOATDoubleTypeHandlerjava.lang.DoubleDOUBLEBigDecimalTypeHandlerjava.math.BigDecimalDECIMALStringTypeHandlerjava.lang.StringCHARVARCHARClobReaderTypeHandlerjava.io.Reader
                -
              ClobTypeHandlerCLOBLONGVARCHARNStringTypeHandlerNVARCHARNCHARNClobTypeHandlerNCLOBBlobInputStreamTypeHandlerjava.io.InputStreamByteArrayTypeHandler
                Cualquiera compatible con byte stream
              BlobTypeHandlerBLOBLONGVARBINARYDateTypeHandlerjava.util.DateTIMESTAMPDateOnlyTypeHandlerDATETimeOnlyTypeHandlerTIMESqlTimestampTypeHandlerjava.sql.TimestampSqlDateTypeHandlerjava.sql.DateSqlTimeTypeHandlerjava.sql.TimeObjectTypeHandler
                Any
              , or unspecified
              EnumTypeHandler
                Enumeration Type
               Cualquiera compatible con string porque se guarda el código (no el índice).
              EnumOrdinalTypeHandler por que se guarda la posición (no el código).
              SqlxmlTypeHandlerSQLXMLInstantTypeHandlerjava.time.InstantLocalDateTimeTypeHandlerjava.time.LocalDateTimeLocalDateTypeHandlerjava.time.LocalDateLocalTimeTypeHandlerjava.time.LocalTimeOffsetDateTimeTypeHandlerjava.time.OffsetDateTimeOffsetTimeTypeHandlerjava.time.OffsetTimeZonedDateTimeTypeHandlerjava.time.ZonedDateTimeYearTypeHandlerjava.time.YearMonthTypeHandlerjava.time.MonthYearMonthTypeHandlerjava.time.YearMonth or JapaneseDateTypeHandlerjava.time.chrono.JapaneseDateorg.apache.ibatis.type.TypeHandlerorg.apache.ibatis.type.BaseTypeHandler
        Es posible sobrescribir los TypeHanders o crear TypeHanders personalizados para tratar tipos no soportados o no estándares.
        Para ello, debes implementar la interfaz  o extender
        la clase de ayuda  y opcionalmente mapear el TypeHandler a un tipo JDBC.
        Por ejemplo:
        // ExampleTypeHandler.java
@MappedJdbcTypes(JdbcType.VARCHAR)
public class ExampleTypeHandler extends BaseTypeHandler<String> {

  @Override
  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {
    ps.setString(i, parameter);
  }

  @Override
  public String getNullableResult(ResultSet rs, String columnName) throws SQLException {
    return rs.getString(columnName);
  }

  @Override
  public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
    return rs.getString(columnIndex);
  }

  @Override
  public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
    return cs.getString(columnIndex);
  }
}
<!-- mybatis-config.xml -->
<typeHandlers>
  <typeHandler handler="org.mybatis.example.ExampleTypeHandler"/>
</typeHandlers>
Al usar este TypeHandler se sobrescribe el TypeHandler existente para los tipos String y los parámetros y resultados VARCHAR. Observa que MyBatis no introspecciona la base de datos para conocer el tipo así que debes especificar que se trata de un VARCHAR en los mapeos de parámetros y resultados para que se use el TypeHandler adecuado. Esto se debe a que MyBatis no conoce nada sobre los tipos de datos hasta que la sentencia ha sido ejecutada.
          MyBatis conoce el tipo Java que quieres gestionar introspecionando tipo genérico del TypeHandler, pero puedes modificar este comportamiento de dos maneras.
        javaType="String"Añadir un atributo  al elemento typeHandler (por ejemplo: )
          @MappedTypesAñadir una anotación  a tu clase TypeHandler especificando la lista de tipos java a la que asociarlo.
          Esta anotación será ignorada si se ha especificado también un atributo .
          El tipo JDBC asociado se puede especificar de dos maneras:jdbcType="VARCHAR"
           Añadiendo un atributo  al lemento typeHandler (por ejemplo: ).
          @MappedJdbcTypesAñadiendo una anotación  a tu clase TypeHandler especificando la lista de tipos JDBC a la que asociarlo.
          Esta anotación será ignorada si se ha especificado también un atributo javaType=[TheJavaType], jdbcType=nullrestrictsincludeNullJdbcType=truebsingle
          When deciding which TypeHandler to use in a , the Java type is known
          (from the result type), but the JDBC type is unknown. MyBatis therefore uses the combination
           to choose a TypeHandler. This means that
          using a  annotation  the scope of a TypeHandler
          and makes it unavailable for use in s unless explicity set. To make a
          TypeHandler available for use in a , set 
          on the  annotation. Since Mybatis 3.4.0 however, if a 
          TypeHandler is registered to handle a Java type, it will be used by default in s
          using this Java type (i.e. even without ).
        Y finalmente puedes hacer que MyBatis busque tus TypeHandlers:<!-- mybatis-config.xml -->
<typeHandlers>
  <package name="org.mybatis.example"/>
</typeHandlers>

          Observa que cuando usas la función de búsqueda los tipos JDBC sólo se pueden especificar usando anotaciones.
        
          Puedes crear un TypeHandler genérico que sea capaz de manejar más de un tipo de clase. Para ello añade
          un constructor que recibe una clase como parámetro y MyBatis le pasará la clase actual cuando construya
          el TypeHandler.
        //GenericTypeHandler.java
public class GenericTypeHandler<E extends MyObject> extends BaseTypeHandler<E> {

  private Class<E> type;

  public GenericTypeHandler(Class<E> type) {
    if (type == null) throw new IllegalArgumentException("Type argument cannot be null");
    this.type = type;
  }
  ...
 y  son TypeHandlers genéricos.
        Conoceremos más sobre ellos en la próxima sección.
        Handling Enums
        Si quires mapear un , debes usar bien un
         o un .
        Por ejemplo, digamos que quieres guardar el modo de reondeo que debe
        usarse con un número determinado que debe redondearse. Por defecto MyBatis
        usa un  para comvertir los valores del  
        a sus nombres.
        Observa que el  es un handler especial en el sentido de que
        no maneja una clase específica, como los demás handlers sino cualquier clase que extiende
        de RoundingMode
        Sin embargo, puede que no queramos guardar nombres. Nuestro DBA puede insistir en que
        usemos un entero en su lugar. Muy sencillo: añade un 
        a las sección de  de tu fichero de configuración y ahora todos los
         se mapearán a un entero usando su valor ordinal.
        <!-- mybatis-config.xml -->
<typeHandlers>
  <typeHandler handler="org.apache.ibatis.type.EnumOrdinalTypeHandler" javaType="java.math.RoundingMode"/>
</typeHandlers>

      Pero ¿y si quieres mapear el mismo  a un string en un sitio pero a un entero en otro?
    
          El mapeo automático siempre usará ,
          así que si queremos usar el clásico ,
          debemos indicarlo establiencidolo esplícitamente su uso en los statements.
        
          Los mappers no se tratarán hasta la sección siguiente asi que si esta es tu primera lectura de
          la documentación quizá prefieras saltarte esta sección por ahora y volver más tarde).
        <!DOCTYPE mapper
    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "https://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="org.apache.ibatis.submitted.rounding.Mapper">
  <resultMap type="org.apache.ibatis.submitted.rounding.User" id="usermap">
    <id column="id" property="id"/>
    <result column="name" property="name"/>
    <result column="funkyNumber" property="funkyNumber"/>
    <result column="roundingMode" property="roundingMode"/>
  </resultMap>

  <select id="getUser" resultMap="usermap">
    select * from users
  </select>
  <insert id="insert">
      insert into users (id, name, funkyNumber, roundingMode) values (
        #{id}, #{name}, #{funkyNumber}, #{roundingMode}
      )
  </insert>

  <resultMap type="org.apache.ibatis.submitted.rounding.User" id="usermap2">
    <id column="id" property="id"/>
    <result column="name" property="name"/>
    <result column="funkyNumber" property="funkyNumber"/>
    <result column="roundingMode" property="roundingMode" typeHandler="org.apache.ibatis.type.EnumTypeHandler"/>
  </resultMap>
  <select id="getUser2" resultMap="usermap2">
    select * from users2
  </select>
  <insert id="insert2">
      insert into users2 (id, name, funkyNumber, roundingMode) values (
        #{id}, #{name}, #{funkyNumber}, #{roundingMode, typeHandler=org.apache.ibatis.type.EnumTypeHandler}
      )
  </insert>

</mapper>

      Observa que esto nos fuerza a usar un 
      en lugar de un  en nuestros statements tipo select.
    Cada vez que MyBatis crea una nueva instancia de un objeto de resultado usa una instancia de ObjectFactory para hacerlo. El ObjectFactory por defecto no hace mucho más que instanciar la clase destino usando su constructor por defecto, o el constructor que se ha parametrizado en su caso. Es posible sobrescribir el comportamiento por defecto creando tu propio ObjectFactory. Por ejemplo:
        // ExampleObjectFactory.java
public class ExampleObjectFactory extends DefaultObjectFactory {
  @Override
  public <T> T create(Class<T> type) {
    return super.create(type);
  }

  @Override
  public <T> T create(Class<T> type, List<Class<?>> constructorArgTypes, List<Object> constructorArgs) {
    return super.create(type, constructorArgTypes, constructorArgs);
  }

  @Override
  public void setProperties(Properties properties) {
    super.setProperties(properties);
  }

  @Override
  public <T> boolean isCollection(Class<T> type) {
    return Collection.class.isAssignableFrom(type);
  }
}<!-- mybatis-config.xml -->
<objectFactory type="org.mybatis.example.ExampleObjectFactory">
  <property name="someProperty" value="100"/>
</objectFactory>La interfaz ObjectFactory es muy sencilla. Contiene solo dos métodos de creación, uno para el constructor por defecto y otro para el constructor parametrizado. Adicionalmente el método setProperties sirve para configurar el ObjectFactory. Las propiedades definidas en el cuerpo del elemento objectFactory se pasan al método setProperties después de que el ObjectFactory haya sido inicializado.
        MyBatis permite interceptar las llamadas en ciertos puntos de la ejecución de un mapped statement. Por defecto, MyBatis permite incluir plugins que intercepten las llamadas de:
        
            Executor
            (update, query, flushStatements, commit, rollback,
            getTransaction, close,
            isClosed)
          
            ParameterHandler
            (getParameterObject, setParameters)
          
            ResultSetHandler
            (handleResultSets, handleOutputParameters)
          
            StatementHandler
            (prepare, parameterize, batch, update, query)
          Los detalles de estos métodos se pueden conocer observando sus firmas y el código fuente de los mismos que está disponible en el sitio de MyBatis. Es recomendable que comprendas el funcionamiento del método que estas sobrescribiendo siempre que vayas a hacer algo más complejo que monitorizar llamadas. Ten en cuenta que si modificas el comportamiento de alguno de estos métodos existe la posibilidad de que rompas el funcionamiento de MyBatis. Estas clases son de bajo nivel y por tanto debes usar los plugins con cuidado.
        Utilizar un plugin es muy sencillo para la potencia que ofrecen. Simplemente implementa el interfaz Interceptor y asegúrate de especificar las signaturas que quieres interceptar.
        // ExamplePlugin.java
@Intercepts({@Signature(
  type= Executor.class,
  method = "update",
  args = {MappedStatement.class,Object.class})})
public class ExamplePlugin implements Interceptor {
  private Properties properties = new Properties();

  @Override
  public Object intercept(Invocation invocation) throws Throwable {
    // implement pre processing if need
    Object returnObject = invocation.proceed();
    // implement post processing if need
    return returnObject;
  }

  @Override
  public void setProperties(Properties properties) {
    this.properties = properties;
  }
}<!-- mybatis-config.xml -->
<plugins>
  <plugin interceptor="org.mybatis.example.ExamplePlugin">
    <property name="someProperty" value="100"/>
  </plugin>
</plugins>El plugin anterior interceptará cualquier llamada al método “update” en la instancia de Executor, que es un objeto interno que se encarga de la ejecución a bajo nivel de los mapped statements.
        NOTAstrongAcerca de sobrescribir la clase Configuration
          Además de modificar el comportamiento de MyBatis mediante los plugins, también es posible sobrescribir la clase Configuración por completo. Extiende la clase, sobrescribe sus métodos y pásala como parámetro en la llamada al método SqlSessionFactoryBuilder.build(myConfig). Nuevamente, ten cuenta que esto puede afectar seriamente al funcionamiento de MyBatis así que úsalo con cuidado.
        En MyBatis pueden configurarse varios entornos. De esta forma puedes usar tus SQL Maps en distintas bases de datos por muchos motivos. Por ejemplo puede que tengas una configuración distinta para tus entornos de desarrollo, pruebas y producción. O quizá tengas varias bases de datos en producción que comparten el esquema y quieres usar los mismos SQL maps sobre todas ellas. Como ves, hay muchos casos.
        Debes recordar un asunto importante. Cuando configures varios entornos, solo será posible usar UNO por cada instancia de SqlSessionFactory.Por lo tanto, si quieres conectar a dos bases de datos, deberás crear dos instancias de SqlSessionFactory, una para cada cual. Para el caso de tres bases de datos necesitarás tres instancias y así sucesivamente. Es fácil de recordar:
        Una instancia de SqlSessionFactory por base de datosPara indicar qué entorno debe utilizarse, debes informar el parámetro opcional correspondiente en la llamada al SqlSessionFactoryBuilder. Existen dos métodos que aceptan el entorno:SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment,properties);Si se omite el entorno se usará el entorno por defecto:SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader,properties);El elemento environments contiene la configuración del entorno:<environments default="development">
  <environment id="development">
    <transactionManager type="JDBC">
      <property name="..." value="..."/>
    </transactionManager>
    <dataSource type="POOLED">
      <property name="driver" value="${driver}"/>
      <property name="url" value="${url}"/>
      <property name="username" value="${username}"/>
      <property name="password" value="${password}"/>
    </dataSource>
  </environment>
</environments>
          Observa que las secciones importantes son:
        El ID del entorno por defecto (ej. default=”development”).El ID de de cada entorno definido (ej. id=”development”).La configuración del TransactionManager (ej. type=”JDBC”)La configuración del DataSource (ej. type=”POOLED”)El ID del entorno por defecto y de los entornos existentes son auto-explicativos. Puedes nombrarlos como más te guste, tan sólo asegúrate de que el valor por defecto coincide con un entorno existente.
        MyBatis incluye dos tipos de TransactionManager (ej. type=”[JDBC|MANAGED]”):
        <transactionManager type="JDBC">
  <property name="skipSetAutoCommitOnClose" value="true"/>
</transactionManager>JDBC – Este TransactionManager simplemente hace uso del las capacidades de commit y rollback de JDBC.  Utiliza la conexión obtenida del DataSource para gestionar la transacción. By default, it enables auto-commit when closing the connection for compatibility with some drivers. However, for some drivers, enabling auto-commit is not only unnecessary, but also is an expensive operation. So, since version 3.5.10, you can skip this step by setting the "skipSetAutoCommitOnClose" property to true. For example:
            <transactionManager type="MANAGED">
  <property name="closeConnection" value="false"/>
</transactionManager>MANAGED  – Este TransactionManager no hace nada. No hace commit ni rollback sobre la conexión. En su lugar, permite que el contenedor gestione el ciclo de vida completo de la transacción (ej. Spring o un servidor de aplicaciones JEE).  Por defecto cierra la conexión. Sin embargo, algunos contenedores no esperan que la conexión se cierre y por tanto, si necesitas cambiar este comportamiento, informa la propiedad closeConnection a false. Por ejemplo:

          Si estás pensando en usar MyBatis con Spring no necesitas configurar ningún TransactionManager
          porque el módulo de Spring configurará el suyo propio sobrescribiendo cualquier otra configuración previa.
        Ninguno de estos TransactionManagers necesita ninguna propiedad. Sin embargo ambos son Type Aliases, es decir, en lugar de usarlos puedes informar el nombre totalmente cualificado o el Type Alias de tu propia implementación del interfaz TransactionFactory:
        public interface TransactionFactory {
  default void setProperties(Properties props) { // Since 3.5.2, change to default method
    // NOP
  }
  Transaction newTransaction(Connection conn);
  Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit);
}Todas las propiedades que configures en el XML se pasarán al método setProperties() tras la instanciación de la clase. Tu implementación debe crear una implementación de Transaction, que a su vez es también un interfaz muy sencillo:
        public interface Transaction {
  Connection getConnection() throws SQLException;
  void commit() throws SQLException;
  void rollback() throws SQLException;
  void close() throws SQLException;
  Integer getTimeout() throws SQLException;
}Con estos dos interfaces puedes personalizar por completo la forma en la que MyBatis gestiona las transacciones.El elemento dataSource sirve para configurar la forma de obtener conexiones JDBC mediante la interfaz DataSource JDBC estándar.La mayoría de las aplicaciones que usen MyBatis configurarán el dataSource como se muestra en el ejemplo. Sin embargo, esta configuración no es obligatoria. Ten en cuenta, aun así, que el dataSource es necesario para utilizar Lazy Loading.
          Hay tres tipos de dataSources pre-construidos (ej. type=”????”): – Esta implementación de DataSource abre y cierra una conexión JDBC cada vez que se solcita una conexión. Aunque es un poco lento, es una buena elección para aplicaciones que no necesitan la velocidad de tener conexiones abiertas de forma inmediata. Las bases de datos tienen un rendimiento distinto en cuanto al rendimiento que aportan con este tipo de DataSource, para algunas de ellas no es muy importante tener un pool y por tanto esta configuración es apropiada. El DataSource UNPOOLED tiene las siguientes opciones de configuración:
           – El nombre completamente cualificado de la clase java del driver JDBC (NO de la clase DataSource en el caso de que tu driver incluya una). – La URL de la instancia de base de datos.
           – El usuario de conexión.
           – La password de conexión.
           – El nivel de aislamiento por defecto con el que se crearán las conexiones.
          java.sql.Connection#setNetworkTimeout() – The default network timeout value in milliseconds to wait for the database operation to complete. See the API documentation of  for details.
          Opcionalmente, puedes también pasar propiedades al driver de la base de datos. Para ello prefija las propiedades con “driver.”, por ejemplo:
        driver.encoding=UTF8
          Esto pasaría la propiedad “encoding” con el valor “UTF8” al driver de base datos mediante el método DriverManager.getConnection(url, driverProperties).
         – Esta implementación de DataSource hace usa un pool de conexiones para evitar el tiempo necesario en realizar la conexión y autenticación cada vez que se solicita una nueva instancia de conexión. Este es un enfoque habitual en aplicaciones Web concurrentes para obtener el mejor tiempo de respuesta posible.Además de las propiedades de (UNPOOLED) hay otras muchas propiedades que se pueden usar para configurar el DataSource POOLED:
         – Número máximo de conexiónes activas que pueden existir de forma simultánea. Por defecto:  10
           – Número máximo de conexiones libres que pueden existir de forma simultánea.
           – Tiempo máximo que puede permanecer una conexión fuera del pool antes de que sea forzosamente devuelta. Por defecto: 20000ms (20 segundos)
           – Este es un parámetro de bajo nivel que permite escribir un log y reintentar la adquisición de una conexión en caso de que no se haya conseguido la conexión transcurrido un tiempo razonable (esto evita que se produzcan fallos constantes y silenciosos si el pool está mal configurado). Por defecto:  20000ms (20 segundos)
           – This is a low level setting about
            tolerance of bad connections got for any thread. If a thread got a bad connection, it may
            still have another chance to re-attempt to get another connection which is valid. But the
            retrying times should not more than the sum of 
            and .
            Default:
            3 (Since: 3.4.5)
           – La query de ping (sondeo) que se envía a la base de datos para verificar que la conexión funciona correctamente y que está lista para aceptar nuevas peticiones de conexión. El valor por defecto es "NO PING QUERY SET", que hará que la mayoría de los drivers de base de datos devuelvan un error con un mensaje de error decente.
           – Habilita o inhabilita la query de ping. Si está habilitada deberías informar también la propiedad poolPingQuery con una sentencia SQL (preferentemente una rápida).  Por defecto:  false.
          poolPingConnectionsNotUsedFor – Configura la frecuencia con la que se ejecutará la sentencia poolPingQuery. Normalmente se iguala al timeout de la conexión de base de datos para evitar pings innecesarios. Por defecto: 0 (todas las conexiones se testean continuamente – solo si se ha habilitado poolPingEnabled).
          
          – Esta implementación de DataSource está pensada para ser usada en contenedores como Spring o los servidores de aplicaciones JEE en los que es posible configurar un DataSource de forma externa y alojarlo en el contexto JNDI. Esta configuración de DataSource requiere solo dos propiedades:
         – Propiedad que se usa para realizar el lookup en el InitialContext (initialContext.lookup(initial_context)). Esta propiedad es opcional, si no se informa, se buscará directamente la propiedad data_source.
           – Es el contexto donde se debe buscar el DataSource. El DataSource se buscará en el contexto resultado de buscar data_source en el InitialContext o si no se ha informado la propiedad se buscará directamente sobre InitialContext.
          Al igual que en las otras configuraciones de DataSource. Es posible enviar propiedades directamente al InitialContext prefijando las propiedades con “env.”, por ejemplo:
        env.encoding=UTF8
         Enviará la propiedad “encoding” y el valor “UTF-8” al constructor del InitialContext durante su instanciación.
        org.apache.ibatis.datasource.DataSourceFactory
      You can plug any 3rd party DataSource by implementing the interface :
    public interface DataSourceFactory {
  void setProperties(Properties props);
  DataSource getDataSource();
}org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory
      The  puede extenderse para crear nuevos
      adaptadores. Por ejemplo, este es el código necesario para integrar C3P0:
    import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;
import com.mchange.v2.c3p0.ComboPooledDataSource;

public class C3P0DataSourceFactory extends UnpooledDataSourceFactory {

  public C3P0DataSourceFactory() {
    this.dataSource = new ComboPooledDataSource();
  }
}Para configurarlo, añade una propiedad por cada método al que quieres que llame MyBatis.
        A continuación se muestra una configuración de ejemplo para conectar con una base de datos PostgresSQL:<dataSource type="org.myproject.C3P0DataSourceFactory">
  <property name="driver" value="org.postgresql.Driver"/>
  <property name="url" value="jdbc:postgresql:mydb"/>
  <property name="username" value="postgres"/>
  <property name="password" value="root"/>
</dataSource>

          MyBatis puede ejeutar sentencias distintas en función del fabricante (vendor) de tu base de datos.
          El soporte de múltiples bases de datos se basa en el atributo de  de los mapped statements.
          MyBatis cargará todos los statements que no tengan atributo  attribute o aquellos
          cuyo  coincida con el valor en curso. Si se encuentra un statement con y sin atributo
           el último se descartará.
          Para activar el soporte de multi vendor añade un 
          al fichero mybatis-config.xml file de la siguiente forma:
        <databaseIdProvider type="DB_VENDOR" />
DatabaseMetaData#getDatabaseProductName()
      La implementación DB_VENDOR del databaseIdProvider establece como databaseId el String devuelto por
      .
      Como normalmente este string es demasiado largo, y además, distintas versiones del mismo producto devuelven valores
      similares, puedes traducirlo a un valor más corto añadiendo propiedades de la siguente forma:
    <databaseIdProvider type="DB_VENDOR">
  <property name="SQL Server" value="sqlserver"/>
  <property name="DB2" value="db2"/>
  <property name="Oracle" value="oracle" />
</databaseIdProvider>getDatabaseProductName()
      Cuando se añaden propiedades, el databaseIdProvider DB_VENDOR devuelve el primer valor que corresponde a la primera clave
      encontrada en el nombre devuelto por  o "null" si no se encuentra ninguna.
      En este caso, si  devuelve "Oracle (DataDirect)" el databaseId se informará con "oracle".
    org.apache.ibatis.mapping.DatabaseIdProvider
      Puedes construir tu propio DatabaseIdProvider implementando la interfaz 
      y registrandolo en el fichero mybatis-config.xml:
    public interface DatabaseIdProvider {
  default void setProperties(Properties p) { // Since 3.5.2, change to default method
    // NOP
  }
  String getDatabaseId(DataSource dataSource) throws SQLException;
}
          Ahora que se ha configurado el comportamiento de MyBatis con todos los elementos de configuración comentados estamos listos para definir los SQL mapped statements (sentencias SQL mapeadas). Primeramente necesitaremos indicarle a MyBatis dónde encontrarlos. Java no ofrece muchas posibilidades de auto-descubrimiento así que la mejor forma es simplemente decirle a MyBatis donde encontrar los ficheros de mapeo. Puedes utilizar referencias tipo classpath, o tipo path o referencias url completamente cualificadas (incluyendo file:///) . Por ejemplo:
        <!-- Using classpath relative resources -->
<mappers>
  <mapper resource="org/mybatis/builder/AuthorMapper.xml"/>
  <mapper resource="org/mybatis/builder/BlogMapper.xml"/>
  <mapper resource="org/mybatis/builder/PostMapper.xml"/>
</mappers><!-- Using url fully qualified paths -->
<mappers>
  <mapper url="file:///var/mappers/AuthorMapper.xml"/>
  <mapper url="file:///var/mappers/BlogMapper.xml"/>
  <mapper url="file:///var/mappers/PostMapper.xml"/>
</mappers><!-- Using mapper interface classes -->
<mappers>
  <mapper class="org.mybatis.builder.AuthorMapper"/>
  <mapper class="org.mybatis.builder.BlogMapper"/>
  <mapper class="org.mybatis.builder.PostMapper"/>
</mappers><!-- Register all interfaces in a package as mappers -->
<mappers>
  <package name="org.mybatis.builder"/>
</mappers>
         Esta configuración sólo indica a MyBatis cuáles son los ficheros de mapeo. El resto de la configuración se encuentra dentro de estos ficheros, y eso es de lo que hablaremos en el siguiente apartado.
        /Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/es/xdoc/dynamic-sql.xmlMyBatis 3 | SQL dinámicoSQL dinámicoUna de las características más potentes de MyBatis ha sido siempre sus capacidades de SQL dinámico. Si tienes experiencia con JDBC o algún framework similar, entenderás que doloroso es concatenar strings de SQL, asegurándose de que no olvidas espacios u omitir una coma al final de la lista de columnas. El SQL dinámico puede ser realmente doloroso de usar.Aunque trabajar con SQL dinámico no va a ser nunca una fiesta, MyBatis ciertamente mejora la situación con un lenguaje de SQL dinámico potente que puede usarse en cualquier mapped statement.Los elementos de SQL dinámico deberían ser familiares a aquel que haya usado JSTL o algún procesador de texto basado en XML. En versiones anteriores de MyBatis había un montón de elementos que conocer y comprender. MyBatis 3 mejora esto y ahora hay algo menos de la mitad de esos elementos con los que trabajar. MyBatis emplea potentes expresiones OGNL para eliminar la necesidad del resto de los elementos:choose (when, otherwise)trim (where, set)La tarea más frecuente en SQL dinámico es incluir un trozo de la clausula where condicionalmente. Por ejemplo:<select id="findActiveBlogWithTitleLike"
     resultType="Blog">
  SELECT * FROM BLOG
  WHERE state = ‘ACTIVE’
  <if test="title != null">
    AND title like #{title}
  </if>
</select>Este statement proporciona una funcionalidad de búsqueda de texto. Si no se pasa ningún título, entonces se retornan todos los Blogs activos. Pero si se pasa un título se buscará un título como el pasado (para los perspicaces, sí, en este caso tu parámetro debe incluir el carácter de comodín).¿Y cómo hacemos si debemos buscar opcionalmente por título o autor? Primeramente, yo cambiaría el nombre del statement para que tenga algo más de sentido. Y luego añadir otra condición.<select id="findActiveBlogLike"
     resultType="Blog">
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’
  <if test="title != null">
    AND title like #{title}
  </if>
  <if test="author != null and author.name != null">
    AND author_name like #{author.name}
  </if>
</select>choose, when, otherwisechooseWhenOtherwiseEn ocasiones no queremos usar una condición sino elegir una de entre varias opciones. De forma similar al switch  de Java, MyBatis ofrece el elemento choose.Usemos el ejemplo anterior, pero ahora vamos a buscar solamente por título si se ha proporcionado un título y por autor si se ha proporcionado un autor. Si  no se proporciona ninguno devolvemos una lista de Blogs destacados (quizá una lista seleccionada por los administradores en lugar de una gran lista de blogs sin sentido).<select id="findActiveBlogLike"
     resultType="Blog">
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’
  <choose>
    <when test="title != null">
      AND title like #{title}
    </when>
    <when test="author != null and author.name != null">
      AND author_name like #{author.name}
    </when>
    <otherwise>
      AND featured = 1
    </otherwise>
  </choose>
</select>trim, where, settrimWhereSetEn los ejemplos anteriores se ha sorteado intencionadamente un notorio problema del SQL dinámico. Imagina lo que sucedería si volvemos a nuestro ejemplo del “if”, pero esta vez, hacemos que “ACTIVE = 1” sea también una condición dinámica.<select id="findActiveBlogLike"
     resultType="Blog">
  SELECT * FROM BLOG
  WHERE
  <if test="state != null">
    state = #{state}
  </if>
  <if test="title != null">
    AND title like #{title}
  </if>
  <if test="author != null and author.name != null">
    AND author_name like #{author.name}
  </if>
</select>¿Qué sucede si no se cumple ninguna condición? Acabarías con una sentencia SQL con este aspecto:SELECT * FROM BLOG
WHEREY eso fallará. ¿Y qué sucede si se cumple la segunda condición? Acabarías con una sentencia SQL con este aspecto:SELECT * FROM BLOG
WHERE
AND title like ‘someTitle’Y eso también fallará. Este problema no se resuelve fácil con condicionales, y si alguna vez tienes que hacerlo, posiblemente no quieras repetirlo nunca más.MyBatis tiene una respuesta sencilla que funcionará en el 90% de los casos. Y en los casos en los que no funciona puedes personalizarlo para hacerlo funcionar. Con un cambio simple, todo funciona correctamente:<select id="findActiveBlogLike"
     resultType="Blog">
  SELECT * FROM BLOG
  <where>
    <if test="state != null">
         state = #{state}
    </if>
    <if test="title != null">
        AND title like #{title}
    </if>
    <if test="author != null and author.name != null">
        AND author_name like #{author.name}
    </if>
  </where>
</select>El elemento where sabe que debe insertar la “WHERE” solo si los tags internos devuelven algún contenido. Más aun, si el contenido comienza con “AND” o “OR”, sabe cómo eliminarlo.Si el elemento where no se comporta exactamente como te gustaría, lo puedes personalizar definiendo tu propio elemento trim. Por ejemplo, el trim equivalente al elemento where es:<trim prefix="WHERE" prefixOverrides="AND |OR ">
  ...
</trim>El atributo prefixOverrides acepta una lista de textos delimitados pro el carácter “| “ donde el espacio en blanco es relevante. El resultado es que se elimina cualquier cosa que se haya especificado en el atributo prefixOverrides, y que se inserta todo lo incluido en el atributo with.Hay una solución similar para updates dinámicos llamada set. El elemento set se pude usar para incluir dinámicamente columnas para modificar y dejar fuera las demás. Por ejemplo:<update id="updateAuthorIfNecessary">
  update Author
    <set>
      <if test="username != null">username=#{username},</if>
      <if test="password != null">password=#{password},</if>
      <if test="email != null">email=#{email},</if>
      <if test="bio != null">bio=#{bio}</if>
    </set>
  where id=#{id}
</update>En este caso, el elemento set  prefijará dinámicamente el valor SET y además eliminará todas las comas sobrantes que pudieran quedar tras las asignaciones de valor después de que se hayan aplicado las condiciones.emAlternativamente, puede utilizar el elemento  para obtener el mismo efecto:<trim prefix="SET" suffixOverrides=",">
  ...
</trim>Fíjate que en este caso estamos sobrescribiendo un sufijo y añadiendo un prefijo.Otra necesidad común del SQL dinámico es iterar sobre una colección, habitualmente para construir una condición IN. Por ejemplo:<select id="selectPostIn" resultType="domain.blog.Post">
  SELECT *
  FROM POST P
  <where>
    <foreach item="item" index="index" collection="list"
        open="ID in (" separator="," close=")" nullable="true">
          #{item}
    </foreach>
  </where>
</select>El elemento foreach es muy potente, permite especificar una colección y declarar variables elemento e índice que pueden usarse dentro del cuerpo del elemento. Permite también abrir y cerrar strings y añadir un separador entre las iteraciones. Este elemento es inteligente en tanto en cuanto no añade separadores extra accidentalmente. You can pass any Iterable object (for example List, Set, etc.), as well as any Map or Array object to foreach as collection parameter. When using an Iterable or Array, index will be the number of current iteration and value item will be the element retrieved in this iteration. When using a Map (or Collection of Map.Entry objects), index will be the key object and item will be the value object.Esto finaliza la discusión sobre la configuración XML y los ficheros de mapeo XML. En la sección siguiente hablaremos del API Java en detalle, de forma que puedas obtener el máximo rendimiento de los mapeos que has creado.For using dynamic SQL in annotated mapper class,  element can be used. For example:
    @Update({"<script>",
      "update Author",
      "  <set>",
      "    <if test='username != null'>username=#{username},</if>",
      "    <if test='password != null'>password=#{password},</if>",
      "    <if test='email != null'>email=#{email},</if>",
      "    <if test='bio != null'>bio=#{bio}</if>",
      "  </set>",
      "where id=#{id}",
      "</script>"})
    void updateAuthorValues(Author author);El elemento  te permite crear una variable a partir de una expresion OGNL y asociarla al contexto. Por ejemplo:
<select id="selectBlogsLike" resultType="Blog">
  <bind name="pattern" value="'%' + _parameter.getTitle() + '%'" />
  SELECT * FROM BLOG
  WHERE title LIKE #{pattern}
</select>Soporte de multiples vendedores de base de datosSi se ha configurado un databaseIdProvider la variable "_databaseId" estará disponible en el código dinámico, de esta forma puedes constrir distintas sntencias dependiendo del fabricante de la base de datos. Mira el siguiente ejemplo:<insert id="insert">
  <selectKey keyProperty="id" resultType="int" order="BEFORE">
    <if test="_databaseId == 'oracle'">
      select seq_users.nextval from dual
    </if>
    <if test="_databaseId == 'db2'">
      select nextval for seq_users from sysibm.sysdummy1"
    </if>
  </selectKey>
  insert into users values (#{id}, #{name})
</insert>
Lenguajes de scripting customizados para SQL dinámicoDesde la versión 3.2 MyBatis soporta la adición de lenguajes de scripting de forma que puedes
    añadir un driver de lenguaje y usar dicho lenguaje para escribir tus sentencias SQL.
    Puedes añadir un lenguaje implementando el siguiente interfaz:public interface LanguageDriver {
  ParameterHandler createParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql);
  SqlSource createSqlSource(Configuration configuration, XNode script, Class<?> parameterType);
  SqlSource createSqlSource(Configuration configuration, String script, Class<?> parameterType);
}Una vez tienes tu driver de lenguaje puedes puede hacer que sea el de uso por defecto estableciéndolo en el fichero mybatis-config.xml:<typeAliases>
  <typeAlias type="org.sample.MyLanguageDriver" alias="myLanguage"/>
</typeAliases>
<settings>
  <setting name="defaultScriptingLanguage" value="myLanguage"/>
</settings>
En lugar de cambiar el valor por defecto, puedes indicar el lenguaje para un statement específico
    añadiendo el atributo  de la siguiente forma:
    <select id="selectBlog" lang="myLanguage">
  SELECT * FROM BLOG
</select>@LangO, en el caso de que uses mappers, usando la anotación public interface Mapper {
  @Lang(MyLanguageDriver.class)
  @Select("SELECT * FROM BLOG")
  List<Blog> selectBlog();
} Puedes utilizar Apache Velocity como lenguaje dinámico. Echa un vistazo al proyecto MyBatis-Velocity para conocer los detalles.org.apache.ibatis.scripting.xmltags.XmlLanguageDriverTodos los tags que has visto en las secciones previas se proporcionan por el lenguaje por defecto de MyBatis cuyo driver es
     que tiene un alias llamado /Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/es/xdoc/java-api.xmlMyBatis 3 | Java APIJava APIjavaApiAhora que ya conoces cómo configurar MyBatis y crear mapeos estás listo para lo mejor. El API Java es donde obtendrás los mejores frutos de tus esfuerzos. Como verás, comparado con JDBC, MyBatis simplifica enormemente tu código y lo mantiene limpio, de fácil comprensión y mantenimiento. MyBatis 3 incorpora muchas mejoras significativas para hacer que el trabajo con SQL Maps sea aun mejor.Directory StructuredirectoryStructureAntes de zambullirnos en el propio API Java , es importante comprender las mejores prácticas relativas a la estructura de directorios. MyBatis es muy flexible, y puedes hacer casi cualquier cosa con tus ficheros. Pero como en cualquier otro framework, hay una forma recomendable.Veamos una estructura de directorios típica:prett<-- Los ficheros .jar de MyBatis van aqui./lib                <-- Los artefactos de MyBatis van aqui, lo que incluye, mappers, configuración XML, y ficheros de mapeo XML./data           <-- Las Properties incluidas en tu configuración XML van aqui./properties       /my_application
  /bin
  /devlib
  
  /src
    /org/myapp/
      /action
      
        /mybatis-config.xml
        /BlogMapper.java
        /BlogMapper.xml
      /model
      /service
      /view
    
  /test
    /org/myapp/
      /action
      /data
      /model
      /service
      /view
    /properties
  /web
    /WEB-INF
      /web.xmlRecuerda, esto son prefierncias no requisitos, pero habrá otros que te agradecerán que uses una estructura de directorios conún.Los ejemplos restantes en esta sección asumen que estás utilizando esta estructura de directorios.SqlSessionssqlSessionsEl interfaz principal para trabajar con MyBatis es el SqlSession. A través de este interfaz puedes ejecutar comandos, obtener mappers y gestionar transacciones. Hablaremos más sobre el propio SqlSession en breve, pero primero veamos cómo obtener una instancia de SqlSession. Las SqlSessions se crean por una instancia de SqlSessionFactory. La SqlSessionFactory contiene métodos para crear instancias de SqlSessions de distintas formas. La SqlSessionFactory en si misma se crea por la SqlSessionFactoryBuilder que puede crear una SqlSessionFactory a partir de XML, anotaciones o un objeto Configuration creado por código. When using MyBatis with a dependency injection framework like Spring or Guice, SqlSessions are created and injected by the DI framework so you don't need to use the SqlSessionFactoryBuilder or SqlSessionFactory and can go directly to the SqlSession section. Please refer to the MyBatis-Spring or MyBatis-Guice manuals for further info.h4SqlSessionFactoryBuilderEl SqlSessionFactoryBuilder tiene cinco métodos build(), cada cual permite construir una SqlSessionFactory desde un origen distinto.SqlSessionFactory build(InputStream inputStream)
SqlSessionFactory build(InputStream inputStream, String environment)
SqlSessionFactory build(InputStream inputStream, Properties properties)
SqlSessionFactory build(InputStream inputStream, String env, Properties props)
SqlSessionFactory build(Configuration config)Los primeros cuatro métodos son los más comunes, dado que reciben una instancia de InputStream que referencia a un documento XML, o más específicamente, al fichero SqlMapConfig.xml comentado anteriormente. Los parámetros opcionales son environment y properties. Environment determina qué entorno cargar, incluyendo el datasource y el gestor de transacciones. Por ejemplo:<environments default="development">
  <environment id="development">
    <transactionManager type="JDBC">
        ...
    <dataSource type="POOLED">
        ...
  </environment>
  <environment id="production">
    <transactionManager type="MANAGED">
        ...
    <dataSource type="JNDI">
        ...
  </environment>
</environments>Si llamas al método build que recibe el parámetro environment, entonces MyBatis usará la configuración de dicho entorno. Por supuesto, si especificas un entorno inválido, recibirás un error. Si llamas a alguno de los métodos que no reciben el parámetro environment, entonces se utilizará el entorno por defecto (que es el especificado como default=”development” en el ejemplo anterior).Si llamas a un método que recibe una instancia de properties, MyBatis cargará dichas properties y las hará accesibles desde tu configuración. Estas propiedades pueden usarse en lugar de la gran mayoría de los valores utilizando al sintaxis: ${propName}Recuerda que las propiedades pueden también referenciarse desde el fichero SqlMapConfig.xml, o especificarse directamente en él. Por lo tanto es importante conocer las prioridades. Lo mencionamos anteriormente en este documento, pero lo volvemos a mencionar para facilitar la referencia.hrSi una propiedad existe en más de un lugar, MyBatis la carga en el siguiente orden:Las propiedades especificadas en el cuerpo del elemento properties se cargan al principio.Las propiedades cargadas desde los atributos resource/url del elemento properties se leen a continuación, y sobrescriben cualquier propiedad duplicada que hubiera sido cargada anteriormente.Las propiedades pasadas como argumento se leen al final, y sobrescriben cualquier propiedad duplicada que hubiera sido cargada anteriormente.Por lo tanto la prioridad mayor es la de las propiedades pasadas como parámetro, seguidas por las especificadas en el atributo resource/url y finalmente las propiedades especificadas en el cuerpo del elemento properties.Por tanto, para resumir, los primeros cuatro métodos son casi iguales pero te permiten opcionalmente especificar el environment y/o las propiedades. Aquí hay un ejemplo de cómo se construye un SqlSessionFactory desde un fichero mybatis-config.xml.String  = "org/mybatis/builder/mybatis-config.xml";
InputStream  = Resources.getResourceAsStream(resource);
SqlSessionFactoryBuilder  = new SqlSessionFactoryBuilder();
SqlSessionFactory  = builder.build(inputStream);Observa que estamos usando la clase de utilidad Resources, que está ubicada en el paquete org.mybatis.io. La clase Resources, tal y como su nombre indica, te ayuda a cargar recursos desde el classpath, el sistema de ficheros o desde una web o URL. Con un vistazo rápido al código fuente en tu IDE descubrirás un conjunto bastante obvio de métodos. Rápidamente:URL getResourceURL(String resource)
URL getResourceURL(ClassLoader loader, String resource)
InputStream getResourceAsStream(String resource)
InputStream getResourceAsStream(ClassLoader loader, String resource)
Properties getResourceAsProperties(String resource)
Properties getResourceAsProperties(ClassLoader loader, String resource)
Reader getResourceAsReader(String resource)
Reader getResourceAsReader(ClassLoader loader, String resource)
File getResourceAsFile(String resource)
File getResourceAsFile(ClassLoader loader, String resource)
InputStream getUrlAsStream(String urlString)
Reader getUrlAsReader(String urlString)
Properties getUrlAsProperties(String urlString)
Class classForName(String className)El último método build() recibe una instancia de Configuration. La clase Configuration contiene todo lo que posiblemente necesites conocer de la instancia de SqlSessionFactory. La clase Configuración es útil para investigar la configuración, incluido añadir o modificar SQL maps (no es recomendable una vez la aplicación ha comenzado a aceptar peticiones). La clase Configuration tiene todas las opciones de configuración que hemos visto ya pero expuestas como una API Java. A continuación se muestra un ejemplo simple de cómo instanciar manualmente un objeto Configuration y pasarlo al método build() para crear un SqlSessionFactory.DataSource dataSource = BaseDataTest.createBlogDataSource();
TransactionFactory transactionFactory = new JdbcTransactionFactory();

Environment environment = new Environment("development", transactionFactory, dataSource);

Configuration configuration = new Configuration(environment);
configuration.setLazyLoadingEnabled(true);
configuration.setEnhancementEnabled(true);
configuration.getTypeAliasRegistry().registerAlias(Blog.class);
configuration.getTypeAliasRegistry().registerAlias(Post.class);
configuration.getTypeAliasRegistry().registerAlias(Author.class);
configuration.addMapper(BoundBlogMapper.class);
configuration.addMapper(BoundAuthorMapper.class);

SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
SqlSessionFactory factory = builder.build(configuration);Ahora tienes un SqlSessionFactory, que puede utilizarse para crear interfaces SqlSession.SqlSessionFactorySqlSessionFactory tiene seis métodos que se usan para crear instancias de SqlSession. En general, las decisiones que deberás tomar cuando tengas qué elegir de entre alguno de estos métodos son:: ¿Quieres usar un ámbito transaccional para esta sesión o utilizar auto-commit (lo cual equivale a no usar transacción en la mayoría de las bases de datos y/o JDBC drivers)?: ¿Quieres que MyBatis obtenga una conexión de un datasource o quieres proporcionar tu propia conexión?Execution: ¿Quieres que MyBatis reúse PreparedStatements y/o haga batch updates (incluyendo inserts y deletes)?El conjunto de métodos sobrecargados openSession te permiten seleccionar una combinación de estas opciones que tenga sentido.SqlSession openSession()
SqlSession openSession(boolean autoCommit)
SqlSession openSession(Connection connection)
SqlSession openSession(TransactionIsolationLevel level)
SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level)
SqlSession openSession(ExecutorType execType)
SqlSession openSession(ExecutorType execType, boolean autoCommit)
SqlSession openSession(ExecutorType execType, Connection connection)
Configuration getConfiguration();El método openSession() por defecto que recibe parámetros crea una SqlSession con las siguientes características:Se arranca una transacción (NO auto-commit)Se obtiene una conexión de una instancia de DataSource configurada en el environment activo.El nivel de aislamiento transaccional será el que la base de datos tenga establecido por defecto.No se reusaran PreparedStatements y no se realizarán actualizaciones batch.La mayoría de los métodos son auto explicativos. Para habilitar el auto-commit, pasa el valor “true” al parámetro opcional autoCommit. Para proporcionar tu propia conexión pasa una instancia de conexión al parámetro conexión. Ten en cuenta que no hay método para proporcionar tanto la conexión como el auto-commit porque MyBatis utilizará las opciones que esté usando actualmente la conexión suministrada. MyBatis usa una enumeration para indicar los niveles de aislamiento denominado TransactionIsolationLevel, pero funcionan como se espera de ellos y tiene los 5 niveles soportados por JDBC (NONE, READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE).El único parámetro que puede ser nuevo para ti es el ExecutorType. Esta enumeración define tres valores:ExecutorType.SIMPLE: Este tipo de executor no hace nada en especial. Crea un PreparedStatement para cada sentencia a ejecutar.ExecutorType.REUSE: Este tipo de executor reusará PreparedStatements.ExecutorType.BATCH: Este executor hará batch de todos las sentencias de actualización. Hay un método más del SqlSessionFactory que no hemos mencionado y es getConfiguration().  Este método devuelve una instancia de Configuration que puedes usar para introspeccionar la configuración de MyBatis en tiempo de ejecución. Si has usado una versión anterior de MyBatis recordarás que las sesiones, transacciones y batches eran cosas separadas. Esto ya no es así, todas ellas están contenidas en el interfaz SqlSession. No tienes que gestionar las transacciones o los batches de forma separada para obtener todo su potencial.SqlSessionComo hemos comentado anteriormente, la instancia de SqlSession es la clase más potente de MyBatis. Es donde encontrarás todos los métodos para ejecutar sentencias, hacer commit o rollback de transacciones y obtener mappers.Hay más de veinte métodos en la clase SqlSession, así que vayamos dividiéndolos en grupo fáciles de digerir.h5Métodos de ejecución de sentenciasEstos métodos se usan para ejecutar las sentencias SELECT, INSERT, UPDATE y DELETE que se hayan definido en los ficheros xml de mapeo SQL. Son bastante auto explicativos, cada uno recibe el ID del statement y el objeto de parámetro, que puede ser una primitiva, un JavaBean, un POJO o un Map.<T> T selectOne(String statement, Object parameter)
<E> List<E> selectList(String statement, Object parameter)
<T> Cursor<T> selectCursor(String statement, Object parameter)
<K,V> Map<K,V> selectMap(String statement, Object parameter, String mapKey)
int insert(String statement, Object parameter)
int update(String statement, Object parameter)
int delete(String statement, Object parameter)La diferencia entre selectOne y selectList es que selectOne debe devolver sólo un objeto. Si hay más de uno se lanzará una excepción. Si no hay ninguno se devolverá null. Si no sabes cuantos objetos esperas recibir, usa selectList. Si quieres comprobar la existencia de un objeto sería mejor que devuelvas un count(). SelectMap es un caso especial diseñado para convertir una lista de resultados en un Map basado en las propiedades de los objetos recibidos. Como no todas las sentencias requieren un parámetro, estos métodos han sido sobrecargados de forma que se proporcionan versiones que no reciben el parámetro objeto.El valor devuelto por los métodos insert, update and delete indica el número de filas afectadas por la sentencia.<T> T selectOne(String statement)
<E> List<E> selectList(String statement)
<T> Cursor<T> selectCursor(String statement)
<K,V> Map<K,V> selectMap(String statement, String mapKey)
int insert(String statement)
int update(String statement)
int delete(String statement)try (Cursor<MyEntity> entities = session.selectCursor(statement, param)) {
   for (MyEntity entity:entities) {
      // process one entity
   }
}Finalmente hay tres versiones avanzadas de los métodos select que te permiten restringir el rango de filas devueltas, o proporcionar lógica de tratamiento de resultados personalizada, normalmente para grandes cantidades de datos.<E> List<E> selectList (String statement, Object parameter, RowBounds rowBounds)
<T> Cursor<T> selectCursor(String statement, Object parameter, RowBounds rowBounds)
<K,V> Map<K,V> selectMap(String statement, Object parameter, String mapKey, RowBounds rowbounds)
void select (String statement, Object parameter, ResultHandler<T> handler)
void select (String statement, Object parameter, RowBounds rowBounds, ResultHandler<T> handler)El parámetro RowBounds hace que MyBatis salte los registros especificados y que limite los resultados devueltos a cierto número. La clase RowBounds tiene un constructor que recibe ambos el offset y el limit, y es inmutable.int offset = 100;
int limit = 25;
RowBounds rowBounds = new RowBounds(offset, limit);El rendimiento de algunos drivers puede variar mucho en este aspecto. Para un rendimiento optimo, usa tipos de ResultSet SCROLL_SENSITIVE o SCROLL_INSENSITIVE (es decir, no FORWARD_ONLY)El parámetro ResultHandler te permite manejar cada fila como tú quieras. Puedes añadirla a una lista, crear un Map, un Set, o descartar cada resultado y guardar solo cálculos. Puedes hacer casi todo lo que quieras con un ResultHandler, de hecho, es lo que MyBatis usa internamente para construir listas de ResultSets.Since 3.4.6, ResultHandler passed to a CALLABLE statement is used on every REFCURSOR output parameter of the stored procedure if there is any.La interfaz es muy sencilla:package org.apache.ibatis.session;
public interface ResultHandler<T> {
  void handleResult(ResultContext<? extends T> context);
}El parámetro ResultContext te da acceso al objeto resultado en sí mismo, un contador del número de objetos creados y un método booleano stop() que te permite indicar a MyBatis que pare la carga de datos.Using a ResultHandler has two limitations that you should be aware of:Data got from an method called with a ResultHandler will not be cached.When using advanced resultmaps MyBatis will probably require several rows to build an object. If a ResultHandler is used you may be given an object whose associations or collections are not yet filled.Batch update statement Flush MethodThere is method for flushing(executing) batch update statements that stored in a JDBC driver class at any timing. This method can be used when you use the  as List<BatchResult> flushStatements()transaction-control-methodsMétodos de control de transacciónvoid commit()
void commit(boolean force)
void rollback()
void rollback(boolean force)Por defecto MyBatis no hace un commit a no ser que haya detectado que la base de datos ha sido modificada por una insert, update, delete o select con  habilitado. Si has realizado cambios sin llamar a estos métodos, entonces puedes pasar true en al método de commit() y rollback() para asegurar que se realiza el commit (ten en cuenta que aun así no puedes forzar el commit() en modo auto-commit o cuando se usa un gestor de transacciones externo). La mayoría de las veces no tendrás que llamar a rollback() dado que MyBatis lo hará por ti en caso de que no hayas llamado a commit(). Sin embargo, si necesitas un control más fino sobre la sesión, donde puede que haya varios commits, tienes esta opción para hacerlo posible. MyBatis-Spring y MyBatis-Guice proporcionan gestión de transacción declarativa. Por tanto si estás usando MyBatis con Spring o Guice consulta sus manuales específicos.Local CacheMyBatis utliza dos cachés: la caché local y la caché de segundo nivel.Cada vez que se crea una sesión MyBatis crea una cache local y la asocia a dicha sesión. Cualquier query que se ejecute en la sesión será cacheada de forma que si en el futuro se vuelve a lanzar la misma query con los mismos parámetros de entrada los datos se obtendrán de la caché y no se accederá a la base de datos. La caché local se vacía cuando se ejecuta cupdate, commit, rollback y close.Por defecto la cache local se utiliza durante toda la duración de la sesión. Esta cache es necesaria para resolver dependencias circulares y para acelerar consultas anidadas repetidas asi que no puede desactivarse, pero puede configurarse para que se utilize sólo durante la duración de la ejecución de una sentencia infomando el parámetro de configuración localCacheScope=STATEMENT.Cuando localCacheScope está informado a SESSION (valor por defecto) MyBatis devuelve referencias a objetos objetos almacenados en la caché. Cualquier modificación de un objeto (listas etc.) influye en el contenido de la caché y en los valores que serán retornados posteriormente durante la existencia de la sessión. Por lo tanto, como mejor práctica, evita modificaciones sobre los objetos devueltos por MyBatis.Puedes borrar el contenido de la caché local en el momento que desees invocando:void clearCache()Asegurarse de que la SqlSession se cierravoid close()El punto más importante del que debes asegurarte es que cierras todas las sesiones que abres. La mejor forma de asegurarse es usar el patrón mostrado a continuación:try (SqlSession session = sqlSessionFactory.openSession()) {
    // following 3 lines pseudocod for "doing some work"
    session.insert(...);
    session.update(...);
    session.delete(...);
    session.commit();
} Al igual que con SqlSessionFactory, puedes obtener la instancia de Configuration que está usando al SqlSession llamando al método getConfiguration().Configuration getConfiguration()Uso de Mappers<T> T getMapper(Class<T> type)Aunque los métodos insert, update, delete y select son potentes, también son muy verbosos, no hay seguridad de tipos (type safety) y no son tan apropiados para tu IDE o tus pruebas unitarias como pudieran ser. Ya hemos visto un ejemplo de uso de mappers en la sección de primeros pasos.Por lo tanto, una forma más común de ejecutar mapped statements es utilizar clases Mapper. Un mapper es simplemente una interfaz con definiciones de métodos que se hacen encajar con métodos de SqlSession. El ejemplo siguiente demuestra algunas firmas de método y como se asignan a una SqlSession.public interface AuthorMapper {
  // (Author) selectOne("selectAuthor",5);
  Author selectAuthor(int id);
  // (List<Author>) selectList(“selectAuthors”)
  List<Author> selectAuthors();
  // (Map<Integer,Author>) selectMap("selectAuthors", "id")
  @MapKey("id")
  Map<Integer, Author> selectAuthors();
  // insert("insertAuthor", author)
  int insertAuthor(Author author);
  // updateAuthor("updateAuthor", author)
  int updateAuthor(Author author);
  // delete("deleteAuthor",5)
  int deleteAuthor(int id);
}En resumen, cada firma de método de mapper se asigna al método de la SqlSession al que está asociado pero sin parámetro ID. En su lugar el nombre del método debe ser el mismo que el ID del mapped statement.Además, el tipo devuelto debe ser igual que el result type del mapped statement. Todos los tipos habituales se soportan, incluyendo primitivas, mapas, POJOs y JavaBeans. Los mappers no necesitan implementar ninguna interfaz o extender ninguna clase. Sólo es necesario que la firma de método pueda usarse para identificar unívocamente el mapped statement correspondiente. Los mappers pueden extender otras interfaces. Asegúrate que tienes tus statements en los namespaces adecuados en tu fichero XML. Además, la única limitación es que no puedes tener el mismo método, con la misma firma, en dos interfaces de la jerarquía (una mala idea en cualquier caso).Puedes pasar más de un parámetro a un método de un mapper. Si lo haces, se usará como nombre el literal "param" seguido de su posición en la lista de parámetros, por ejemplo:  #{param1}, #{param2} etc. Si quieres cambiar su nombre (solo en caso de parámetros múltiples) puedes usar la notación @Param(“paramName”).También puedes pasar una instancia de RowBounds al método para limitar los resultados.Anotaciones de mappersDesde sus comienzos, MyBatis ha sido siempre un framework XML. La configuración se basa en XML y los mapped statements se definen en XML. Con MyBatis 3, hay más opciones. MyBatis 3 se ha desarrollado sobre una exhaustiva y potente API de configuración Java. Este API es el fundamento de la configuración basada en XML y también de la nueva configuración basada en anotaciones. Las anotaciones simplemente ofrecen una forma más sencilla de implementar los mapped statements sin introducir un montón de sobrecarga. Las anotaciones Java son desafortunadamente muy  limitadas en su flexibilidad y expresividad. A pesar de haber dedicado mucho tiempo a la investigación, diseño y pruebas, los mapeos más potentes de MyBatis simplemente no es posible construirlos con anotaciones. Los atributos C# (por ejemplo) no sufren de las mismas limitaciones y por tanto MyBatis.NET podrá construir una alternativa mucho más rica al XML. Dicho esto, la configuración basada en anotaciones Java también tiene sus ventajas.Las anotaciones son las siguientes:AnotaciónTargetXML equivalente@CacheNamespaceClass<cache>Configura la cache para un namespace (una clase). Atributos: implementation, eviction, flushInterval, size, readWrite, blocking and properties.@PropertyN/A<property>mybatis-config.xmlSpecifies the property value or placeholder(can replace by configuration properties that defined at the ). Attributes: . (Available on MyBatis 3.4.2+)@CacheNamespaceRef<cacheRef>
          Referencia una cache de otro namespace. Note that caches declared in an XML mapper file are considered a separate namespace, even if they share the same FQCN. Atributos: .
          If you use this annotation, you should be specified either  attribute.
          For the  attribute specify a java type indicating the namespace(the namespace name become a FQCN of specified java type),
          and for the  attribute(this attribute is available since 3.4.2) specify a name indicating the namespace.
        @ConstructorArgsMethod<constructor>Agrupa un conjunto de resultados que serán pasados al constructor de un objeto de resultado. Atributos: value, que es un array de Args.@Arg<arg><idArg>Un argumento que es parte de un  ConstructorArgs.  Atributos:  id, column, javaType, jdbcType, typeHandler, select and resultMap.  El atributo id es un valor booleano que identifica la propiedad que será usada en las comparaciones, parecido al elemento XML <idArg>. Since 3.5.4, it can be used as repeatable annotation.@TypeDiscriminator<discriminator>Un grupo de clases que se pueden usar para determinar que mapeo de resultados realizar. Atributos:  column, javaType, jdbcType, typeHandler, cases.  El atributo cases es un array de Cases.@Case<case>Un caso concreto y su mapeo correspondiente. Atributos: value, type, results.  El atributo results es un array de Results, por tanto esta anotación Case es similar a un ResultMap, que se especifica mediante la anotación Results a continuación.@Results<resultMap>Una lista de  Result mapping que contiene los detalles de cómo una columna particular se mapea a una propiedad o campo. Atributos: value, id. El atributo value es un array de anotaciones Result. The id attribute is the name of the result mapping.@Result<result><id>Un result mapping entre una columna y una propiedad o campo. Atributos: :  id, column, property, javaType, jdbcType, typeHandler, one, many.  El atributo id es un valor booleano que indica que la propiedad debe usarse en comparaciones (similar al <id> de los mapeos XML). El atributo one sirve para asociaciones de simples, similar al <association>, y el atributo many es para colecciones, similar al <collection>. Sus denominaciones son tales para evitar conflictos con nombres de clases. Since 3.5.4, it can be used as repeatable annotation.@One<association>
        Un mapeo a una propiedad que contiene un tipo complejo. Atributos: select, que contiene el nombre completamente cualificado de un mapped statement (o un método de mapper) que puede cargar la instancia del tipo indicado.
        , que sobrescribe el parámetro global de configuración  para este mapeo.
        (available since 3.5.5), which is the fully qualified name of a result map that map to a single container object from select result.
        (available since 3.5.5), which is column prefix for grouping select columns at nested result map.
        Nota: Habrás visto que el mapeo de tipo join no se soporta mediante el API de anotaciones. Esto es debido a las limitaciones de las anotaciones en Java que no permiten referencias circulares.@Many<collection>Un mapeo a una propiedad que contiene una colección de tipos complejos. Atributos: select, que contiene el nombre completamente cualificado de un mapped statement (o un método de mapper) que puede cargar la instancia del tipo indicado.
        (available since 3.5.5), which is the fully qualified name of a result map that map to collection object from select result.
        @MapKeySe usa en métodos cuyo tipo de retorno es Map. Se usa para convertir una Lista de objetos de resultado a un Map basándose en una propiedad de dichos objetos.@OptionsAttributes of mapped statements.DatabaseIdProviderOptionsbr
          Esta anotación proporciona acceso a un gran conjunto de opciones de configuración que normalmente aparecen como atributos en los mapped statements.
          En lugar de complicar cada anotación existente la anotación Options proporciona una forma sencilla y concisa de acceder a estas opciones.
          Atributos: useCache=true, flushCache=FlushCachePolicy.DEFAULT, resultSetType=DEFAULT, statementType=PREPARED, fetchSize=-1, timeout=-1, useGeneratedKeys=false, keyProperty=“”, keyColumn=“”, resultSets=“”, databaseId="".
          Es importante comprender que las anotaciones en Java no permiten indicar un valor nulo.
          Por lo tanto, cuando usas la anotación Options el statement usará todos los valores por defecto.
          Presta atención a estos valores pro defecto para evitar comportamientos inesperados.
          The (Available since 3.5.5), in case there is a configured ,
          the MyBatis use the  with no  attribute or with a 
          that matches the current one. If found with and without the  the latter will be discarded.

          La keyColumn solo se requiere para algunas bases de datos (como PostgreSQL) cuando la columna no es la primera columna de la tabla.
        @Insert@Update@Delete@Select<insert><update><delete><select>
          Cada una de estas anotaciones representa el SQL que debe ejecutarse. Cada una de ellas recibe un array de strings (o un solo string).
          Si se pasa un array de strings, todos ellos se concatenarán introduciendo un espacio en blanco entre ellos.
          Esto ayuda a evitar el problema “falta un espacio en blanco” al construir SQL en código Java. Sin embargo, también puedes concatenarlos en un solo string si lo prefieres.
          Atributos: value, que es el array de String para formar una única sentencia SQL.
          The ,
          the MyBatis use a statement with no  the latter will be discarded.
        @InsertProvider@UpdateProvider@DeleteProviderCharSequenceStringProviderMethodResolverEstas anotaciones SQL alternativas te permiten especificar un nombre de clases y un método que devolverán la SQL que debe ejecutarse (Since 3.4.6, you can specify the  instead of  as a method return type).
          Cuando se ejecute el método MyBatis instanciará la clase y ejecutará el método especificados en el provider. You can pass objects that passed to arguments of a mapper method, "Mapper interface type", "Mapper method" and "Database ID"
          via the (available since MyBatis 3.4.5 or later) as method argument.(In MyBatis 3.4 or later, it's allow multiple parameters)
          Atributos: value, type y method.
          El atributo value y type es el nombre completamente cualificado de una clase
          (The  attribute is alias for , you must be specify either one.
          But both attributes can be omit when specify the  as global configuration).
          El method es el nombre un método de dicha clase
          (Since 3.5.1, you can omit  attribute, the MyBatis will resolve a target method via the
           interface.
          If not resolve by it, the MyBatis use the reserved fallback method that named ).
          The ,
          the MyBatis will use a provider method with no  the latter will be discarded.

          Nota: A continuación hay una sección sobre la clase, que puede ayudar a construir SQL dinámico de una forma más clara y sencilla de leer.@ParamParameterSi tu mapper recibe parámetros múltiples, esta anotación puede aplicarse a cada parámetro para proporcionarle un nombre. En caso contrario, los parámetros múltiples se nombrarán según su posición (sin incluir el parámetro RowBounds), prefijados con "param". Por ejemplo:  #{param1}, #{param2} etc. es el defecto.  Con @Param(“persona”), el parámetro se llamará #{persona}.@SelectKey<selectKey>
          Esta anotación es igual que la <selectKey> para métodos anotados con @Insert, @InsertProvider, @Update o @UpdateProvider.
          Se ignora en otros métodos. Si especificas la anotación @SelectKey, entonces MyBatis ignorará todas las propiedades de generación de claves proporcionadas por la anotación @Options, o mediante propiedades de configuración.
          Atributos: statement un array de strings que contienen la SQL a ejecutar, keyProperty que es la propiedad del objeto parámetro que se actualizará con el Nuevo valor,
          before que debe valer true o false para indicar si la sentencia SQL debe ejecutarse antes o después de la insert, resultType que es el tipo de la propiedad keyProperty, y statementType=PREPARED.
          The ,
          the MyBatis will use a statement with no @ResultMapEsta anotación se usa para proporcionar el id de un elemento <resultMap> en un mapper XML a una anotación @Select o @SelectProvider. Esto permite a las selects anotadas reusar resultmaps definidas en XML. Esta anotación sobrescribe las anotaciones @Result o @ConstructorArgs en caso de que se hayan especificado en la select anotada.@ResultTypeEsta anotación se usa cuando se utiliza un result handler. En ese caso, el tipo devuelto por el método es void y
        MyBatis no puede determinar el tipo del objeto que debe construir para cada fila.
        Si hay un result map XML entonces se utiliza la anotación @ResultMap. Si el tipo de retorno se especifica en el
        elemento  del XML entonces no es necesaria ninguna otra anotación.
        En el resto de casos, usa esta anotación. Por ejemplo en un método anotado con @Select con un result handler
        el valor de retorno será void y por tanto se requiere incluir esta anotación (o @ResultMap).
        La anotación se ignora si el tipo devuelto por el méotdo no es void.@FlushSqlSession#flushStatements()If this annotation is used, it can be called the  via method defined at a Mapper interface.(MyBatis 3.3 or above)Ejemplos de mappers anotadosEste ejemplo muestra como se usa la anotación @SelectKey para obtener un valor de una secuencia antes de de una insert:int.class@Insert("insert into table3 (id, name) values(#{nameId}, #{name})")
@SelectKey(statement="call next value for TestSequence", keyProperty="nameId", before=, resultType=)
 insertTable3(Name name);Este ejemplo muestra como se usa la anotación @SelectKey para obtener el valor de una identity después de una insert:@Insert("insert into table2 (name) values(#{name})")
@SelectKey(statement="call identity()", keyProperty="nameId", before= insertTable2(Name name);This example shows using the  annotation to call the @Flush
List<BatchResult> flush();These examples show how to name a ResultMap by specifying id attribute of @Results annotation.@Results(id = "userResult", value = {
  @Result(property = "id", column = "uid", id = ),
  @Result(property = "firstName", column = "first_name"),
  @Result(property = "lastName", column = "last_name")
})
@Select("select * from users where id = #{id}")
User getUserById(Integer id);

@Results(id = "companyResults")
@ConstructorArgs({
  @Arg(column = "cid", javaType = Integer.class, id = ),
  @Arg(column = "name", javaType = String.class)
})
@Select("select * from company where id = #{id}")
Company getCompanyById(Integer id);This example shows solo parameter using the Sql Provider annotation:@SelectProvider(type = UserSqlBuilder.class, method = "buildGetUsersByName")
List<User> getUsersByName(String name);

class UserSqlBuilder {
  public static String buildGetUsersByName(final String name) {
    return new SQL(){{
      SELECT("*");
      FROM("users");
      if (name != null) {
        WHERE("name like #{value} || '%'");
      }
      ORDER_BY("id");
    }}.toString();
  }
}This example shows multiple parameters using the Sql Provider annotation:@SelectProvider(type = UserSqlBuilder.class, method = "buildGetUsersByName")
List<User> getUsersByName(
    @Param("name") String name, @Param("orderByColumn") String orderByColumn);

class UserSqlBuilder {

  // If not use @Param, you should be define same arguments with mapper method
  public static String buildGetUsersByName(
      final String name, final String orderByColumn) {
    return new SQL(){{
      SELECT("*");
      FROM("users");
      WHERE("name like #{name} || '%'");
      ORDER_BY(orderByColumn);
    }}.toString();
  }

  // If use @Param, you can define only arguments to be used
  public static String buildGetUsersByName(@Param("orderByColumn") final String orderByColumn) {
    return new SQL(){{
      SELECT("*");
      FROM("users");
      WHERE("name like #{name} || '%'");
      ORDER_BY(orderByColumn);
    }}.toString();
  }
}This example shows usage the default implementation of (available since MyBatis 3.5.1 or later):@SelectProvider(type = UserSqlProvider.class)
List<User> getUsersByName(String name);

// Implements the ProviderMethodResolver on your provider class
class UserSqlProvider implements ProviderMethodResolver {
  // In default implementation, it will resolve a method that method name is matched with mapper method
  public static String getUsersByName(final String name) {
    return new SQL(){{
      SELECT("*");
      FROM("users");
      if (name != null) {
        WHERE("name like #{value} || '%'");
      }
      ORDER_BY("id");
    }}.toString();
  }
}This example shows usage that share an sql provider class to all mapper methods using global configuration(Available since 3.5.6):
Configuration configuration = new Configuration();
configuration.setDefaultSqlProviderType(TemplateFilePathProvider.class); // Specify an sql provider class for sharing on all mapper methods
// ...
// Can omit the type/value attribute on sql provider annotation
// If omit it, the MyBatis apply the class that specified on defaultSqlProviderType.
public interface UserMapper {

  @SelectProvider // Same with @SelectProvider(TemplateFilePathProvider.class)
  User findUser(int id);

  @InsertProvider // Same with @InsertProvider(TemplateFilePathProvider.class)
  void createUser(User user);

  @UpdateProvider // Same with @UpdateProvider(TemplateFilePathProvider.class)
  void updateUser(User user);

  @DeleteProvider // Same with @DeleteProvider(TemplateFilePathProvider.class)
  void deleteUser(int id);
}@SelectProvider(UserSqlProvider.class)
List<User> getUsersByName(String name);

// Implements the ProviderMethodResolver on your provider class
class UserSqlProvider implements ProviderMethodResolver {
  // In default implementation, it will resolve a method that method name is matched with mapper method
  public static String getUsersByName(final String name) {
    return new SQL(){{
      SELECT("*");
      FROM("users");
      if (name != null) {
        WHERE("name like #{value} || '%'");
      }
      ORDER_BY("id");
    }}.toString();
  }
}This example shows usage the  attribute on the statement annotation(Available since 3.5.5):
@Select(value = "SELECT SYS_GUID() FROM dual", databaseId = "oracle") // Use this statement if DatabaseIdProvider provide "oracle"
@Select(value = "SELECT uuid_generate_v4()", databaseId = "postgres") // Use this statement if DatabaseIdProvider provide "postgres"
@Select("SELECT RANDOM_UUID()") // Use this statement if the DatabaseIdProvider not configured or not matches databaseId
String generateId();
/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/es/xdoc/sqlmap-xml.xmlMyBatis 3 | Ficheros XML de mapeoFicheros XML de mapeoLa potencia de MyBatis reside en los Mapped Statements. Aquí es donde está la magia. Para lo potentes que son, los ficheros XML de mapeo son relativamente simples. Sin duda, si los comparas con el código JDBC equivalente comprobarás que ahorras el 95% del código.
      Los ficheros XML de mapeos SQL solo tienen unos pocos elementos de alto nivel (en el orden en el que deberían definirse):
      
          – Configuración de la caché para un namespace.
        
          – Referencia a la caché de otro namespace.
        
          – El elemento más complejo y potente que describe como cargar tus objetos a partir de los ResultSets.
        strike
            – Deprecada!  Antigua forma de mapear parámetros. Se recomienda el uso de parámetros en línea. Este elemento puede ser eliminado en futuras versiones. No se ha documentado en este manual.
          
          – Un trozo de SQL reusable que puede utilizarse en otras sentencias.
        insert
          – Una sentencia INSERT.
        
          – A Una sentencia UPDATE.
        delete
          – Una sentencia DELETE.
        
          – Una sentencia SELECT.
        Las siguientes secciones describen estos elementos en detalle, comenzando con los propios elementos.
      El select statement es uno de los elementos que más utilizarás en MyBatis. No es demasiado útil almacenar datos en la base de datos si no puedes leerlos, de hecho las aplicaciones suelen leer bastantes más datos de los que modifican. Por cada insert, update o delete posiblemente haya varias selects. Este es uno de los principios básicos de MyBatis y la razón por la que se ha puesto tanto esfuerzo en las consultas y el mapeo de resultados. El select statement es bastante simple para los casos simples. Por ejemplo:
        <select id="selectPerson" parameterType="int" resultType="hashmap">
  SELECT * FROM PERSON WHERE ID = #{id}
</select>Esta sentencia se llama “selectPerson”, recibe un parámetro de tipo in (o Integer), y devuelve una HashMap usando los nombres de columna como clave y los valores del registro como valores.
        
          Observa la notación utilizada para los parámetros:
        #{id}Esto le indica a MyBatis que cree un parámetro de PreparedStatement. Con JDBC, ese parámetro iría identificado con una “?” en la select que se le pasa al PreparedStatement, algo así:
        // Código JDBC similar, NO MyBatis…
String selectPerson = "SELECT * FROM PERSON WHERE ID=?";
PreparedStatement ps = conn.prepareStatement(selectPerson);
ps.setInt(1,id);JDBC requiere mucho más código para extraer los resultados y mapearlos a una instancia de un objetos, que es precisamente lo que MyBatis evita que tengas que hacer. Aun queda mucho por conocer sobre los parámetros y el mapeo de resultados. Todos sus detalles merecen su propio capítulo, y serán tratados más adelante.
        El select statement tiene más atributos que te permiten configurar como debe comportarse cada select statement.<select
  id="selectPerson"
  parameterType="int"
  parameterMap="deprecated"
  resultType="hashmap"
  resultMap="personResultMap"
  flushCache="false"
  useCache="true"
  timeout="10"
  fetchSize="256"
  statementType="PREPARED"
  resultSetType="FORWARD_ONLY">captionAtributos de SelectAtributoUn identificador único dentro del namespace que se utiliza para identificar el statement.El nombre completamente cualificado de la clase o el alias del parámetro que se pasará al statement.
              Este atributo es opcional porque MyBatis puede calcular el TypeHandler a utlizar a partir del parametro actual usado en la invocación al statement.
              Por defecto: no informado.Este es un atributo obsoleto que permite referenciar a un elemento parameterMap externo. Se recomienda utilizar mapeos en línea (in-line) y el atributo parameterType.
                El nombre completamente cualificado o el alias del tipo de retorno de este statement. Ten en cuenta que en el caso de las colecciones el parámetro debe ser el tipo contenido en la colección, no el propio tipo de la colección. Puedes utilizar resultType o resultMap, pero no ambos.
              Una referencia una un resultMap externo. Los resultMaps son la característica más potente de MyBatis, con un conocimiento detallado de los mismos, se pueden resolver muchos casos complejos de mapeos. Puedes utilizar resultMap O resultType, pero no ambos.
              Informar esta propiedad a true hará que la cache local y la de segundo nivel se vacíen cada vez que se llame a este statement. Por defecto es false para select statements.
              Informar esta propiedad a true hará que los resultados de la ejecución de este statement se cacheen en la caché de segundo nivel. Por defecto es true para las select statements.
              Establece el número de segundos que el driver esperará a que la base de datos le devuelva una respuesta antes de lanzar una excepción. Por defecto: no informado (depende del driver de base de datos).
              Este es un atributo que “sugiere” al driver que devuelva los resultados en bloques de filas en el número indicado por el parámetro. Por defecto: no informado (depende del driver de base de datos).
              Puede valer STATEMENT, PREPARED o CALLABLE. Hace que MyBatis use Statement, PreparedStatement o CallableStatement respectivamente.  Por defecto: PREPARED.
              Puede valer FORWARD_ONLY|SCROLL_SENSITIVE|SCROLL_INSENSITIVE|DEFAULT(same as unset).  Por defecto: no informado (depende del driver de base de datos).
              Si hay un DatabaseIdProvider configurado. MyBatis cargará todos los statements sin el atributo 
              o aquellos con un  que coincide con el actual. Si se encuentra un statement con y sin
               el último se descartará.
              De aplicación exclusiva para select anidadas. Si es true, se asume que los resultados anidados están
                agrupados de forma que cuando se lee un nuevo resultado principal nuevo, no habrá más referencias
                a resultados principales anteriores. De esta forma los resultados anidados se rellenarán de
                una manera mucho ás eficiente en términos de memoria. Defecto:
                This is only applicable for multiple result sets. It lists the result sets that will
                be returned by the statement and gives a name to each one. Names are separated by commas.
              ./java-api.html#transaction-control-methodsTransaction Control MethodSet this to true when writing a INSERT, UPDATE or DELETE statement that returns data so that the transaction is controlled properly. Also see . Default:  (since 3.5.12)
              insert, update and deleteinsert_update_and_deleteLos insert, update y delete statements son muy similares en su implementación:<insert
  id="insertAuthor"
  parameterType="domain.blog.Author"
  flushCache="true"
  statementType="PREPARED"
  keyProperty=""
  keyColumn=""
  useGeneratedKeys=""
  timeout="20">

<update
  id="updateAuthor"
  parameterType="domain.blog.Author"
  flushCache="true"
  statementType="PREPARED"
  timeout="20">

<delete
  id="deleteAuthor"
  parameterType="domain.blog.Author"
  flushCache="true"
  statementType="PREPARED"
  timeout="20">Insert, Update and Delete AttributesMétodo deprecado de referirse a un parameterMap externo. Usa mapeos inline y el atributo paramterType.Informar esta propiedad a true hará que la caché se vacíe cada vez que se llame a este statement. Por defecto es false para select statements.
              Establece el número máximo de segundos que el driver esperará a que la base de datos le devuelva una respuesta antes de lanzar una excepción. Por defecto: no informado (depende del driver de base de datos).(solo en insert y update) Indica a MyBatis que utilice el método getGeneratedKeys de JDBC para recuperar las claves autogeneras automáticamente por la base de datos. (ej. campos autoincrementales en SGBD como MySQL o SQL Server).  Por defecto:  false
              (solo en insert y update) Indica la propiedad a la que MyBatis debe asignar la clave autogenerada devuelva por getGeneratedKeys o por un elemento hijo de tipo selectKey. Por defecto: no informado. Puede contener una lista de nombres seperados por comas en el caso de que se esperen varios valores autogenerados.
              (solo en insert y update) Indica el nombre de la columna en tabla con clave generada. Solo se requiere en algunas bases de datos (como PostgreSQL) donde la
              columna clave no es la primera de la tabla. Puede contener una lista de nombres seperados por comas en el caso de que se esperen varios valores autogenerados.
              A continuación se muestran unos ejemplos de insert, update y delete.<insert id="insertAuthor">
  insert into Author (id,username,password,email,bio)
  values (#{id},#{username},#{password},#{email},#{bio})
</insert>

<update id="updateAuthor">
  update Author set
    username = #{username},
    password = #{password},
    email = #{email},
    bio = #{bio}
  where id = #{id}
</update>

<delete id="deleteAuthor">
  delete from Author where id = #{id}
</delete>Tal y como se ha indicado, insert es algo más complejo dado que dispone de algunos atributos extra para gestionar la generación de claves de varias formas distintas.
        
          Primeramente, si tu base de datos soporta la auto-generación de claves (ej. MySQL y SQL Server), entonces puedes simplemente informar el atributo useGeneratedKeys=”true” e informar también en keyProperty el nombre del la propiedad donde guardar el valor y ya has terminado.
Por ejemplo, si la columna id de la tabla Author del ejemplo siguiente fuera autogenerada el insert statement se escribiría de la siguiente forma:
        <insert id="insertAuthor" useGeneratedKeys="true"
    keyProperty="id">
  insert into Author (username,password,email,bio)
  values (#{username},#{password},#{email},#{bio})
</insert>Author
          If your database also supports multi-row insert, you can pass a list or an array of s and retrieve the auto-generated keys.
        <insert id="insertAuthor" useGeneratedKeys="true"
    keyProperty="id">
  insert into Author (username, password, email, bio) values
  <foreach item="item" collection="list" separator=",">
    (#{item.username}, #{item.password}, #{item.email}, #{item.bio})
  </foreach>
</insert>MyBatis puede tratar las claves autogeneradas de otra forma para el caso de las bases de datos que no soportan columnas autogeneradas, o porque su driver JDBC no haya incluido aun dicho soporte.
        A continuación se muestra un ejemplo muy simple que genera un id aleatorio (algo que posiblemente nunca harás pero que demuestra la flexibilidad de MyBatis y cómo MyBatis ignora la forma en la que se consigue la clave):
        <insert id="insertAuthor">
  <selectKey keyProperty="id" resultType="int" order="BEFORE">
    select CAST(RANDOM()*1000000 as INTEGER) a from SYSIBM.SYSDUMMY1
  </selectKey>
  insert into Author
    (id, username, password, email,bio, favourite_section)
  values
    (#{id}, #{username}, #{password}, #{email}, #{bio}, #{favouriteSection,jdbcType=VARCHAR})
</insert>
          En el ejemplo anterior, el selectKey statement se ejecuta primero, la propiedad id de Author se informará y posteriormente se invocará al insert statement. Esto proporciona un comportamiento similar a la generación de claves en base de datos sin complicar el código Java.
        El elemento selectKey tiene el siguiente aspecto:<selectKey
  keyProperty="id"
  resultType="int"
  order="BEFORE"
  statementType="PREPARED">selectKey AttributesAttributeDescriptionLa propiedad destino con la que debe informarse el resultado del selectKey statement. Puede contener una lista de nombres seperados por comas en el caso de que se esperen varios valores autogenerados.
              Los nombres de columnas en el ResultSet que corresponden con las propiedades. Puede contener una lista de nombres seperados por comas en el caso de que se esperen varios valores autogenerados.
              El tipo de retorno. MyBatis puede adivinarlo pero no está de más añadirlo para asegurarse. MyBatis permite usar cualquier tipo simple, incluyendo Strings.
              Puede contener BEFORE o AFTER. Si se informa a BEFORE, entonces la obtención de la clave se realizará primero, se informará el campo indicado en keyProperty y se ejecutará la insert. Si se informa a AFTER se ejecuta primero la insert y después la selectKey – Esto es habitual en bases de datos como Oracle que soportan llamadas embebidas a secuencias dentro de una sentencia insert.
              Al igual que antes, MyBatis soporta sentencias de tipo STATEMENT, PREPARED and CALLABLE que corresponden Statement, PreparedStatement y CallableStatement respectivamente.
              RETURNINGOUTPUT
          As an irregular case, some databases allow INSERT, UPDATE or DELETE statement to return result set (e.g.  clause of PostgreSQL and MariaDB or  clause of MS SQL Server). This type of statement must be written as  to map the returned data.
        <select id="insertAndGetAuthor" resultType="domain.blog.Author"
      affectData="true" flushCache="true">
  insert into Author (username, password, email, bio)
  values (#{username}, #{password}, #{email}, #{bio})
  returning id, username, password, email, bio
</select>Este elemento se utiliza para definir un fragmento reusable de código SQL que puede ser incluido en otras sentencias. It can be statically (during load phase) parametrized. Different property values can
          vary in include instances. Por ejemplo:
        <sql id="userColumns"> ${alias}.id,${alias}.username,${alias}.password </sql>Este fragmento de SQL puede ser incluido en otra sentencia, por ejemplo:
        <select id="selectUsers" resultType="map">
  select
    <include refid="userColumns"><property name="alias" value="t1"/></include>,
    <include refid="userColumns"><property name="alias" value="t2"/></include>
  from some_table t1
    cross join some_table t2
</select>
          Property value can be also used in include refid attribute or property values inside include clause, for example:
        <sql id="sometable">
  ${prefix}Table
</sql>

<sql id="someinclude">
  from
    <include refid="${include_target}"/>
</sql>

<select id="select" resultType="map">
  select
    field1, field2, field3
  <include refid="someinclude">
    <property name="prefix" value="Some"/>
    <property name="include_target" value="sometable"/>
  </include>
</select>ParametersEn todos los statements anteriores se han mostrado ejemplos de parámetros simples. Los parámetros son elementos muy potentes en MyBatis. En los casos simples, probablemente el 90% de los casos, no hay mucho que decir sobre ellos, por ejemplo:
        <select id="selectUsers" resultType="User">
  select id, username, password
  from users
  where id = #{id}
</select>El ejemplo anterior muestra un mapeo muy simple de parámetro con nombre. El atributo parameterType se ha informado a “int”, por lo tanto el nombre del parámetro puede ser cualquiera. Los tipos primitivos y los tipos de datos simples como Integer o String no tienen propiedades relevantes y por tanto el parámetro será reemplazado por su valor. Sin embargo, si pasas un objeto complejo, entonces el comportamiento es distinto. Por ejemplo:
        <insert id="insertUser" parameterType="User">
  insert into users (id, username, password)
  values (#{id}, #{username}, #{password})
</insert>Si se pasa un objeto de tipo User como parámetro en este statement, se buscarán en él las propiedades id, username y password  y sus valores se pasarán como parámetros de un PreparedStatement.
        Esta es una Buena forma de pasar parámetros a statements. Pero los parameter maps (mapas de parámetros) tienen otras muchas características.features of parameter maps.
        Primeramente, es posible especificar un tipo de dato concreto.
        #{property,javaType=int,jdbcType=NUMERIC}Como en otros casos, el tipo de Java (javaType) puede casi siempre obtenerse del objeto recibido como parámetro, salvo si el objeto es un HashMap. En ese caso debe indicarse el javaType para asegurar que se usa el TypeHandler correcto.
         El tipo JDBC es obligatorio para todas las columnas que admiten null cuando se pasa un null como valor. Puedes investigar este tema por tu cuenta leyendo los JavaDocs del método PreparedStatement.setNull().
        Si quieres customizar aun más el tratamiento de tipos de datos, puedes indicar un TypeHandler específico (o un alias), por ejemplo:
        #{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler}Comienza a parecer demasiado verboso, pero lo cierto es que rara vez necesitaras nada de esto.Para los tipos numéricos hay un atributo numericScale que permite especificar cuantas posiciones decimales son relevantes.
        #{height,javaType=double,jdbcType=NUMERIC,numericScale=2}Finalmente, el atributo mode te permite especificar parámetros IN, OUT o INOUT. Si un parámetro es OUT o INOUT, el valor actual de las propiedades del objeto pasado como parámetro será modificado. Si el mode=OUT (o INOUT) y el jdbcType=CURSOR (ej. Oracle REFCURSOR), debes especificar un resultMap para mapear el RestultSet al tipo del parámetro. Ten en cuenta que el atributo javaType es opcional en este caso, dado que se establecerá automáticamente al valor ResultSet en caso de no haberse especificado si el jdbcType es CURSOR.
        #{department, mode=OUT, jdbcType=CURSOR, javaType=ResultSet, resultMap=departmentResultMap}MyBatis también soporta tipos de datos avanzados como los structs, pero en este caso debes indicar in el statement el jdbcTypeName en la declaración del parámetro de tipo OUT.
        #{middleInitial, mode=OUT, jdbcType=STRUCT, jdbcTypeName=MY_TYPE, resultMap=departmentResultMap}A pesar de estas potentes opciones, la mayoría de las veces simplemente debes especificar el nombre de la propiedad y MyBatis adivinará lo demás. A lo sumo, deberás especificar los jdbcTypes para las columnas que admiten nulos.
        #{firstName}
#{middleInitial,jdbcType=VARCHAR}
#{lastName}
          Sustitución de Strings
        
          Por defecto, usar la sintaxis #{} hace que MyBatis genere propiedades de PreparedStatement y que asigne los valores a parámetros de PreparedStatement de forma segura (ej. ?). Aunque esto es más seguro, más rápido y casi siempre la opción adecuada, en algunos casos sólo quieres inyectar un trozo de texto sin modificaciones dentro de la sentencia SQL. Por ejemplo, para el caso de ORDER BY, podrías utilizar algo así:
        ORDER BY ${columnName}
          En este caso MyBatis no alterará el contenido del texto.
        
@Select("select * from user where id = #{id}")
User findById(@Param("id") long id);

@Select("select * from user where name = #{name}")
User findByName(@Param("name") String name);

@Select("select * from user where email = #{email}")
User findByEmail(@Param("email") String email);

// and more "findByXxx" method

@Select("select * from user where ${column} = #{value}")
User findByColumn(@Param("column") String column, @Param("value") String value);
${column}#{value}
User userOfId1 = userMapper.findByColumn("id", 1L);
User userOfNameKid = userMapper.findByColumn("name", "kid");
User userOfEmail = userMapper.findByColumn("email", "noone@nowhere.com");

          String Substitution can be very useful when the metadata(i.e. table name or column name) in the sql statement is dynamic,
          for example, if you want to  from a table by any one of its columns, instead of writing code like:
          
          you can just write:
          
          in which the  will be substituted directly and the  will be "prepared".
          Thus you can just do the same work by:
          
          This idea can be applied to substitute the table name as well.
         No es seguro recoger un texto introducido por el usuario e inyectarlo en una sentencia SQL. Esto permite ataques de inyección de SQL y por tanto debes impedir que estos campos se informen con la entrada del usuario, o realizar tus propias comprobaciones o escapes.
        Result Maps
          El elemento resultMap es el elemento más importante y potente de MyBatis. Te permite eliminar el 90% del código que requiere el JDBC para obtener datos de ResultSets, y en algunos casos incluso te permite hacer cosas que no están siquiera soportadas en JDBC. En realidad, escribir un código equivalente para realizar algo similar a un mapeo para un statement complejo podría requerir cientos de líneas de código. El diseño de los ResultMaps es tal, que los statemets simples no requieren un ResultMap explícito, y los statements más complejos requieren sólo la información imprescindible para describir relaciones.
        Ya has visto algunos ejemplos de un statement sencillo que no requiere un ResultMap explícito. Por ejemplo:
        <select id="selectUsers" resultType="map">
  select id, username, hashedPassword
  from some_table
  where id = #{id}
</select>
          Este statement simplemente obtiene como resultado una HashMap que contiene como claves todas las columnas, tal y como se ha especificado en el atributo resultType. Aunque es muy útil en muchos casos, una HashMap no contribuye a un buen modelo de dominio. Es más probable que tu aplicación use JavaBeans o POJOs (Plain Old Java Objects) para el modelo de dominio. MyBatis soporta ambos. Dado el siguiente JavaBean:
        package com.someapp.model;
public class User {
  private int id;
  private String username;
  private String hashedPassword;

  public int getId() {
    return id;
  }
  public void setId(int id) {
    this.id = id;
  }
  public String getUsername() {
    return username;
  }
  public void setUsername(String username) {
    this.username = username;
  }
  public String getHashedPassword() {
    return hashedPassword;
  }
  public void setHashedPassword(String hashedPassword) {
    this.hashedPassword = hashedPassword;
  }
}
          Basándose en la especificación de JavaBeans, la clase anterior tiene 3 propiedades: ip, username y hashedPassword. Todas ellas coinciden exactamente con los nombres de columna en la sentencia select.
        
          Este JavaBean puede mapearse desde un ResultSet de forma casi tan sencilla como la HashMap.
        <select id="selectUsers" resultType="com.someapp.model.User">
  select id, username, hashedPassword
  from some_table
  where id = #{id}
</select>Y recuerda que los TypeAliases son tus amigos. Úsalos y de esa forma no tendrás que escribir constantemente el nombre totalmente cualificado (fully qualified). Por ejemplo:
        <!-- In Config XML file -->
<typeAlias type="com.someapp.model.User" alias="User"/>

<!-- In SQL Mapping XML file -->
<select id="selectUsers" resultType="User">
  select id, username, hashedPassword
  from some_table
  where id = #{id}
</select>
          En estos casos MyBatis crea automáticamente un RestulMap entre bastidores para mapear las columnas a las propiedades del JavaBean en base a sus nombres. Si los nombres de las columnas no coinciden exactamente, puedes emplear alias en los nombres de columnas de la sentencia SQL (una característica estándar del SQL) para hacer que coincidan. Por ejemplo:
        <select id="selectUsers" resultType="User">
  select
    user_id             as "id",
    user_name           as "userName",
    hashed_password     as "hashedPassword"
  from some_table
  where id = #{id}
</select>
          Lo mejor de los ResultMaps es que ya has aprendido mucho sobre ellos ¡y ni siquiera los has visto! Los casos sencillos no requieren nada más que lo que ya has visto. Solo como ejemplo, veamos qué aspecto tendría el último ejemplo utilizando un ResultMap externo, lo cual es otra forma de solucionar las divergencias entre los nombres de columnas y de propiedades.
        <resultMap id="userResultMap" type="User">
  <id property="id" column="user_id" />
  <result property="username" column="user_name"/>
  <result property="password" column="hashed_password"/>
</resultMap>
          Y el statement que las referencia utiliza para ello el atributo resultMap (fíjate que hemos eliminado el atributo resultType). Por ejemplo:
        <select id="selectUsers" resultMap="userResultMap">
  select user_id, user_name, hashed_password
  from some_table
  where id = #{id}
</select>
          Ojalá todo fuera tan sencillo.
        Mapeo de resultados avanzado
          MyBatis fue creado con una idea en mente: las bases de datos no siempre son como a ti te gustaría que fueran. Nos encantaría que todas las bases de datos estuvieran en 3ª forma normal o BCNF, pero no lo están. Sería genial que una base de datos encajara perfectamente con todas las aplicaciones que la usan pero no es así. Los ResultMaps son la respuesta de MyBatis a este problema.
        Por ejemplo, ¿cómo mapearías este statement?<!-- Very Complex Statement -->
<select id="selectBlogDetails" resultMap="detailedBlogResultMap">
  select
       B.id as blog_id,
       B.title as blog_title,
       B.author_id as blog_author_id,
       A.id as author_id,
       A.username as author_username,
       A.password as author_password,
       A.email as author_email,
       A.bio as author_bio,
       A.favourite_section as author_favourite_section,
       P.id as post_id,
       P.blog_id as post_blog_id,
       P.author_id as post_author_id,
       P.created_on as post_created_on,
       P.section as post_section,
       P.subject as post_subject,
       P.draft as draft,
       P.body as post_body,
       C.id as comment_id,
       C.post_id as comment_post_id,
       C.name as comment_name,
       C.comment as comment_text,
       T.id as tag_id,
       T.name as tag_name
  from Blog B
       left outer join Author A on B.author_id = A.id
       left outer join Post P on B.id = P.blog_id
       left outer join Comment C on P.id = C.post_id
       left outer join Post_Tag PT on PT.post_id = P.id
       left outer join Tag T on PT.tag_id = T.id
  where B.id = #{id}
</select>Posiblemente te gustaría mapearlo a un modelo de objetos formado por un Blog que ha sido escrito por un Autor, y tiene varios Posts, cada uno de ellos puede tener cero o varios comentarios y tags. A continuación puede observarse un ResultMap complejo (asumimos que Author, Blog, Post, Comments y Tags son typeAliases). Échale un vistazo, pero no te preocupes, iremos paso a paso. Aunque parece enorme, es en realidad, bastante sencillo.
        <!-- Very Complex Result Map -->
<resultMap id="detailedBlogResultMap" type="Blog">
  <constructor>
    <idArg column="blog_id" javaType="int"/>
  </constructor>
  <result property="title" column="blog_title"/>
  <association property="author" javaType="Author">
    <id property="id" column="author_id"/>
    <result property="username" column="author_username"/>
    <result property="password" column="author_password"/>
    <result property="email" column="author_email"/>
    <result property="bio" column="author_bio"/>
    <result property="favouriteSection" column="author_favourite_section"/>
  </association>
  <collection property="posts" ofType="Post">
    <id property="id" column="post_id"/>
    <result property="subject" column="post_subject"/>
    <association property="author" javaType="Author"/>
    <collection property="comments" ofType="Comment">
      <id property="id" column="comment_id"/>
    </collection>
    <collection property="tags" ofType="Tag" >
      <id property="id" column="tag_id"/>
    </collection>
    <discriminator javaType="int" column="draft">
      <case value="1" resultType="DraftPost"/>
    </discriminator>
  </collection>
</resultMap>El elemento resultMap tiene varios sub-elementos y una estructura que merece la pena comentar. A continuación se muestra una vista conceptual del elemento resultMap.
         - argumento ID; marcar el argumento ID mejora el rendimiento - un resultado normal inyectado en el constructor - usado para inyectar resultados en el constructor de la clase durante la instanciación
             – result ID; marcar los results con ID mejora el rendimiento – un resultado normal inyectado en un campo o una propiedad de un JavaBeanresult mapping anidado – las asociaciones son resultMaps en sí mismas o pueden apuntar a otro resultMap
               – una asociación con un objeto complejo; muchos resultados acabarán siendo de este tipo
            result mapping anidado – las colecciones son resultMaps en sí mismas o pueden apuntar a otro resultMap – una colección de tipos complejos
            result mapping anidado – un case es un resultMap en sí mismo y por tanto puede contener a su vez elementos propios de un resultMap o bien apuntar a un resultMap externo.
                   – un resultMap basado en un valor concreto
                 – utiliza un valor del resultado para determinar qué resultMap utilizar
            Atributos de ResultMapUn identificador único dentro del namespace que se utiliza para identificar el result map.El nombre completamente cualificado de la clase o el alias del parámetro que se pasará al statement.Si el atributo está presente MyBatis habilita o inhabilita el automapping para este result map.
                El atributo sobreescribe el parametro global autoMappingBehavior. Valor por defecto: no informado.
              Buena práctia Construye los ResultMaps de forma incremental. Las pruebas unitarias son de gran ayuda en ellos. Si intentas construir un ResultMap gigantesco como el que se ha visto anteriormente, es muy probable que lo hagas mal y será difícil trabajar con él. Comienza con una versión sencilla y evolucionarla paso a paso. Y haz pruebas unitarias! La parte negativa de utilizar frameworks es que a veces son una caja negra (sean opensource o no). Lo mejor que puedes hacer para asegurar que estás consiguiendo el comportamiento que pretendes es escribir pruebas unitarias. También son de utilidad para enviar bugs.
        
          Las próximas secciones harán un recorrido por cada uno de los elementos en detalle.
        id, result<id property="id" column="post_id"/>
<result property="subject" column="post_subject"/>
          Estos son los ResultMaps más sencillos. Ambos id, y result mapean una columna con una propiedad o campo de un tipo de dato simple (String, int, double, Date, etc.).
        
          La única diferencia entre ambos es que id marca que dicho resultado es un identificador y dicha propiedad se utilizará en las comparaciones entre instancias de objetos. Esto mejora el rendimiento global y especialmente el rendimiento de la cache y los mapeos anidados (ej. mapeo de joins).
        
          Cada uno tiene los siguientes atributos:
        Atributos de id y resultEl campo o propiedad al que se va a mapear al valor resultado. Si existe una propiedad tipo JavaBean para el nombre dado, se utilizará. En caso contrario MyBatis buscará un campo con el mismo nombre. En ambos casos puedes utilizar navegación compleja usando la notación habitual con puntos. Por ejemplo, puedes mapear a algo sencillo como: “username”, o a algo más complejo como:  “address.street.number”.
              El nombre de la columna de la base de datos, o el alias de columna. Es el mismo string que se pasaría al método resultSet.getString(columnName).
              Un nombre de clase Java totalmente cualificado, o un typeAlias (más adelante se indican los typeAlias predefinidos). Normalmente MyBatis puede adivinar el tipo de datos de una propiedad de un JavaBean. Sin embargo si usas una HashMap deberás especificar el javaType para obtener el comportamiento deseado.
              Un tipo JDBC de los tipos soportados que se muestran a continuación. El tipo JDBC solo se requiere para columnas que admiten nulos en insert, update o delete. Esto es un requerimiento de JDBC no de MyBatis. Incluso si usas JDBC directamente debes especificar el tipo – pero solo para los valores que pueden ser nulos.
              Ya hemos hablado sobre typeHandlers anteriormente. Usando esta propiedad se puede sobre escribir el typeHandler por defecto. El valor admite un nombre totalmente cualificado o un alias.
              Tipos JDBC soportadosPara referencia futura, MyBatis soporta los siguientes tipos JDBC por medio de la enumeración JdbcType.BITUNDEFINEDTINYINTREALBINARYVARBINARYCURSORARRAYAunque las propiedades funcionan bien en clases tipo Data Transfer Object (DTO), y posiblemente en la mayor parte de tu modelo de dominio, hay algunos casos en los que puedes querer clases inmutables. En ocasiones, las tablas que contienen información que nunca o raramente cambia son apropiadas para las clases inmutables. La inyección en el constructor te permite informar valores durante la instanciación de la clase, sin necesidad de exponer métodos públicos. MyBatis tambien soporta propiedades privadas para conseguir esto mismo pero habrá quien prefiera utilizar la inyección de Constructor. El elemento constructor  permite hacer esto.
        Dado el siguiente constructor:public class User {
   //...
   public User(Integer id, String username, int age) {
     //...
  }
//...
}
          In order to inject the results into the constructor, MyBatis needs to identify the constructor for somehow.
          In the following example, MyBatis searches a constructor declared with three parameters:  in this order.
        <constructor>
   <idArg column="id" javaType="int"/>
   <arg column="username" javaType="String"/>
   <arg column="age" javaType="_int"/>
</constructor>
          When you are dealing with a constructor with many parameters, maintaining the order of arg elements is error-prone.
          Since 3.4.3, by specifying the name of each parameter, you can write arg elements in any order. To reference constructor parameters by their names, you can either add  annotation to them or compile the project with '-parameters' compiler option and enable  (this option is enabled by default).
          The following example is valid for the same constructor even though the order of the second and the third parameters does not match with the declared order.
        <constructor>
   <idArg column="id" javaType="int" name="id" />
   <arg column="age" javaType="_int" name="age" />
   <arg column="username" javaType="String" name="username" />
</constructor> can be omitted if there is a writable property with the same name and type.
        El resto de atributos son los mismos que los de los elementos id y result.El id de otro mapped statement que cargará el tipo complejo asociado a este argumento. Los valores obtenidos de las columnas especificadas en el atributo column se pasarán como parámetros al select  statement referenciado. Ver el elemento association  para más información.
              El id de un resultmap que puede mapear los resultados anidados de este argumento al grafo de objetos (object graph) apropiado. Es una alternativa a llamar a otro select statement. Permite hacer join de varias tablas en un solo ResultSet. Un ResultSet de este tipo puede contener bloques repetidos de datos que deben ser descompuestos y mapeados apropiadamente a un árbol de objetos (object graph). MyBatis te permite encadenar RestultMaps para tratar resultados anidados.  Ver el elemento association  para más información.
              
                The name of the constructor parameter. Specifying name allows you to write arg elements in any order. See the above explanation. Since 3.4.3.
              <association property="author" javaType="Author">
  <id property="id" column="author_id"/>
  <result property="username" column="author_username"/>
</association>El elemento association trata las relaciones de tipo “tiene-un”. Por ejemplo, en nuestro ejemplo, un Blog tiene un Autor. Un mapeo association funciona casi como cualquier otro result. Debes especificar la propiedad destino, el javaType de la propiedad (que normalmente MyBatis puede adivinar), el jdbcType si fuera necesario y un typeHandler si quieres sobre escribir el tratamiento de los valores de retorno.
        Donde la association es distinta es en que debes indicar a MyBatis como cargar la asociación. MyBatis puede hacerlo de dos formas distintas:
        
            Nested Select: Ejecutando otra select que devuelve el tipo complejo deseado.
          
            Nested Results: Usando un ResultMap anidado que trata con los datos repetidos de resultsets provenientes de joins.
          Primeramente, examinemos la propiedades del elemento. Como veras, es distinto de un ResultMap normal solo por los atributos select y resultMap.
        El campo o propiedad a la que se debe mapear la columna. Si existe una propiedad JavaBean igual al nombre dado, se usará. En caso contrario, MyBatis buscará un campo con el nombre indicado. En ambos casos puedes usar navegación compleja usando la notación habitual con puntos. Por ejemplo puedes mapear algo simple como: “username”, o algo más complejo como:  “address.street.number”.
              Select anidada en AssociationEl nombre de la columna de la base de datos, o el alias de columna que contiene el valor que será pasado como parámetro de entrada al statement anidado. Es el mismo string que se pasaría al método resultSet.getString(columnName). Nota: para tratar con claves compuestas, puedes especificar varios nombres usando esta sintaxis column=”{prop1=col1,prop2=col2}”. Esto hará que se informen las propiedades prop1 y prop2 del objeto parámetro del select statement destino
              El id de otro mapped statement que cargará el tipo complejo asociado a esta propiedad. Los valores obtenidos de las columnas especificadas en el atributo column se pasarán como parámetros al select  statement referenciado. A continuación se muestra un ejemplo detallado. Nota: para tratar con claves compuestas, puedes especificar varios nombres usando esta sintaxis column=”{prop1=col1,prop2=col2}”. Esto hará que se informen las propiedades prop1 y prop2 del objeto parámetro del select statement destino
              
                Opcional. Los valores válidos son . Si está presente sobrescribe
                el parámetro global de configuración  para este mapping.
              
          Por ejemplo:
        <resultMap id="blogResult" type="Blog">
  <association property="author" column="author_id" javaType="Author" select="selectAuthor"/>
</resultMap>

<select id="selectBlog" resultMap="blogResult">
  SELECT * FROM BLOG WHERE ID = #{id}
</select>

<select id="selectAuthor" resultType="Author">
  SELECT * FROM AUTHOR WHERE ID = #{id}
</select>Tenemos dos statements: uno para cargar el Blog, el otro para cargar el Autor, y el RestulMap de Blog describe que la sentencia “selectAuthor” debe utilizarse para cargar su propiedad author.
        Todas las demás propiedades se cargarán automáticamente asumiendo que los nombres de propiedad y de columna coinciden.
        Aunque este enfoque es simple, puede no tener un buen rendimiento con gran cantidad de datos. Este problema es conocido como “El problema de las N+1 Selects”. En resumidas cuentas, el problema de N+1 selects está causado por esto:
        Ejecutas una sentencia SQL para obtener una lista de registros (el “+1”).Para cada registro obtenido ejecutas una select para obtener sus detalles (el “N”).
          Este problema puede provocar la ejecución de cientos o miles de sentencias SQL. Lo cual no es demasiado recomendable.
        MyBatis puede cargar esas consultas de forma diferida (lazy load), por lo tanto se evita el coste de lanzar todas esas consultas a la vez. Sin embargo, si cargas la lista e inmediatamente iteras por ella para acceder a los datos anidados, acabarás cargando todos los registros y por lo tanto el rendimiento puede llegar a ser muy malo.
        Así que, hay otra forma de hacerlo.
        ResultMaps anidadas en AssociationEl id de un resultmap que puede mapear los resultados anidados de esta asociación al grafo de objetos apropiado. Es una alternativa a llamar a otro select statement. Permite hacer join de varias tablas en un solo ResultSet. Un ResultSet de este tipo puede contener bloques repetidos de datos que deben ser descompuestos y mapeados apropiadamente a un árbol de objetos (object graph). MyBatis te permite encadenar RestultMaps para tratar resultados anidados.  A continuación se muestra un ejemplo detallado.
              
                Cuando se hace una join de varias tablas, es posible que tengas que usar alias de columna para evitar nombres duplicados en el ResultSet.
                El atributo columnPrefix te permite mapear dichas columnas a un Result Map externo. Más adelante se muestra un ejemplo de esta función.
              
                Por defecto MyBatis sólo crea objetos hijos si al menos una de las columnas mapeadas a las propiedades de dicho objeto es no nula.
                Con este atributo se puede modificar este comportamiento especificando qué columnas deben tener un valor de forma que MyBatis
                sólo creará un objeto hijo si alguna de estas columnas no es nula. Pueden indicarse una lista de columnas usando la coma como separador.
              If present, MyBatis will enable or disable automapping when mapping the result to this property.
                This attribute overrides the global autoMappingBehavior.
                Note that it has no effect on an external resultMap, so it is pointless to use it with  attribute. Default value: unset.
              Previamente has visto un ejemplo muy complejo de asociaciones anidadas. Lo que se muestra a continuación es un ejemplo más simple que muestra cómo funciona esta característica. En lugar de ejecutar un statement separado, vamos a hacer una JOIN de las tablas Blog y Author de la siguiente forma:
        <select id="selectBlog" resultMap="blogResult">
  select
    B.id            as blog_id,
    B.title         as blog_title,
    B.author_id     as blog_author_id,
    A.id            as author_id,
    A.username      as author_username,
    A.password      as author_password,
    A.email         as author_email,
    A.bio           as author_bio
  from Blog B left outer join Author A on B.author_id = A.id
  where B.id = #{id}
</select>Fíjate en la join, y el especial cuidado que se ha dedicado a que todos los resultados tengan un alias que les de un nombre único y claro. Esto hace el mapeo mucho más sencillo. Ahora podemos mapear los resultados:
        <resultMap id="blogResult" type="Blog">
  <id property="id" column="blog_id" />
  <result property="title" column="blog_title"/>
  <association property="author" javaType="Author" resultMap="authorResult"/>
</resultMap>

<resultMap id="authorResult" type="Author">
  <id property="id" column="author_id"/>
  <result property="username" column="author_username"/>
  <result property="password" column="author_password"/>
  <result property="email" column="author_email"/>
  <result property="bio" column="author_bio"/>
</resultMap>En el ejemplo anterior puedes ver que la asociación “author” de Blog delega la carga de las instancias de Author en el ResultMap “authorResult”.
        importantMuy importante: El elemento id tiene un papel muy importante en el mapeo de resultados anidados. Debes especificar siempre una o más propiedades que se puedan usar para identificar unívocamente los resultados. Lo cierto es que MyBatis también va a funcionar si no lo haces pero a costa de una importante penalización en rendimiento. Elige el número mínimo de propiedades que pueda identificar unívocamente un resultado. La clave primaria es una elección obvia (incluso si es compuesta).
        En el ejemplo anterior se usa un resultMap externo para mapear la asociación. Esto hace que el resultMap del Autor sea reusable. Sin embargo, si no hay necesidad de reusarla o simplemente prefieres colocar todos los mapeos en un solo ResultMap, puedes anidarlo en la propia asociación. A continuación se muestra un ejemplo de este enfoque:
        <resultMap id="blogResult" type="Blog">
  <id property="id" column="blog_id" />
  <result property="title" column="blog_title"/>
  <association property="author" javaType="Author">
    <id property="id" column="author_id"/>
    <result property="username" column="author_username"/>
    <result property="password" column="author_password"/>
    <result property="email" column="author_email"/>
    <result property="bio" column="author_bio"/>
  </association>
</resultMap>
          Pero ¿y si el blog tiene un co-autor? La select sería algo así:
        <select id="selectBlog" resultMap="blogResult">
  select
    B.id            as blog_id,
    B.title         as blog_title,
    A.id            as author_id,
    A.username      as author_username,
    A.password      as author_password,
    A.email         as author_email,
    A.bio           as author_bio,
    CA.id           as co_author_id,
    CA.username     as co_author_username,
    CA.password     as co_author_password,
    CA.email        as co_author_email,
    CA.bio          as co_author_bio
  from Blog B
  left outer join Author A on B.author_id = A.id
  left outer join Author CA on B.co_author_id = CA.id
  where B.id = #{id}
</select>
          Recuerda que el resultMap de Author está definido de la siguiente forma.
        <resultMap id="authorResult" type="Author">
  <id property="id" column="author_id"/>
  <result property="username" column="author_username"/>
  <result property="password" column="author_password"/>
  <result property="email" column="author_email"/>
  <result property="bio" column="author_bio"/>
</resultMap>
          Dado que los nombres de columnas de los resultados difieren de los nombres especidficados en el resultMap, necesitas
          especificar un atributo  para poder reusar el result map de Author para los co-autores.
        <resultMap id="blogResult" type="Blog">
  <id property="id" column="blog_id" />
  <result property="title" column="blog_title"/>
  <association property="author"
    resultMap="authorResult" />
  <association property="coAuthor"
    resultMap="authorResult"
    columnPrefix="co_" />
</resultMap>ResultSets múltiples en Association
                Cuando se usan result sets multiples este atributo especifica las columnas (separadas por comas) que se
                correlarán con las indicadas en  para identificar al padre y e hijo de una relación.
              
                Identifica los nombres de las columnas que contienen las claves foráneas que se emparejarán
                con las columnas especificadas en el atributo  del tipo padre.
              
                Identifica el nombre del result set de donde se cargarán los datos.
              Desce la versión 3.2.3 MyBatis proporciona otra forma más de resolver el problema del N+1.Algunas bases de datos permiten que un procedimiento almacenado devuelva más de un resultset o
        ejecutar más de una sentencia a la vez y obtener de vuelta un resultset por cada. Esto se puede usar
        para acceder una sola vez a la base de datos y obtener datos relacionados sin usar una join.En el ejemplo, el procedimiento almacenado deolverá dos result sets. El primero contendrá
        Blogs y el segundo Authors.SELECT * FROM BLOG WHERE ID = #{id}

SELECT * FROM AUTHOR WHERE ID = #{id}Se debe proporcionar un nombre a cada resultset informando el atributo
         del mapped statement con una lista de nombres separados por comas.<select id="selectBlog" resultSets="blogs,authors" resultMap="blogResult" statementType="CALLABLE">
  {call getBlogsAndAuthors(#{id,jdbcType=INTEGER,mode=IN})}
</select>

        Ahora podemos especificar que los datos para rellenar la asociación "author" vienen en el result set "authors":
        <resultMap id="blogResult" type="Blog">
  <id property="id" column="id" />
  <result property="title" column="title"/>
  <association property="author" javaType="Author" resultSet="authors" column="author_id" foreignColumn="id">
    <id property="id" column="id"/>
    <result property="username" column="username"/>
    <result property="password" column="password"/>
    <result property="email" column="email"/>
    <result property="bio" column="bio"/>
  </association>
</resultMap>Has visto como se utiliza la asociación “Tiene Un”. Pero ¿qué hay que el “Tiene Muchos”? Ese es el contenido de la siguiente sección.
        <collection property="posts" ofType="domain.blog.Post">
  <id property="id" column="post_id"/>
  <result property="subject" column="post_subject"/>
  <result property="body" column="post_body"/>
</collection>El elemento collection funciona de forma casi idéntica al association.  En realidad, es tan similar, que documentar todas las similitudes sería redundante. Así que enfoquémonos en las diferencias.
        Para continuar con nuestro ejemplo anterior, un Blog solo tiene un Autor. Pero un Blog tiene muchos Posts. En la clase Blog esto se representaría con algo como:
        private List<Post> posts;Para mapear un conjunto de resultados anidados a una Lista como esta, debemos usar el elemento collection. Al igual que el elemento association, podemos usar una select anidada, o bien resultados anidados cargados desde una join.
        Select anidada en CollectionPrimeramente, echemos un vistazo al uso de una select anidada para cargar los Posts de un Blog.
        <resultMap id="blogResult" type="Blog">
  <collection property="posts" javaType="ArrayList" column="id" ofType="Post" select="selectPostsForBlog"/>
</resultMap>

<select id="selectBlog" resultMap="blogResult">
  SELECT * FROM BLOG WHERE ID = #{id}
</select>

<select id="selectPostsForBlog" resultType="Post">
  SELECT * FROM POST WHERE BLOG_ID = #{id}
</select>Hay unas cuantas diferencias que habrás visto de forma inmediata, pero la mayor parte tiene el mismo aspecto que el elemento association  que vimos anteriormente. Primeramente, verás que estamos usando el elemento collection. Verás también que hay un nuevo atributo “ofType”. Este atributo es necesario para distinguir el tipo de la propiedad del JavaBean (o del campo) y el tipo contenido por la colección. Por tanto podrías leer el siguiente mapeo de esta forma:
        <collection property="posts" javaType="ArrayList" column="id" ofType="Post" select="selectPostsForBlog"/>Leído como: "Una colección de posts en un ArrayList de tipos Post."
        El javaType es casi siempre innecesario, porque MyBatis lo adivinará en la mayoría de los casos. Así que podrías acortarlo de esta forma:
        <collection property="posts" column="id" ofType="Post" select="selectPostsForBlog"/>ResultMaps anidados en CollectionA estas alturas, posiblemente ya imaginarás cómo funcionan los ResultMaps anidados en una colección porque funcionan exactamente igual que en una asociación, salvo por que se añade igualmente el atributo “ofType”.
        Primero, echemos un vistazo al SQL:<select id="selectBlog" resultMap="blogResult">
  select
  B.id as blog_id,
  B.title as blog_title,
  B.author_id as blog_author_id,
  P.id as post_id,
  P.subject as post_subject,
  P.body as post_body,
  from Blog B
  left outer join Post P on B.id = P.blog_id
  where B.id = #{id}
</select>Nuevamente hemos hecho una JOIN de las tablas Blog y Post, y hemos tenido cuidado de asegurarnos que las columnas obtenidas tienen un alias adecuado. Ahora, mapear un Blog y colección de Post es tan simple como:
        <resultMap id="blogResult" type="Blog">
  <id property="id" column="blog_id" />
  <result property="title" column="blog_title"/>
  <collection property="posts" ofType="Post">
    <id property="id" column="post_id"/>
    <result property="subject" column="post_subject"/>
    <result property="body" column="post_body"/>
  </collection>
</resultMap>Nuevamente, recuerda la importancia del elemento id,  o lee la sección de asociación si no lo has hecho aun.
        Además, si prefieres el formato más largo que aporta más reusabilidad a tus ResultMaps, puedes utilizar esta forma alternativa de mapeo:
        <resultMap id="blogResult" type="Blog">
  <id property="id" column="blog_id" />
  <result property="title" column="blog_title"/>
  <collection property="posts" ofType="Post" resultMap="blogPostResult" columnPrefix="post_"/>
</resultMap>

<resultMap id="blogPostResult" type="Post">
  <id property="id" column="id"/>
  <result property="subject" column="subject"/>
  <result property="body" column="body"/>
</resultMap>ResultSets múltiples en Collection
          De la misma forma que hicimos en la association, podemos llamar a un procedimiento almacenado que devuelva
          dos resultsets, uno con Blogs y otro con Posts:
        SELECT * FROM BLOG WHERE ID = #{id}

SELECT * FROM POST WHERE BLOG_ID = #{id}<select id="selectBlog" resultSets="blogs,posts" resultMap="blogResult">
  {call getBlogsAndPosts(#{id,jdbcType=INTEGER,mode=IN})}
</select>Especificamos que la collection "posts" se rellenará con datos contenidos en el resultset llamado "posts":<resultMap id="blogResult" type="Blog">
  <id property="id" column="id" />
  <result property="title" column="title"/>
  <collection property="posts" ofType="Post" resultSet="posts" column="id" foreignColumn="blog_id">
    <id property="id" column="id"/>
    <result property="subject" column="subject"/>
    <result property="body" column="body"/>
  </collection>
</resultMap> No hay límite en profundidad, amplitud o combinaciones de las asociaciones y colecciones que mapees. Debes tener en cuenta el rendimiento cuando crees los mapeos. Las pruebas unitarias y de rendimiento de tu aplicación son de gran utilidad para conocer cuales el mejor enfoque para tu aplicación. La parte positiva es que MyBatis te permite cambiar de opinión más tarde, con muy poco (o ningún) cambio en tu código.
        El mapeo de asociaciones y colecciones es un tema denso. La documentación solo puede llevarte hasta aquí. Con un poco de práctica, todo se irá aclarando rápidamente.
        <discriminator javaType="int" column="draft">
  <case value="1" resultType="DraftPost"/>
</discriminator>En ocasiones una base de datos puede devolver resultados de muchos y distintos (y esperamos que relacionados) tipos de datos. El elemento discriminator fue diseñado para tratar esta situación, y otras como la jerarquías de herencia de clases. El discriminador es bastante fácil de comprender, dado que funciona muy parecido la sentencia switch de Java.
        Una definición de discriminator especifica los atributos column y javaType. Column indica de dónde debe MyBatis obtener el valor con el que comparar. El javaType es necesario para asegurar que se utiliza el tipo de comparación adecuada (aunque la comparación de Strings posiblemente funcione casi en todos los casos). Por ejemplo:
        <resultMap id="vehicleResult" type="Vehicle">
  <id property="id" column="id" />
  <result property="vin" column="vin"/>
  <result property="year" column="year"/>
  <result property="make" column="make"/>
  <result property="model" column="model"/>
  <result property="color" column="color"/>
  <discriminator javaType="int" column="vehicle_type">
    <case value="1" resultMap="carResult"/>
    <case value="2" resultMap="truckResult"/>
    <case value="3" resultMap="vanResult"/>
    <case value="4" resultMap="suvResult"/>
  </discriminator>
</resultMap>En este ejemplo, MyBatis obtendrá cada registro del ResultSet y comparará su valor vehicle_type. Si coincide con alguno de los casos del discriminador entonces usará el ResultMap especificado en cada caso. Esto se hace de forma exclusiva, es decir, el resto del ResultMap se ignora (a no ser que se extienda, de lo que hablaremos en un Segundo). Si no coincide ninguno de los casos MyBatis utilizará el resultmap definido fuera del bloque discriminator.  Por tanto si carResult ha sido declarado de la siguiente forma:
        <resultMap id="carResult" type="Car">
  <result property="doorCount" column="door_count" />
</resultMap>Entonces solo la propiedad doorCount se cargará. Esto se hace así para permitir grupos de discriminadores completamente independientes, incluso que no tengan ninguna relación con el ResultMap padre. En este caso sabemos que hay relación entre coches y vehículos, dado que un coche es-un vehículo. Por tanto queremos que el resto de propiedades se carguen también, así que con un simple cambio en el ResultMap habremos terminado.
        <resultMap id="carResult" type="Car" extends="vehicleResult">
  <result property="doorCount" column="door_count" />
</resultMap>Ahora, se cargarán todas las propiedades tanto de vehicleResult como de carResult.
        Nuevamente, hay quien puede pensar que la definición externa es tediosa. Por tanto hay una sintaxis alternativa para los que prefieran un estilo más conciso. Por ejemplo:
        <resultMap id="vehicleResult" type="Vehicle">
  <id property="id" column="id" />
  <result property="vin" column="vin"/>
  <result property="year" column="year"/>
  <result property="make" column="make"/>
  <result property="model" column="model"/>
  <result property="color" column="color"/>
  <discriminator javaType="int" column="vehicle_type">
    <case value="1" resultType="carResult">
      <result property="doorCount" column="door_count" />
    </case>
    <case value="2" resultType="truckResult">
      <result property="boxSize" column="box_size" />
      <result property="extendedCab" column="extended_cab" />
    </case>
    <case value="3" resultType="vanResult">
      <result property="powerSlidingDoor" column="power_sliding_door" />
    </case>
    <case value="4" resultType="suvResult">
      <result property="allWheelDrive" column="all_wheel_drive" />
    </case>
  </discriminator>
</resultMap> Recuerda que todos estos son ResultMaps, y que si no indicas ningún result en ellos, MyBatis mapeará automáticamente las columnas a las propiedades por ti. Así que en muchos casos estos ejemplos son más verbosos de lo que realmente debieran ser. Dicho esto, la mayoría de las bases de datos son bastante complejas y muchas veces no podemos depender de ello para todos los casos.
        Auto-mapeo
          Como ya has visto en las secciones previas, en los casos simples MyBatis puede auto-mapear los resultados por ti y en el resto de los casos
          es posible que tengas que crear un result map. Pero, como verás en esta sección también puedes combinar ambas estrategias.
          Veamos en detalle cómo funciona el auto-mapeo.
        ID
          Al auto-mapear resultados MyBatis obtiene el nombre de columna y busca una propiedad con el mismo nombre sin tener en cuenta las mayúsculas.
          Es decir, si se encuentra una columna  y una propiedad , MyBatis informará la propiedad  con el valor de la columna
          
          Normalmente las columnas de base de datos se nombran usando mayúsculas y separando las palabras con un subrayado, mientras que las propiedades
          java se nombran habitualmente siguiendo la notación tipo camelcase. Para habilitar el auto-mapeo entre ellas informa el parámetro de configuración
           a true.
        userNamehashed_password
          El auto-mapeo funciona incluso cuando hay un result map específico. Cuando esto sucede, para cada result map, todas las columnas que están
          presentes en el ResultSet y que no tienen un mapeo manual se auto-mapearán. Posteriormente se procesarán los mapeos manuales.
          En el siguiente ejemplo las columnas  se auto-mapearán y la columna  se mapeará manualmente.<select id="selectUsers" resultMap="userResultMap">
  select
    user_id             as "id",
    user_name           as "userName",
    hashed_password
  from some_table
  where id = #{id}
</select><resultMap id="userResultMap" type="User">
  <result property="password" column="hashed_password"/>
</resultMap>
          Hay tres niveles de auto-mapeo:
         - desactiva el auto-mapeo. Solo las propiedades mapeadas manaulmente se informarán.
           - auto-mapea todos los resultados que no tienen un mapeo anidado definido en su interior (joins).
          FULL - lo auto-mapea todo.
          
          El valor por defecto es , y hay una razón para ello. Cuandos se utiliza  el auto-mapeo se
          realiza cuando se están procesando resultados de joins y las joins obtienen datos de distintas entidades en la misma fila
          por lo tanto podrían producirse mapeos automáticos indeseados. Para comprender el riesgo observa el siguiente ejemplo:
        <select id="selectBlog" resultMap="blogResult">
  select
    B.id,
    B.title,
    A.username,
  from Blog B left outer join Author A on B.author_id = A.id
  where B.id = #{id}
</select><resultMap id="blogResult" type="Blog">
  <association property="author" resultMap="authorResult"/>
</resultMap>

<resultMap id="authorResult" type="Author">
  <result property="username" column="author_username"/>
</resultMap>
          Con este result map ambos  se auto-mapearán. Pero fíjate que  tiene un  y que hay una
          columna con nombre  en el ResultSet por lo que el id de Author se rellenará con el id de Blog, y eso no era lo que esperabas.
          Por tanto usa la opción  con cuidado.
        
          Independientemente del nivel de auto-mapeo configurado puedes activar o desactivar el auto-mapeo para un ResultMap especifico
          añadiendole el atributo:
        <resultMap id="userResultMap" type="User" autoMapping="false">
  <result property="password" column="hashed_password"/>
</resultMap>MyBatis incluye una funcionalidad de caché transaccional de segundo nivel muy potente que es ampliamente configurable y personalizable. Se han realizado muchos cambios en la caché de MyBatis 3 para hacer la a la vez más potente y más sencilla de configurar.
        
           Por defecto la única caché activa es la caché local de sesión que se utiliza únicamente durante la duración de una sesión.
           Para habilitar la caché de segundo nivel global simplemente necesitas añadir una línea en tu fichero de mapping:
        <cache/>Eso es todo literalmente. El efecto de esta sencilla línea es el siguiente:
        Todos los resultados de las sentencias select en el mapped statement se cachearán.Todas las sentencias insert, update y delete del mapped statement vaciarán la caché.La caché usarán un algoritmo de reemplazo tipo Least Recently Used (LRU).La caché no se vaciará por tiempo (ej. no Flush Interval).La caché guardará 1024 referencias a listas u objetos (según lo que devuelva el statement).La caché puede tratarse como una cache de tipo lectura/escritura, lo cual significa que los objetos obtenidos no se comparten y pueden modificarse con seguridad por el llamante sin interferir en otras potenciales modificaciones realizadas por otros llamantes o hilos. The cache will only apply to statements declared in the mapping file
          where the cache tag is located. If you are using the Java API in conjunction with the XML mapping files, then
          statements declared in the companion interface will not be cached by default. You will need to refer to the
          cache region using the @CacheNamespaceRef annotation.
        Todas estas propiedades son modificables mediante atributos del elemento cache. Por ejemplo:
        <cache
  eviction="FIFO"
  flushInterval="60000"
  size="512"
  readOnly="true"/>Esta configuración más avanzada de caché crea una cache de tipo FIFO que se vacía cada 60 segundos, guarda hasta 512 referencias a objetos o listas, y los objetos devueltos son considerados de solo lectura, esto es, que modificarlos puede crear problemas en llamantes de otros hilos.
        Las políticas de reemplazo son las siguientes:
         – Least Recently Used: Borra los objetos que llevan más tiempo sin ser usados.
           – First In First Out: Borra los objetos en el mismo orden en el que entraron en la caché. – Soft Reference: Borra los objetos en base a las referencias Soft del Garbage Collector.
           – Weak Reference: Es más agresivo y borra objetos basándose en el estado del Garbage Collector y las referencias débiles.
          LRU es la política por defecto.El atributo flushInterval acepta un entero positivo y debería representar un lapso de tiempo razonable en milisegundos. No está activo por defecto, por tanto no hay intervalo de vaciado y la caché solo se vacía mediante llamadas a otros statements.
        El atributo size acepta un entero positivo, ten en cuenta el tamaño de los objetos que quieres cachear y la cantidad de memoria de la que dispone. Por defecto es 1024.
        El atributo readOnly puede informarse con true o false. Una caché de solo lectura devuelve la misma instancia de objeto a todos los llamantes. Por lo tanto estos objetos no deben modificarse. Por otro lado esto proporciona una mejora en el rendimiento. Una caché de tipo lectura-escritura devuelve una copia (vía serialización) del objeto cacheado. Esto es más lento, pero más seguro, y por ello el valor por defecto es false.
         La caché de segundo nivel es transaccional. Esto significa que solo es actualizada cuando
          una sessión acaba con commit o cuando acaba con rollback pero no se ha ejecutado ninguna sentencia insert/delete/update
          con el parámetro flushCache=true.
        Como usar una caché personalizadaAdemás de poder personalizar la caché de las formas indicadas, puedes sustituir el sistema de caché por completo y proporcionar tu propia caché, o crear un adaptador para cachés de terceros.
        <cache type="com.domain.something.MyCustomCache"/>Este ejemplo muestra cómo usar una caché personalizada. La clase especificada en el atributo type debe implementar el interfaz org.apache.ibatis.cache.Cache y proporcionar un constructor que recibe como parámetro un String id. Este es uno de los interfaces más complejos de MyBatis pero su funcionalidad es simple.
        public interface Cache {
  String getId();
  int getSize();
  void putObject(Object key, Object value);
  Object getObject(Object key);
  boolean hasKey(Object key);
  Object removeObject(Object key);
  void clear();
}Para configurar tu caché añade simplemente propiedades tipo JavaBean a tu implementación, y pasa las propiedades usando el elemento cache, por ejemplo el siguiente ejemplo llamará a un método “setCacheFile(String file)” en tu implementación de caché:
        <cache type="com.domain.something.MyCustomCache">
  <property name="cacheFile" value="/tmp/my-custom-cache.tmp"/>
</cache>${cache.file}configuration.html#properties
          Puedes utilizar propiedades JavaBean de cualquier tipo simple y MyBatis hará la conversión.
          And you can specify a placeholder(e.g. ) to replace value defined at org.apache.ibatis.builder.InitializingObject
          Since 3.4.2, the MyBatis has been supported to call an initialization method after it's set all properties.
          If you want to use this feature, please implements the 
          interface on your custom cache class.
        public interface InitializingObject {
  void initialize() throws Exception;
}
          Los parametros de configuración de la cache (eviction, read write..etc.) explicados anteriormente no aplican cuando se usa
          una caché personalizada.
        Es importante recordar que la configuración de la caches y la instancia de caché está asociadas al namespace del fichero SQL Map. Y por tanto, a todas las sentencias del mismo namespace dado que la cache está asociada a él. Los statements pueden modificar cómo interactúan con la caché, o excluirse a sí mismos completamente utilizando dos atributos simples. Por defecto los statements están configurados así:
        <select ... flushCache="false" useCache="true"/>
<insert ... flushCache="true"/>
<update ... flushCache="true"/>
<delete ... flushCache="true"/>Dado que estos son los valores por defecto, no deberías nunca configurar un statement de esa forma. En cambio, utiliza los atributos flushCache y useCache si quieres modificar el valor por defecto. Por ejemplo en algunos casos quieres excluir los resultados de un caché particular de la caché, o quizá quieras que un statement de tipo select vacíe la caché. O de forma similar, puede que quieras que algunas update statements no la vacíen.
        Recuerda que en la sección anterior se indicó que la caché de un namespace sería utilizada por statements del mismo namespace. Es posible que en alguna ocasión quieras compartir la misma configuración de caché e instancia entre statements de distintos namespaces. En estos casos puedes hacer referencia a otra caché usando el elemento cache-ref.
        <cache-ref namespace="com.someone.application.data.SomeMapper"/>/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/es/xdoc/statement-builders.xmlMyBatis 3 | Statement BuildersThe SQL Builder ClassEl ProblemaUna de las cosas más tediosas que un programador Java puede llegar a tener que hacer es incluir código SQL en código Java. Normalmente esto se hace cuando es necesario generar dinámicamente el SQL – de otra forma podrías externalizar el código en un fichero o un procedimiento almacenado. Como ya has visto, MyBatis tiene una respuesta potente a la generación dinámica de SQL mediante las capacidades del mapeo XML. Sin embargo, en ocasiones se hace necesario construir una sentencia SQL dentro del código Java. En este caso, MyBatis tiene una funcionalidad más para ayudarte en ello, antes de que comiences con el típico lío de signos de suma, comillas, líneas nuevas, problemas de formato y condicionales anidados para tratar con las comas extra y las conjunciones AND… Realmente, generar código dinámico en java, puede ser una verdadera pesadilla. Por ejemplo:
String sql = "SELECT P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME, "
"P.LAST_NAME,P.CREATED_ON, P.UPDATED_ON " +
"FROM PERSON P, ACCOUNT A " +
"INNER JOIN DEPARTMENT D on D.ID = P.DEPARTMENT_ID " +
"INNER JOIN COMPANY C on D.COMPANY_ID = C.ID " +
"WHERE (P.ID = A.ID AND P.FIRST_NAME like ?) " +
"OR (P.LAST_NAME like ?) " +
"GROUP BY P.ID " +
"HAVING (P.LAST_NAME like ?) " +
"OR (P.FIRST_NAME like ?) " +
"ORDER BY P.ID, P.FULL_NAME";
La SoluciónMyBatis 3 introduce un concepto un tanto distinto para tratar con el problema.
    Con la clase SQL, puedes crear una sentencia SQL en un sólo paso invocando a sus métodos.
    El ejemplo anterior tendría este aspecto si se rescribe con la clase SQL:
  
private String selectPersonSql() {
  return new SQL() {{
    SELECT("P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME");
    SELECT("P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON");
    FROM("PERSON P");
    FROM("ACCOUNT A");
    INNER_JOIN("DEPARTMENT D on D.ID = P.DEPARTMENT_ID");
    INNER_JOIN("COMPANY C on D.COMPANY_ID = C.ID");
    WHERE("P.ID = A.ID");
    WHERE("P.FIRST_NAME like ?");
    OR();
    WHERE("P.LAST_NAME like ?");
    GROUP_BY("P.ID");
    HAVING("P.LAST_NAME like ?");
    OR();
    HAVING("P.FIRST_NAME like ?");
    ORDER_BY("P.ID");
    ORDER_BY("P.FULL_NAME");
  }}.toString();
}
¿Qué hay de especial en este ejemplo?
      Bien, si lo miras detenidamente, verás que no hay que preocuparse de duplicar “AND”s, o elegir entre “WHERE” o “AND”, o ninguno de ambos!
      La clase SQL se ocupa de colocar el "WHERE" donde debe de ir, si debe usarse "AND" o no y de realizar todas las concatenaciones de Strings.
    La clase SQLAqui van algunos ejemplos:
// Anonymous inner class
public String deletePersonSql() {
  return new SQL() {{
    DELETE_FROM("PERSON");
    WHERE("ID = #{id}");
  }}.toString();
}

// Builder / Fluent style
public String insertPersonSql() {
  String sql = new SQL()
    .INSERT_INTO("PERSON")
    .VALUES("ID, FIRST_NAME", "#{id}, #{firstName}")
    .VALUES("LAST_NAME", "#{lastName}")
    .toString();
  return sql;
}

// With conditionals (note the final parameters, required for the anonymous inner class to access them)
public String selectPersonLike(final String id, final String firstName, final String lastName) {
  return new SQL() {{
    SELECT("P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME");
    FROM("PERSON P");
    if (id != null) {
      WHERE("P.ID like #{id}");
    }
    if (firstName != null) {
      WHERE("P.FIRST_NAME like #{firstName}");
    }
    if (lastName != null) {
      WHERE("P.LAST_NAME like #{lastName}");
    }
    ORDER_BY("P.LAST_NAME");
  }}.toString();
}

public String deletePersonSql() {
  return new SQL() {{
    DELETE_FROM("PERSON");
    WHERE("ID = #{id}");
  }}.toString();
}

public String insertPersonSql() {
  return new SQL() {{
    INSERT_INTO("PERSON");
    VALUES("ID, FIRST_NAME", "#{id}, #{firstName}");
    VALUES("LAST_NAME", "#{lastName}");
  }}.toString();
}

public String updatePersonSql() {
  return new SQL() {{
    UPDATE("PERSON");
    SET("FIRST_NAME = #{firstName}");
    WHERE("ID = #{id}");
  }}.toString();
}
MetodoSELECT(String)SELECT(String...)Comienza o añade a una sentencia SELECT. Se puede invocar más de una vez y los parámetros se irán añadiendo a la sentencia SELECT. Los parámetros son normalmente una lista de columnas o alias separados por comas, pero puede ser cualquier cosa que acepte el driver de base de datos.SELECT_DISTINCT(String)SELECT_DISTINCT(String...)Comienza o añade a una sentencia SELECT, también añade la palabra clave “DISTINCT” a la sentencia generada. Se puede invocar más de una vez y los parámetros se irán añadiendo a la sentencia SELECT. Los parámetros son normalmente una lista de columnas o alias separados por comas, pero puede ser cualquier cosa que acepte el driver de base de datos.FROM(String)FROM(String...)Comienza o añade a una cláusula FROM. Se puede invocar más de una vez y los parámetros se irán añadiendo a la clausula FROM. Los parámetros son normalmente un nombre de tabla o alias o cualquier cosa que acepte el driver de base de datos.JOIN(String)JOIN(String...)INNER_JOIN(String)INNER_JOIN(String...)LEFT_OUTER_JOIN(String)LEFT_OUTER_JOIN(String...)RIGHT_OUTER_JOIN(String)RIGHT_OUTER_JOIN(String...)Añade una nueva clausula JOIN del tipo apropiado, dependiendo al método que se haya llamado. El parámetro puede incluir un join estándar que consiste en las columnas y las condiciones sobre las que hacer la join.WHERE(String)WHERE(String...)Añade una nueva condición a la clausula WHERE concatenada con un AND. Puede llamarse más de una vez, lo cual hará que se añadan más condiciones todas ellas concatenadas con un AND. O usa OR() para partirlas con un OR().Parte las condiciones actuales de la WHERE con un OR. Puede llamarse más de una vez, pero llamarlas más de una vez en la misma línea puede producir sentencias incorrectas.Parte las condiciones actuales de la WHERE con un AND. Puede llamarse más de una vez, pero llamarlas más de una vez en la misma línea puede producir sentencias incorrectas.  Dado que WHERE y HAVING concatenan automáticamente el AND, es muy infrecuente que sea necesario invocar a este método y se incluye realmente por completitud.GROUP_BY(String)GROUP_BY(String...)Añade una nueva clausula GROUP BY grupo, concatenada con una coma. Se le puede llamar más de una vez, lo cual hará que se concatenen nuevas condiciones separadas también por coma.HAVING(String)HAVING(String...)Añade una nueva clausula HAVING, concatenada con un AND. Se le puede llamar más de una vez, lo cual hará que se concatenen nuevas condiciones separadas también por AND. Usa OR() para dividirlas por OR.ORDER_BY(String)ORDER_BY(String...)Añade un Nuevo elemento a la clausula ORDER BY concatenado por coma. Se le puede llamar más de una vez, lo cual hará que se concatenen nuevas condiciones separadas también por coma.LIMIT(String)
      Appends a  clause.
      This method valid when use together with SELECT(), UPDATE() and DELETE().
      And this method is designed to use together with OFFSET() when use SELECT(). (Available since 3.5.2)
    OFFSET(String) clause.
      This method valid when use together with SELECT().
      And this method is designed to use together with LIMIT(). (Available since 3.5.2)
    OFFSET_ROWS(String)OFFSET n ROWS clause.
      This method valid when use together with SELECT().
      And this method is designed to use together with FETCH_FIRST_ROWS_ONLY(). (Available since 3.5.2)
    FETCH_FIRST_ROWS_ONLY(String)FETCH FIRST n ROWS ONLY clause.
      This method valid when use together with SELECT().
      And this method is designed to use together with OFFSET_ROWS(). (Available since 3.5.2)
    DELETE_FROM(String)Comienza una sentencia delete y especifica la tabla donde borrar. Generalmente suele ir seguida de una clausula WHERE!
    INSERT_INTO(String)Comienza una sentencia insert y especifica al tabla en la que insertar. Suele ir seguida de una o más llamadas a VALUES() o INTO_COLUMNS() y INTO_VALUES().
    SET(String)SET(String...)Añade a la lista “set” de una update.UPDATE(String)Comienza una sentencia update y especifica la tabla que modificar Suele ir seguida de una o más llamadas a SET() y normalmente de una llamada a WHERE().VALUES(String, String)Añade a una sentencia insert. El primer parámetro es el nombre de columna y el Segundo el valor(es).INTO_COLUMNS(String...)
      Appends columns phrase to an insert statement.
      This should be call INTO_VALUES() with together.
    INTO_VALUES(String...)
      Appends values phrase to an insert statement.
      This should be call INTO_COLUMNS() with together.
    
      Add new row for bulk insert. (Available since 3.5.2)
    
          It is important to note that SQL class writes  clauses into the generated statement as is.
          In other words, the library does not attempt to normalize those values for databases that don’t support these clauses directly.
          Therefore, it is very important for users to understand whether or not the target database supports these clauses.
          If the target database does not support these clauses, then it is likely that using this support will create SQL that has runtime errors.
        Since version 3.4.2, you can use variable-length arguments as follows:
public String selectPersonSql() {
  return new SQL()
    .SELECT("P.ID", "A.USERNAME", "A.PASSWORD", "P.FULL_NAME", "D.DEPARTMENT_NAME", "C.COMPANY_NAME")
    .FROM("PERSON P", "ACCOUNT A")
    .INNER_JOIN("DEPARTMENT D on D.ID = P.DEPARTMENT_ID", "COMPANY C on D.COMPANY_ID = C.ID")
    .WHERE("P.ID = A.ID", "P.FULL_NAME like #{name}")
    .ORDER_BY("P.ID", "P.FULL_NAME")
    .toString();
}

public String insertPersonSql() {
  return new SQL()
    .INSERT_INTO("PERSON")
    .INTO_COLUMNS("ID", "FULL_NAME")
    .INTO_VALUES("#{id}", "#{fullName}")
    .toString();
}

public String updatePersonSql() {
  return new SQL()
    .UPDATE("PERSON")
    .SET("FULL_NAME = #{fullName}", "DATE_OF_BIRTH = #{dateOfBirth}")
    .WHERE("ID = #{id}")
    .toString();
}
Since version 3.5.2, you can create insert statement for bulk insert as follow:
public String insertPersonsSql() {
  // INSERT INTO PERSON (ID, FULL_NAME)
  //     VALUES (#{mainPerson.id}, #{mainPerson.fullName}) , (#{subPerson.id}, #{subPerson.fullName})
  return new SQL()
    .INSERT_INTO("PERSON")
    .INTO_COLUMNS("ID", "FULL_NAME")
    .INTO_VALUES("#{mainPerson.id}", "#{mainPerson.fullName}")
    .ADD_ROW()
    .INTO_VALUES("#{subPerson.id}", "#{subPerson.fullName}")
    .toString();
}
Since version 3.5.2, you can create select statement for limiting search result rows clause as follow:
public String selectPersonsWithOffsetLimitSql() {
  // SELECT id, name FROM PERSON
  //     LIMIT #{limit} OFFSET #{offset}
  return new SQL()
    .SELECT("id", "name")
    .FROM("PERSON")
    .LIMIT("#{limit}")
    .OFFSET("#{offset}")
    .toString();
}

public String selectPersonsWithFetchFirstSql() {
  // SELECT id, name FROM PERSON
  //     OFFSET #{offset} ROWS FETCH FIRST #{limit} ROWS ONLY
  return new SQL()
    .SELECT("id", "name")
    .FROM("PERSON")
    .OFFSET_ROWS("#{offset}")
    .FETCH_FIRST_ROWS_ONLY("#{limit}")
    .toString();
}
SqlBuilder y SelectBuilder (DEPRECADAS)
          En versiones anteriores a la 3.2 optamos por una solución distinta, usando una variable ThreadLocal para
          resolver algunas limitaciones de las que hacen los DSLs Java algo incomodos. Sin embargo, esta solución está ahora
          desprecada porque los frameworks actuales están mas orientados a usar patrones builder-type y clases anónimas
          interas para este tipo de cosas. Por lo tanto las clases SelectBuilder y SqlBuilder están ahora deprecadas.
        
          Los siguientes métodos aplican solo a las clases deprecadas SqlBuilder y SelectBuilder.
        MétodoBEGIN()RESET() / Estos métodos limpian estado guardad en el ThreadLocal de la clase SelectBuilder, y la preparan para construir una nueva sentencia. BEGIN() se lee mejor cuando se está creando una sentencia. RESET() se lee mejor cuando se está borrando lo hecho anteriormente en medio de una ejecución (quizá porque la lógica necesita una sentencia completamente distinta según las condiciones).SQL()Devuelve la SQL generada y restablece el estado del SelectBuilder (como si se hubiera llamado a un BEGIN() o a un RESET()). Por tanto este método solo se puede llamar una vez!La clase SelectBuilder no es mágica, pero es importante que conozcas cómo funcionan.
  SelectBuilder y SqlBuilder usan una combinación de imports estáticos y una variable ThreadLocal para permitir una sintaxis más limpia más fácilmente usabe con condicionales.
  Para usarlas debes importar estáticamente métodos de las siguientes clases (uno u otro, no ambos):import static org.apache.ibatis.jdbc.SelectBuilder.*;import static org.apache.ibatis.jdbc.SqlBuilder.*;De esta forma podrás crear métodos como estos:
/* DEPRECATED */
public String selectBlogsSql() {
  BEGIN(); // Clears ThreadLocal variable
  SELECT("*");
  FROM("BLOG");
  return SQL();
}
        
/* DEPRECATED */
private String selectPersonSql() {
  BEGIN(); // Clears ThreadLocal variable
  SELECT("P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME");
  SELECT("P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON");
  FROM("PERSON P");
  FROM("ACCOUNT A");
  INNER_JOIN("DEPARTMENT D on D.ID = P.DEPARTMENT_ID");
  INNER_JOIN("COMPANY C on D.COMPANY_ID = C.ID");
  WHERE("P.ID = A.ID");
  WHERE("P.FIRST_NAME like ?");
  OR();
  WHERE("P.LAST_NAME like ?");
  GROUP_BY("P.ID");
  HAVING("P.LAST_NAME like ?");
  OR();
  HAVING("P.FIRST_NAME like ?");
  ORDER_BY("P.ID");
  ORDER_BY("P.FULL_NAME");
  return SQL();
}
        /Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/ja/xdoc/configuration.xml/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/ja/xdoc/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/jaMyBatis 3 | 設定harawata@gmail.com設定
        MyBatis の設定ファイルには、MyBatis の動作をカスタマイズするための設定やプロパティが含まれています。ファイルの上位レベルの構造は次のようになっています。
      
          'properties' は、別ファイルで設定することができて上書き可能なプロパティです。よく使われる Java Properties ファイルのインスタンス、または properties 要素の子要素として設定することができます。例：
        
          読み込んだプロパティは設定ファイル全体を通して使用可能で、変数を動的に設定することができます。
          この例では username と password の値が properties 要素で指定した値に、そして driver と url の値が config.properties 内で定義されている値に置き換えられます。この仕組みによって柔軟な設定が実現可能です。
        
          SqlSessionFactoryBuilder.build() メソッドに Properties を渡すこともできます。
          あるプロパティが複数の箇所で指定されている場合、MyBatis は次の順番で値を読み込みます。
        まず最初に properties 要素のボディで指定されたプロパティが読み込まれます。
          次に、クラスパスリソースや properties 要素の url 属性で指定された Properties が読み込まれます。先に設定されていた値があれば上書きされます。
          そして最後にメソッドの引数として渡された値が読み込まれます。ここでも properties 要素のボディで指定された値や resource/url 属性で指定されたファイルから同じキーを持つ値が読み込まれていた場合には上書きされます。
          
          従って、メソッド引数として渡されたプロパティが最も優先度が高く、次に resource/url 属性、最も優先度が低いのは properties 要素のボディで指定された値ということになります。
        
          MyBatis 3.4.2以降では、下記に示すようにプレースホルダの中にデフォルト値を指定することができます。
        
<dataSource type="POOLED">
  <!-- ... -->
  <property name="username" value="${username:ut_user}"/> <!-- 'username'プロパティが存在しない場合は、 usernameは'ut_user'になる -->
</dataSource>
          この機能はデフォルトでは無効になっています。もしプレースホルダの中にデフォルト値を指定したい場合は、下記に示すように特別なプロパティを追加して機能を有効化する必要があります。
        
<properties resource="org/mybatis/example/config.properties">
  <!-- ... -->
  <property name="org.apache.ibatis.parsing.PropertyParser.enable-default-value" value="true"/> <!-- この機能を有効化 -->
</properties> また、既にプロパティキーとしてを使用(例: )していたり、
          SQL定義の中でOGNL式の三項演算子(例: )を使用している場合は、
          下記に示すように特別なプロパティを追加してキーとデフォルト値を分割するための文字を変更する必要があります。
        
<properties resource="org/mybatis/example/config.properties">
  <!-- ... -->
  <property name="org.apache.ibatis.parsing.PropertyParser.default-value-separator" value="?:"/> <!-- 分割文字を変更 -->
</properties>
          'settings' は、実行時に MyBatis の動作を変更することができる、非常に重要な調整点です。
          各設定についての説明と設定可能な値およびデフォルト値を以下の表にまとめてあります。
        説明設定可能な値デフォルト値
                このコンフィグレーション内で定義されている全てのキャッシュの有効／無効を切り替えるグローバルな設定です。
              
                Lazy Loading（遅延読み込み）の有効／無効を切り替えるグローバルな設定です。
                無効にした場合、association として指定されているデータは直ちに読み込まれます。
                association 要素で  属性が指定されている場合はそちらの指定が優先されます。
              
                この設定が有効の場合、オブジェクトのいずれかのメソッド呼び出しと同時にすべての Lazy loading が実行されます。
                無効の場合は、各プロパティはそれぞれ要求時に読み込まれます（関連項目  ）。
              
                false （3.4.1 以下は true）
              
                １つのステートメントから複数の ResultSet を返すことを許可するかどうかを指定します（複数 ResultSet に対応したドライバが必要です）。
              
                列名の代わりに列ラベルを使用します。
                ドライバによって動作が異なります。
                ドライバのドキュメントを参照するか、両方のモードを試して動作を確認してください。
              
                JDBC の generated keys サポートを使用するかどうかを指定します。
                Derby のように非互換となっていても動作するドライバに対応するため、true を設定した場合は強制的に generated keys を使用します。
              
                MyBatis の自動マッピング機能（列をフィールド／プロパティに自動的にマッピングする機能）の動作を指定します。
                NONE を指定すると自動マッピングは無効となります。
                PARTIAL が指定された場合、association や collection などを含まない単純な resultMap のみが自動マッピングの対象となります。
                FULL が指定された場合、ネストされた結果などの複雑なものも含めて全てが自動マッピングの対象となります。
              : 何もしません: 警告ログを出力します ( のログレベルをに設定してください): 自動マッピング処理をエラーにします。(が発生します)
                自動マッピング対象のプロパティが存在しない(又はプロパティ型がサポート外の)カラムを検知した時の動作を指定します。
                
                この機能には制限があり、`autoMappingBehavior` に `FULL` がセットされていると誤った結果が報告される場合があります。
              
                デフォルトの executor を指定します。
                SIMPLE executor は特別なことは何もしません。
                REUSE executor は PreparedStatement を再利用します。
                BATCH executor はステートメントを再利用してバッチ更新を実行します。
              
                ドライバがデータベースからの応答を待ち続ける秒数（タイムアウト）を設定します。
              
                正の整数（単位：秒）
              
                なし (null)
              
                検索結果のフェッチサイズを制御するためのドライバヒントを設定します。
                このパラメータ値はクエリ毎の設定で上書きできます。
              
                正の整数
              
                ステートメント毎の設定を省略した場合のスクロール方法を指定します。 (導入されたバージョン: 3.5.2)
              
                FORWARD_ONLY | SCROLL_SENSITIVE | SCROLL_INSENSITIVE | DEFAULT(指定しない時と同じ動作)
              
                ネストされたステートメントに対して RowBounds の使用を許可するかどうかを設定します。
                許可する場合は、 false を設定します。
              
                ネストされたステートメントに対して ResultHandler の使用を許可するかどうかを設定します。
                許可する場合は、 false を設定します。
              
                データベースにある A_COLUMN のようなアンダースコアを含む列を Camel Case の Java プロパティ aColumn に自動的にマッピングする機能の有効／無効を切り替えます。
              
                MyBatis は循環参照の解決やネストされたクエリのスピード向上のためにローカルキャッシュを使用します。
                デフォルト（SESSION）では同一セッション内の全てのクエリ結果がキャッシュされます。localCacheScope に STATEMENT を設定した場合、ローカルキャッシュはステートメントごとに適用されます。言い換えると、同一 SqlSession に対する複数の呼び出しでデータが共有されることはありません。
              
                引数の JDBC タイプが未指定の場合、null 値に対して割り当てられる JDBC タイプを設定します。
                ドライバによっては列に対する JDBC タイプの指定が必須な場合もありますが、NULL, VARCHAR, OTHER などの汎用の型を指定すれば動作するものもあります。
              
                JdbcType 列挙型。一般的には NULL, VARCHAR, OTHER のいずれかです。
              
                Lazy loading のトリガとなる Object のメソッドを指定します。
              
                カンマ区切りのメソッド名のリスト
              
                ダイナミック SQL を記述する際のデフォルトの言語を指定します。
              
                タイプエイリアスまたは完全修飾クラス名
              
                Enum型に適用するデフォルトの  を指定します。(導入されたバージョン: 3.4.5)
              
                取得した値が null の場合にセッターあるいは Map の put メソッドを呼び出すかどうかを指定します。
                この設定は Map.keySet() や null 値による初期化を利用している場合に有用です。プリミティブ型（int, boolean, 等）に null がセットされることはありません。
              
                取得した列が全て NULL だった場合、デフォルトの動作では  が返りますが、 returnInstanceForEmptyRow に true を設定すると空のインスタンスが返るようになります。この動作はネストされた結果をマッピングする際にも適用されます。導入されたバージョン: 3.4.2
              
                MyBatis が出力するログに付加される接頭辞を指定します。
              
                任意の文字列
              
                未指定
              
                MyBatis のログ出力に使用するロギング実装を指定します。未指定の場合は自動的検出されます。
              
                SLF4J | LOG4J(3.5.9以降非推奨) | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING
              
                Lazy Loading（遅延読み込み）に対応したオブジェクトを生成する際に使用するプロクシツールを指定します。
              
                CGLIB (3.5.10 以降非推奨) | JAVASSIST
              
                JAVASSIST (MyBatis 3.3 以上)
              
                VFS 実装クラスを指定します。
              
                完全修飾クラス名（カンマ区切りで複数指定可能）
              
                ステートメントの引数を参照する際、メソッドシグネチャで宣言されている名前で参照できるようにします。
                このオプションを有効にする場合、プロジェクトを Java 8 （コンパイラオプション  付き）でコンパイルする必要があります。 (導入されたバージョン: 3.4.1)
              
                デシリアライズされたオブジェクトの遅延読込（Lazy loading）を行う際に利用される  のインスタンスを返すクラスを指定します。
                このクラスには次のシグネチャを持つメソッドが定義されている必要があります。 . (導入されたバージョン: 3.2.3)
              
                SQL 内の余分な空白文字を削除します。リテラル文字列も対象となる点に注意してください。（導入されたバージョン: 3.5.5）
              
                SQLを提供するメソッドを保持するSQLプロバイダクラスを指定します(導入されたバージョン: 3.5.6)。
                ここで指定したクラスは、SQLプロバイダアノテーション(例: )の(または ) 属性を省略した際に適用されます。
              
                'foreach' タグの 'nullable' 属性のデフォルト値. (導入されたバージョン: 3.5.9)
              
                引数を受け取るコンストラクタに対して自動マッピングを適用する際、引数名に一致する列をマップ対象にします。 の場合は列の順序依存となります。 (導入されたバージョン: 3.5.10）
              
          各種設定を含む settings の例：
        
          タイプエイリアスとは、Java タイプに対する短縮名です。
          XML の中でクラスを指定する際、完全修飾名の記述を最小限で済ませることができます。
          例えば、

        
          上記のようにタイプエイリアスを定義しておくと、
          
          と書く代わりに
          
          と書くことができます。
        
          全てのクラスを列挙する代わりにパッケージを指定することもできます。
        
          この場合、
          
          というパッケージ内のクラスに対してタイプエイリアスが登録されます。
          例えば
          
          というクラスに対しては
          
          というタイプエイリアスが登録されます。
          アノテーションを使うと、登録されるエイリアス名を指定することもできます。
          次のようになります。
        
          汎用の Java タイプには、予めタイプエイリアスが用意されています。
          これらは全て Case Insensitive （大文字小文字を区別しない）です。
          プリミティブ型の場合は特殊な表記が必要となるので注意してください。
        
                エイリアス
              
                Java タイプ
              
                _char （3.5.10 以降）
              
                _character （3.5.10 以降）
              
                char （3.5.10 以降）
              
                character （3.5.10 以降）
              
          MyBatis が PreparedStatement のパラメーターをセットするとき、あるいは ResultSet から値を取得するときには、必ずその Java タイプに対応する TypeHandler が使用されます。
          次の表はデフォルトの TypeHandler の一覧です。
        
          バージョン3.4.5より、JSR-310(Date and Time API)のクラスがデフォルトでサポートされました。
        
                タイプハンドラー
              
                JDBC タイプ
              
                BooleanTypeHandler
              
                Boolean, boolean
              
                BOOLEAN 互換の型
              
                ByteTypeHandler
              
                Byte, byte
              
                NUMERIC または BYTE 互換の型
              
                ShortTypeHandler
              
                Short, short
              
                NUMERIC または SMALLINT 互換の型
              
                IntegerTypeHandler
              
                Integer, int
              
                NUMERIC または INTEGER 互換の型
              
                LongTypeHandler
              
                Long, long
              
                NUMERIC または BIGINT 互換の型
              
                FloatTypeHandler
              
                Float, float
              
                NUMERIC または FLOAT 互換の型
              
                DoubleTypeHandler
              
                Double, double
              
                NUMERIC または DOUBLE 互換の型
              
                BigDecimalTypeHandler
              
                NUMERIC または DECIMAL 互換の型
              
                StringTypeHandler
              
                CHAR, VARCHAR
              
                ClobReaderTypeHandler
              
                java.io.Reader
              
                ClobTypeHandler
              
                CLOB, LONGVARCHAR
              
                NStringTypeHandler
              
                NVARCHAR, NCHAR
              
                NClobTypeHandler
              
                NCLOB
              
                BlobInputStreamTypeHandler
              
                java.io.InputStream
              
                ByteArrayTypeHandler
              
                byte[]
              
                byte ストリーム互換の型
              
                BlobTypeHandler
              
                BLOB, LONGVARBINARY
              
                DateTypeHandler
              
                Date (java.util)
              
                TIMESTAMP
              
                DateOnlyTypeHandler
              
                DATE
              
                TimeOnlyTypeHandler
              
                TIME
              
                SqlTimestampTypeHandler
              
                Timestamp (java.sql)
              
                SqlDateTypeHandler
              
                Date (java.sql)
              
                SqlTimeTypeHandler
              
                Time (java.sql)
              
                ObjectTypeHandler
              
                OTHER または指定がない場合
              
                EnumTypeHandler
              
                VARCHAR インデックスではなくコードが保存されるので、String 互換の型
              
                EnumOrdinalTypeHandler
              
                コードではなく位置（ordinal）が保存されるので、NUMERIC または DOUBLE 互換の型
              
                SqlxmlTypeHandler
              
                java.lang.String
              
                SQLXML
              
                InstantTypeHandler
              
                java.time.Instant
              
                LocalDateTimeTypeHandler
              
                java.time.LocalDateTime
              
                LocalDateTypeHandler
              
                java.time.LocalDate
              
                LocalTimeTypeHandler
              
                java.time.LocalTime
              
                OffsetDateTimeTypeHandler
              
                java.time.OffsetDateTime
              
                OffsetTimeTypeHandler
              
                java.time.OffsetTime
              
                ZonedDateTimeTypeHandler
              
                java.time.ZonedDateTime
              
                YearTypeHandler
              
                java.time.Year
              
                INTEGER
              
                MonthTypeHandler
              
                java.time.Month
              
                YearMonthTypeHandler
              
                java.time.YearMonth
              
                VARCHAR または LONGVARCHAR
              
                JapaneseDateTypeHandler
              
                java.time.chrono.JapaneseDate
              
          標準のタイプハンドラーをオーバーライドしたり、自ら作成したタイプハンドラーを使って未対応あるいは非標準の型を扱うことも可能です。自作する場合は、BaseTypeHandler クラスのサブクラスを作成します。必要に応じて対応する JDBC タイプを指定してください。
          例：
        // ExampleTypeHandler.java
@MappedJdbcTypes(JdbcType.VARCHAR)
public class StringTypeHandler extends BaseTypeHandler<String> {

  @Override
  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {
    ps.setString(i, parameter);
  }

  @Override
  public String getNullableResult(ResultSet rs, String columnName) throws SQLException {
    return rs.getString(columnName);
  }

  @Override
  public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
    return rs.getString(columnIndex);
  }

  @Override
  public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
    return cs.getString(columnIndex);
  }
}

          上記のようにして登録された TypeHandler は、String 型のプロパティと VARCHAR 型の引数または結果のマッピング時に使用されるデフォルトのタイプハンドラーよりも優先的に使用されます。
          MyBatis はデータベースメタデータを参照してタイプを判断している訳ではないので、正しいタイプハンドラーが使用されるよう、パラメーター設定時にフィールドが VARCHAR 型であることを明示する必要があります。MyBatis は実際にステートメントが実行されるまで、データ型のチェックなどは行いません。
        
          MyBatis は、このタイプハンドラーの総称型（Genric Type）から適用対象の Java タイプを自動判定しますが、この動作をオーバーライドする方法が２つあります。
        typeHandler 要素に javaType 属性を追加する（例：javaType="String"）
          TypeHandler の実装クラスに  アノテーションを付加して適用対象の Java タイプのリストを指定します。javaType とアノテーションを両方指定した場合は javaType の指定が優先されます。
          typeHandler 要素に jdbcType 属性を追加することで適用対象の JDBC タイプを指定することもできます（例：jdbcType=VARCHAR）。jdbcType 属性が指定されている場合、 の指定は無視されます。
        適用対象の JDBC タイプを指定する方法は二つあります。typeHandler 要素に jdbcType 属性を追加する（例：jdbcType=VARCHAR）。 を付加し、JDBC タイプのリストを指定します。jdbcType 属性が指定されている場合、このアノテーションは無視されます。includeNullJdbcType　でプロパティの指定に  と  が明示的に指定されていない場合、パース時点で  はプロパティの型から推測可能ですが  は未知となります。 MyBatis は javaType=[推測された型] と jdbcType=null にマップされた TypeHandler を探します。
          TypeHandler を jdbcType=null にマップするためには  の  属性に  を指定します。
          MyBatis 3.4.0 以降は javaType に対してマップされている TypeHandler が１つの場合は登録時の jdbcType に関わらずこの TypeHandler が使われるようになりました。
        また、MyBatis にタイプハンドラーを自動検出させることもできます。
          自動検出機能を使う場合、適用対象の JDBC タイプの指定はアノテーションで行う必要があります。
        @MappedTypes(BigInteger.class)
public class BigIntegerHandler implements TypeHandler<BigInteger> {
   ...
}

          複数のクラスを扱う汎用の TypeHandler を作成することもできます。
          引数に Class を受け取るコンストラクタを定義しておくと、MyBatis が TypeHandler のインスタンスを作成する際に実際のクラスが渡されます。
        この後の節では汎用の TypeHandler である  について解説します。
         （列挙型）をマップする場合、
           または  のどちらかを使うことになります。
        例えば数値の丸めモード（java.math.RoundingMode）を格納する場合、デフォルトでは  が使われ、各  は名前の文字列（DOWN, HALF_UP, etc.）に変換されます。
        他の TypeHandler が特定のクラスを対象としているのに対し、 は  を継承した任意のクラスを対象とする特別な TypeHandler です。では名前以外の値を格納したい場合、例えばデータベース管理者が数値で格納して欲しいと言ってきた場合はどうすれば良いのでしょうか。
        簡単です：設定ファイルの  に  を追加すれば  は ordinal の数値に変換されてマップされます。
        
          では、同じ  を、あるテーブルには文字列として格納し、別のテーブルには数値として格納したいといった場合はどうでしょう。
        
          上の設定により自動マッピングでは  が使われますので、
           を使いたい箇所ではこれを明示的に指定する必要があります。
        
          （Mapper ファイルについては次の章で解説していますので、このドキュメントを初めて読む方はこの部分を後回しにした方が良いかも知れません）
        
          typeHandler を指定するため、select 要素では  ではなく  を使う必要があります。
        
          MyBatis が新しい結果オブジェクトのインスタンスを作るときは ObjectFactory が使われます。
          デフォルトの ObjectFactory は、対象クラスのデフォルトコンストラクタまたは引数付きのコンストラクタを使ってインスタンスを作成するだけです。
          ObjectFactory を自作することで、デフォルトの ObjectFactory の動作をオーバーライドすることもできます。// ExampleObjectFactory.java
public class ExampleObjectFactory extends DefaultObjectFactory {
  @Override
  public <T> T create(Class<T> type) {
    return super.create(type);
  }

  @Override
  public <T> T create(Class<T> type, List<Class<?>> constructorArgTypes, List<Object> constructorArgs) {
    return super.create(type, constructorArgTypes, constructorArgs);
  }

  @Override
  public void setProperties(Properties properties) {
    super.setProperties(properties);
  }

  @Override
  public <T> boolean isCollection(Class<T> type) {
    return Collection.class.isAssignableFrom(type);
  }}

          ObjectFactory のインターフェイスは非常にシンプルです。
          ２つある create メソッドのうち１つはデフォルトコンストラクタを扱うもので、もうひとつは引数を取るコンストラクタを扱います。
          もう１つのメソッド setProperties は ObjectFactory を設定するために使うことができます。
          設定ファイルの objectFactory 要素のボディで定義されているプロパティは、ObjectFactory が初期化された後に setProperties メソッドの引数として渡されます。
        
          MyBatis が Mapped Statement を実行する際、いくつかのタイミングで処理をインターセプトすることができます。
          デフォルトでは、プラグインを使って下記のメソッド呼び出しをインターセプトすることができるようになっています。
        
          これらのクラスおよびメソッドに関する詳細は、各メソッドのシグネチャや MyBatis のリリースに含まれているソースコードを参照してください。
          単にメソッドの呼び出しを監視する以上のことをしたいのなら、その動作について十分に理解しておく必要があります。
          メソッドのデフォルトの動作を変更したりオーバーライドするということは、MyBatis のコア部分の動作に影響を与える可能性があるということを忘れないでください。これらのクラスやメソッドは非常に低レベルのものなので、プラグインを使うときは注意が必要です。
        
          プラグインはとても強力ですが、使うのは比較的簡単です。
          Interceptor インターフェイスを実装したら、インターセプト対象のメソッドシグネチャを指定するだけです。
        
          上記のプラグインは Executor インスタンスの update メソッド呼び出しをインターセプトします。Executor は、低レベルで mapped statement を実行する内部オブジェクトです。
        Configuration クラスをオーバーライドする
          
          プラグインによって MyBatis の動作を変更する以外に、Configuration クラスをオーバーライドすることもできます。
          方法は単純で、Configuration のサブクラスを作って任意のメソッドをオーバーライドし、SqlSessionFactoryBuilder.build(myConfig) のようにして呼び出すだけです。
          繰り返しになりますが、これは MyBatis の動作に重大な影響を与える可能性があるので注意してください。
        
          MyBatis では複数の環境設定を定義することができます。これは、同じ SQL Map を複数のデータベースに対して使いたいとき役に立ちます。例えば、開発環境、デモ環境、本番環境で、それぞれ異なる設定場合や、本番環境の同じスキーマを持つ複数のデータベースがあり、両方に対して同じ SQL Map を使いたい場合など、様々な用途が考えられます。
        
            ひとつだけ注意しなくてはならないことは、複数の環境設定を扱うことはできますが、一つの SqlSessionFactory インスタンスに対しては一つの環境しか割り当てることができない、ということです。
          
          もし二つのデータベースに接続したいのなら、それぞれの接続に対して一つずつ、合計二つの SqlSessionFactory を作る必要があります。データベースが三つなら SqlSessionFactory も三つ必要、といった具合です。実に簡単なルールです。
        一つのデータベースにつき、一つの SqlSessionFactory が必要です。
            
          SqlSessionFactoryBuilder に envrionment を渡すことで、どの環境に対する SqlSessionFactory をビルドするか指定することができます。
          envrionment を引数に取るシグネチャは下記の２つです。
        
          environment が省略された場合、デフォルトの environment がロードされます。
        
          environment の具体的な設定は、environments 要素で行います。
        
          ここでのポイントは以下の通りです。
        
            デフォルトの環境 (default="development")
          
            各環境のID (id="development")
          
            トランザクションマネージャーの設定 (type="JDBC")
          
            データソースの設定 (type="POOLED")
          
          デフォルト環境と環境 ID は自明です。
          各環境の ID は自由に命名して構いませんが、デフォルトとして指定した環境 ID を必ず定義しておいてください。
        
          MyBatis では二種類のトランザクションマネージャー（JDBC と MANAGED）が用意されています。
        <transactionManager type="JDBC">
  <property name="skipSetAutoCommitOnClose" value="false"/>
</transactionManager>
            JDBC - JDBC トランザクションマネージャーは、単純に JDBC のコミットとロールバックの機能を直接利用します。
            この場合、トランザクションのスコープはデータソースから取得した接続に依存します。一部のドライバーとの互換性を保つため、デフォルトでは接続をクローズする前にオートコミットを有効化するようになっていますが、この処理は他のドライバにとっては不要なだけでなく負荷の高い操作となる可能性があります。バージョン 3.5.10 以降では skipSetAutoCommitOnClose に false を設定することでオートコミットの有効化処理をスキップできるようになっています。
            
            MANAGED - MANAGED トランザクションマネージャーはコミットもロールバックもしません。
            トランザクションのライフサイクルは全てコンテナ（JEE アプリケーションサーバーなど）が管理することになります。
            MANAGED マネージャーは接続をクローズするのがデフォルトの動作ですが、お使いのコンテナによってはこの動作を変更する必要があります。以下のようにして closeConnection に false を設定してください。
            
          MyBatis を Spring と組み合わせて使う場合、トランザクションマネージャーの設定は不要です（設定しても Spring 側で用意したトランザクションマネージャーによって上書きされます）。
        
          トランザクションマネージャーに必須のプロパティはありませんが、これらはともにタイプエイリアスです。つまり、TransactionFactory インターフェイスの実装クラスの完全修飾クラス名を指定すれば、MyBatis が用意した二種類のトランザクションマネージャーの代わりに独自に実装したトランザクションマネージャーを利用することが可能です。
        
          XML ファイルの中で properties 要素で指定されたプロパティは、インスタンスが作成された後、setProperties() メソッドに渡されます。
          トランザクションマネージャーの他に Transaction の実装クラスが必要となります。
          こちらも非常にシンプルなインターフェイスです。
        
          これらのインターフェイスを使えば、MyBatis のトランザクション管理方法を完全にカスタマイズすることが可能です。
        
          dataSource 要素では、JDBC 標準の DataSource インターフェイスを実装している JDBC Connection オブジェクトの取得元を指定します。
        ほとんどの MyBatis アプリケーションではサンプルのように dataSource を設定することになるはずですが、これは必須というわけではありません。
            ただし、遅延読み込み (Lazy Loading) を利用する場合はこのデータソースを使う必要があります。
          MyBatis では、３つのデータソースタイプが用意されています (type="????")
        
          – このデータソースは、リクエストごとに接続のオープン／クローズを実行します。
          少々遅いですが、即時の接続を必要としないシンプルなアプリケーションの場合は良い選択肢です。
          パフォーマンスに関しては、お使いのデータベースによっても変わってきます。
          接続プールの重要性が低いデータベースの場合はこの設定が最適となります。
          UNPOOLED データソースに対して設定可能なプロパティは下記の通りです。
        driver – JDBC ドライバーの完全修飾 Java クラス名（ドライバーに含まれているデータソースクラスではありません）
          url – JDBC 接続 URL
          username – データベース接続時のユーザー名
          password - データベース接続時のパスワード
          defaultTransactionIsolationLevel – デフォルトのトランザクション分離レベル
          defaultNetworkTimeout – 任意の要求に対するデータベースからの応答待機期限のデフォルト値（ミリ秒）。詳細は  の javadoc 参照。
          
          オプションとして、データベースドライバーのプロパティを設定することもできます。
          この場合、プロパティ名に接頭辞 "driver." を付加します。driver.encoding=UTF8
          
          上記の例では、DriverManager.getConnection(url, driverProperties) メソッド経由でドライバーに渡されるプロパティとして "encoding=UTF8" が追加されます。
        
          – このデータソースは新規接続開始時に必要となる初期接続と認証の時間を省くため JDBC 接続をプールします。
          Web アプリケーションでは応答速度向上のために良く使われる設定です。
        
          POOLED データソースには、UNPOOLED に対して設定可能なプロパティに加えて以下を指定することができます。
        poolMaximumActiveConnections – 同時にプールされる接続数の最大値です。
            デフォルト: 10
          poolMaximumIdleConnections – 同時にプールされるアイドル接続数の最大値です。
          poolMaximumCheckoutTime – プールされた接続が足りなくなった場合、使用中の接続でこの時間を経過しても戻されていない接続があれば強制的に切断されます。
            デフォルト: 20000ms （20秒）
          poolTimeToWait – 接続の取得に長時間を要した場合にログを出力し、接続の再取得を試みる機会を与えるための低レベルの設定です（プールが誤って設定された場合、無限に待機状態となってしまうのを防ぐため）。
            デフォルト: 20000ms （20秒）
          poolPingQuery – プールされた接続が正常で、リクエストを受け付けられる状態にあるかどうか確認するためにデータベースに送信される ping クエリを設定します。
            デフォルトは "NO PING QUERY SET" で、一般的なドライバーであれば問い合わせは失敗し、適切なエラーメッセージが出力されるはずです。
          poolPingEnabled – ping クエリの有効／無効を設定します。有効化した場合は poolPingQuery に適切な SQL 文（できるだけ軽いもの）を指定する必要があります。
            デフォルト: false
          poolPingConnectionsNotUsedFor – poolPingQuery が実行されるまでの時間を設定します。
            データベース接続がタイムアウトするまでの時間に合わせて設定することで、必要以上に ping クエリが実行されるのを防ぎます。
            デフォルト: 0（poolPingEnabled が true の場合、すべての接続に対して毎回 ping が実行されます）
          
          – JNDI 経由でデータソースを取得する EJB やアプリケーションサーバーと併用することを想定したデータソースです。
          設定に必要なプロパテイは２つだけです。
        initial_context – InitialContext から Context を参照する際に使用されるプロパティです（i.e. initialContext.lookup(initial_context))。
            このプロパティは省略可能で、省略した場合は InitialContext に対して直接 data_source プロパティの参照が実行されます。
          data_source – データソースのインスタンを参照するためのコンテクストパスです。
            この参照は initial_context で指定したコンテキストに対して（initial_context が省略された場合は直接 InitialContext に対して）実行されます。
          他の DataSource 設定と同様に、"env." という接頭辞を付けることで InitialContext にそのまま渡されるプロパティを設定することができます。env.encoding=UTF8
          
          上記のように指定すると、"encoding=UTF8" というプロパティが InitialContext のインスタンス生成時にコンストラクタに渡されます。
        
          上記以外の DataSource を利用する場合は  インターフェイスを実装したアダプタを作成します。
        
          アダプタを作成する際は  を継承することもできます。
          下記は C3P0 のデータソースを利用する場合の実装例です。
        
          作成したアダプタを設定する場合は property 要素を使って必要なプロパティを指定します。
          上述のアダプタを使って PostgreSQL に接続する場合の設定例を挙げておきます。
        
          MyBatis では、利用するデータベースによって異なるステートメントを実行することができます。
          複数データベースサポート機能は、各ステートメントの  属性によって実現されます。
          MyBatis は定義されているステートメントの中で  属性が指定されていないステートメントおよび現在の設定と一致する  属性を持ったステートメントをロードします。
          同じステートメントで、 属性が指定されているものと指定されていないものが両方定義されていた場合、指定がないステートメントは無視されます。
          複数データベースサポート機能を有効にするには、mybatis-config.xml に  を追加します。
        
      databaseIdProvider に DB_VENDOR が指定された場合は VendorDatabaseIdProvider がプロバイダとして使われます。
      この実装は、 から返される製品名の文字列を「現在の databaseId」として返します。この文字列は長すぎる上にバージョンによって異なる値を返すことがあるので、次のようにプロパティを指定して短い文字列に変換できるようになっています。
    
      プロパティが指定された場合、VendorDatabaseIdProvider は  から返された製品名に name 属性で指定された文字列が含まれているかどうかチェックし、含まれている場合は value 属性で指定されている文字列を「現在の databaseId」として返します。指定された name が一つも含まれていない場合は "null" を返します。
      上記の例で、 が "Oracle (DataDirect)" という文字列を返す場合、現在の databaseId は "oracle" となります。
    
      DatabaseIdProvider を自作することも可能です。 インターフェイスを実装したクラスを作成し、mybatis-config.xml で databaseIdProvider の type 属性の値として、作成したクラスの完全修飾クラス名を指定します。
    
          上記のように configuration 要素を設定することで MyBatis の動作設定は完了したので、Mapped SQL Statement の定義を行う準備ができました。
          まず、定義ファイルの場所を指定する必要があります。
          Java にはこのような場合に利用できる自動検出の仕組みがないので、単純にマッピングファイルの場所を指定します。
          相対パスでクラスパスリソースへの参照を指定することもできますし、文字列リテラルでフルパスか完全修飾 URL 形式（file:/// でも可）を指定することも可能です。
          これらの設定は、単に MyBatis にマッピングファイルの場所を伝えているだけで、その先は各 SQL マップファイルの定義次第ということになります（次の章で説明します）。
        /Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/ja/xdoc/dynamic-sql.xmlMyBatis 3 | 動的 SQL動的 SQLMybatis の強力な機能のひとつに、動的 SQL があります。もし、JDBC や類似のフレームワークを使ったことがあるなら、条件に合うように文字列をつなぎ合わせて、スペースを忘れたり、列のリストの末尾のカンマを削除するのを忘れないように注意しながら SQL を構築するのが如何に大変か分かると思います。動的に SQL を構築するのは大変な苦痛を伴う場合があります。
動的 SQL の構築が楽しくなることはないでしょうが、MyBatis が提供する強力な動的 SQL 言語を使えばかなり改善することができます。
 JSTL などの XML ベースのテキストプロセッサを使ったことがあるなら、MyBatis の動的 SQL の要素は馴染みやすいものだと思います。以前のバージョンの MyBatis では理解しておかなくてはならない要素が数多くありましたが、MyBatis 3 では改良の結果、要素の数は半分以下になっています。要素の数を減らすため、MyBatis では OGNL ベースの式（expression）を採用しています。
  動的 SQL で最も良く行うのが、次のように条件に応じて where 句に検索条件を追加する処理でしょう。このステートメントによって「任意の検索項目」を実現することができます。title を指定しなければ全ての ACTIVE な Blog が返されますが、title を指定した場合は指定したタイトルを持った Blog が返されます（このステートメントでは like 演算子を使っているので、渡された title にワイルドカードを使うこともできます）。
    タイトルと著者の両方を任意の条件としたい場合はどうすれば良いのでしょうか。
    ステートメント名を分かりやすいものに変更したら、あとは条件をもう一つ追加するだけです。
  全ての条件を適用する代わりに、多くの選択肢の中から一つを選んで適用したいという場合があります。引き続き上の例を使って、タイトルが指定されたらタイトルのみを条件として検索し、著者が指定されたら著者のみを条件として検索するようにしてみましょう。どちらも指定されなかった場合は注目のブログのみを返すようにしてみましょう（ランダムに選ばれた無意味なリストではなく、管理者が戦略的に選んだリストを返したいという要件があるのでしょう）。ここまでの例題は動的 SQL の厄介な問題点を都合よく避けていました。もう一度 if の例に戻って、今度は "ACTIVE = 1" も動的な条件に変更してみましょう。どの条件にも一致しない場合はどうなるのでしょうか？その場合は次のような SQL が実行されることになります。この SQL は構文エラーで失敗するでしょう。もし２番目の条件だけが一致したらどうなるのでしょうか？今度は次の SQL になります。これまた構文エラーで失敗するでしょう。動的 SQL の問題は単なる条件分岐だけで解決できるものではありません。自分で書いたことがある方なら、もう二度と書きたくないと思うはずです。MyBatis は約 90% のケースをうまく処理できる簡単な解決策を提供します。残りの 10% についても、カスタマイズすることで処理できるようになります。上記の例は、一箇所修正するだけで期待通りに動作するようになります。 要素は、内包するタグのどれかが結果を返すときだけ "WHERE" を挿入します。更に、内包するタグから返された結果が "AND" または "OR" で始まっていた場合はこれを削除します。 要素の動作が期待と異なる場合は、trim 要素を定義することで処理内容をカスタマイズすることができます。 属性にはパイプで区切られたオーバーライド対象の文字列を指定します。ここではスペースにも意味があります。trim 要素の  属性のリストに含まれる文字列が先頭にあった場合は削除され、 属性で指定された文字列は結果が空でない場合先頭に挿入されます。動的な update ステートメントのために同じような要素  が用意されています。 要素を使うと、アップデート対象の列を動的に追加することができます。例： 要素は、動的に SET キーワードを付加し、余分な末尾のカンマを削除します。あるいは、という要素を使っても同じ効果が得られます。prefix を追加している点は前の例と同じですが、今回は suffix をオーバーライドしている点に注意してください。動的 SQL で良くあるもう一つの要件は、コレクションの要素をイテレーション処理したいというものです。多くの場合、IN 演算子を使った条件を構築するのが目的です。例： 要素は非常に強力で、イテレーション処理の対象となるコレクションを指定する collection と、ループ内で要素を格納する変数 item、ループ回数を格納する index 変数を宣言することができます。また、開始・終了の文字列とイテレーションの合間に出力する区切り文字を指定することもできます。foreach タグは賢いので、余分な区切り文字を出力することはありません。 collection には Iterable を実装したオブジェクト（List や Set など）の他に Map や Array を指定することもできます。collection に Iterable または Array を指定した場合、 index で指定した変数にはインデックスの数値、 item で指定した変数にはコレクション、配列の要素が格納されます。Map あるいは Map.Entry のコレクションを指定した場合は index にマップのキー、item にマップの値が格納されます。XML 設定ファイルと XML Mapper ファイルについての説明はここまでになります。次の章では、Java API について詳しく見ていきます。 要素を使うと、OGNL 式の結果を変数に格納し、その変数を SQL 文中で使用することができます。複数データベースのサポートdatabaseIdProvider が設定されている場合、条件式で "_databaseId" 変数が利用可能となります。この変数を使うと、実行時のデータベースに応じてステートメントを使い分けることができます。oracle と db2 で異なる select 文を発行する例を次に挙げておきます。ダイナミック SQL 記述言語バージョン 3.2 以降、ダイナミック SQL の記述言語が Pluggable になりました。言語ドライバーを記述することで、任意の言語でダイナミック SQL を記述することができます。カスタムの言語ドライバーを使用する場合、まずは LanguageDriver インターフェイスを実装したクラスを作成します。作成した言語ドライバーをデフォルトとして使用する場合は、mybatis-config.xml に次のような設定を追加します（typeAlias の使用は必須ではありません）。 属性を指定することで、特定のステートメントの言語ドライバーのみを変更することもできます。Mapper インターフェイスを使っている場合は  アノテーションを使います。 Apache Velocity を使ってダイナミック SQL を記述することができます。MyBatis-Velocity プロジェクトを参照してください。これまでのセクションで出てきた XML タグは、全てデフォルトの言語ドライバー  （エイリアスは  ）によって提供されているものです。/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/ja/xdoc/java-api.xml前章までで、設定方法と SQL マップの書き方は学びました。MyBatis Java API は、今までの努力が実を結ぶところです。この章を読めば、JDBC と比べると、MyBatis によってコードが大幅に単純化され、クリーンで理解しやすくメンテナンスも容易な状態を保つことができるということが分かると思います。ディレクトリ構造Java API の説明に入る前に、ディレクトリ構造に関するベストプラクティスを理解しておくことが重要です。MyBatis は柔軟で、基本的にファイルは好きな場所に配置することができますが、多くのフレームワークと同様に推奨される構成があります。典型的なアプリケーションのディレクトリ構造を見てみましょう。<-- MyBatis *.jar ファイルはここに配置します。<-- MyBatis 関連のファイル（Mapper クラス、XML 設定ファイル、XML マッピングファイル）はここに配置します。<-- 設定ファイルで読み込む properties ファイルはここに配置します。これは推奨されるディレクトリ構造であって必須ではありませんが、一般的なディレクトリ構造を使っておけば他の開発者からは感謝されるはずです。尚、この章のサンプルでは、上記のディレクトリ構造を前提にしています。MyBatis の最も良く使う Java インターフェイスは SqlSession です。コマンドの実行、Mapper の取得、トランザクション管理はこのインターフェイスを通して行うことができます。SqlSession については、後で詳しく説明しますが、その前に SqlSession のインスタンスを取得する方法について学ばなくてはなりません。SqlSession は SqlSessionFactory のインスタンスによって作成されます。SqlSessionFactory には、様々な方法で SqlSession を作成するメソッドが含まれています。SqlSessionFactory 自身は SqlSessionFactoryBuilder によって作られますが、作成される SqlSessionFactory は XML、アノテーション、ハードコードされた Java コンフィグレーションのいずれかの方法で設定することができます。 MyBatis を Spring や Guice といった依存性注入（DI = Dependency Injection）フレームワークと組み合わせて使う場合、SqlSession は DI フレームワークによって作成・注入されます。SqlSessionFactoryBuilder や SqlSessionFactory を使う必要はありませんので、SqlSession の章まで飛ばして構いません。DIフレームワークとの組み合わせについては MyBatis-Spring および MyBatis-Guice のマニュアルを参照してください。SqlSessionFactoryBuilder には５つの build() メソッドがあり、それぞれ異なるソースから SqlSessionFactory をビルドすることができるようになっています。
良く使うのは、InputStream のインスタンスを引数に取って XML ファイル（具体的には mybatis-config.xml ファイル）を読み込む最初の４つのメソッドです。オプションの引数は environment と properties です。environment は、データソースやトランザクションマネージャーも含めて、どの environment を読み込むかを決定します。例：引数として environment を取る build メソッドを呼び出した場合、MyBatis はその environment の設定を使ってビルドを実行します。未定義の environment を指定した場合はエラーが発生します。引数に environment を取らない build メソッドを呼び出した場合はデフォルトの environment が使用されます（上記の例では default="development" と指定されています）。引数に properties のインスタンスを取る build メソッドを実行した場合、これらのプロパティは設定内でアクセスできるように読み込まれます。設定内では ${propName} のように記述することでプロパティを参照することができます。このドキュメントの前の方で説明しましたが、プロパティは mybatis-config.xml ファイルからも参照される可能性があるので、優先順位について理解しておくことが重要です。再掲しておきます。プロパティが複数の箇所で指定されていた場合、MyBatis は次の順序で読み込みます。まず最初に properties 要素のボディで指定されたプロパティが読み込まれます。次に、クラスパスリソースや properties 要素の url 属性で指定された Properties が読み込まれます。先に設定されていた値があれば上書きされます。そして最後にメソッドの引数として渡された値が読み込まれます。ここでも properties 要素のボディで指定された値や resource/url 属性で指定されたファイルから同じキーを持つ値が読み込まれていた場合には上書きされます。従って、メソッド引数として渡されたプロパティが最も優先度が高く、次に resource/url 属性、最も優先度が低いのは properties 要素のボディで指定された値ということになります。まとめると、最初の４つの build メソッドはだいたい同じで、必要に応じて environment と properties をオーバーライドできるメソッドを選択することができます。mybatis-config.xml ファイルから SqlSessionFactory をビルドする例を挙げておきます。ここでは org.apache.ibatis.io パッケージに含まれている Resources ユーティリティクラスを利用しています。このクラスは名前からも分かるように、クラスパスやファイルシステムあるいはウェブ上の URL からリソースを読み込むためのメソッドを提供します。分かりやすい実装なので、ソースを読めばどのようなメソッドが用意されているか分かると思いますが、シグネチャだけリストアップしておきます。もう一つの build メソッドは Configuration のインスタンスを引数に取ります。Configuration クラスには、SqlSessionFactory のインスタンスについて必要とされる設定が全てが含まれています。Configuration クラスを使うと、設定を調べたり、SQL マップの検索、変更を行うこともできます（アプリケーションがリクエストを受け付けた後で SQL マップを操作するのは避けるべきですが）。Configuration クラスは Java API からのみ利用可能で、これまでに出てきた全ての設定にアクセスすることができます。コード内で生成した Configuration のインスタンスを build() メソッドに渡して SqlSessionFactory を作成する簡単な例を挙げておきます。SqlSessionFactory が手に入ったので、SqlSession のインスタンスを生成することができます。SqlSessionFactory には、SqlSession のインスタンスを作成するためのメソッドが６つ用意されています。一般的には、以下のような条件を考慮してメソッドを選ぶことになると思います。: 生成したセッションに対してトランザクション管理が必要か、あるいは auto-commit モード（ほとんどのデータベース／JDBC ドライバで「トランザクション無し」を意味します）で利用するか。: 設定した DataSource 経由で MyBatis に Connection を取得させるか、あるいはあなたが Connection を提供するか。: PreparedStatement の再利用とバッチ更新（update, insert, delete）の両方あるいはどちらか一方を行う必要があるか。上記の判定によって渡すべき引数が決まれば適切な openSession() メソッドを選択することができるはずです。引数を取らないデフォルトの openSession() メソッドは次のような性質を持った SqlSession を生成します。トランザクションスコープが開始されます（つまり auto-commit ではないということです）。 オブジェクトは、現在の environment で設定されている DataSource インスタンスから取得されます。ドライバーまたはデータソースのデフォルトのトランザクション分離レベルが適用されます。PreparedStatement は再利用されず、バッチ更新も行われません。READ_UNCOMMITTEDREAD_COMMITTEDREPEATABLE_READSERIALIZABLEほとんどのメソッドは見たままです。auto-commit を有効にするには、オプションの引数 auto-commit に対して  を指定します。自前の接続を使う場合は、 のインスタンスを引数として渡します。auto-commit と Connection を両方引数に持つメソッドはありませんが、これは MyBatis が渡された Connection のモードをそのまま利用するからです。トランザクション分離レベルを指定する場合、MyBatis が提供する enum 型のラッパー  を引数として渡します。JDBC によって提供される５つのトランザクション分離レベル()  が用意されています。もう一つの引数  は列挙型で、３つの値が定義されています。: 特別なことは行いません。ステートメントを実行するたびに新しい PreparedStatement を作成します。: PreparedStatement を再利用します。: 全ての更新ステートメントをバッチで実行し、途中で SELECT が実行される場合は、より分かりやすい動作となるよう必要に応じてトランザクション境界を設定します。 説明しませんでしたが、SqlSessionFactory にはもう一つ  というメソッドがあります。このメソッドは、MyBatis の実行時設定についての情報を保持する Configuration のインスタンスを返します。 旧バージョンの MyBatis では、セッション、トランザクション、バッチは互いに独立していました。MyBatis 3 では、これら３つは全てセッションのスコープに含まれているので、それぞれを別々に扱う必要はありません。以前説明したように、SqlSession は MyBatis でも最も強力なクラスで、ステートメントの実行、トランザクションのコミットまたはロールバック、Mapper インスタンスの取得を行うメソッドが全て含まれています。SqlSession には 20 を超えるメソッドが定義されていますので、いくつかのグループに分けて説明します。ステートメントを実行するメソッドこれらは、SQL Mapper で定義されている SELECT, INSERT, UPDATE, DELETE の各メソッドを実行するためのメソッドです。ほとんど自明ですが、それぞれ引数としてステートメントの ID とステートメントの引数オブジェクト（プリミティブ、JavaBean、POJO、Map のいずれか）を取ります。selectOne と selectList の違いは、selectOne は１つのオブジェクトまたは null を返さなくてはならないということです。複数のオブジェクトが返されると例外が発生します。結果のオブジェクト数が未知の場合は selectList を使用してください。オブジェクトが存在するかどうかを確認したいのなら、カウント結果（0 or 1）を返すようにした方が良いでしょう。selectMap は、結果のリストを mapKey で指定したプロパティに基づいたマップに格納して返す特殊なメソッドです。ステートメントの引数は不要な場合もあるので、parameter オブジェクトの引数を持たないオーバーロードメソッドも用意されています。insert, update, delete の各メソッドは、ステートメントの実行によって影響を受けた行数を返します。最後に、高度な処理を行うための select メソッドがあります。これらは主に非常に大きなデータセットを扱う場合に、返される行の範囲を限定したり、カスタムの ResultHandler を使って独自に結果処理を行うことができるようになっています。RowBounds 引数を渡すことによって、指定された数のレコードをスキップし、結果として返される行の数を制限することができます。RowBounds クラスはイミュータブルで、コンストラクタ引数として offset と limit を取ります。ドライバーによって得られる効果は異なります。SCROLL_SENSITIVE または SCROLL_INSENSITIVE （つまり FORWARD_ONLY 以外）の結果セットタイプを使った時、最も良いパフォーマンスが得られます。ResultHandler を渡すと、各行を自由に処理することができます。List に追加したり、Map や Set を作成することもできますし、結果を捨てて合計値のみを返すこともできます。ResultHandler を使えば好きな処理を行うことも可能で、MyBatis 自身も内部的に結果リストを構築するために ResultHandler を利用しています。3.4.6 以降では、CALLABLE ステートメントに渡された ResultHandler は、指定されたストアド・プロシージャで宣言されている REFCURSOR 型の OUT 引数全てに対して適用されます。ResultHandler インターフェイスは非常にシンプルです。package org.mybatis.executor.result;
public interface ResultHandler<T> {
  void handleResult(ResultContext<? extends T> context);
}引数 ResultContext を介して結果オブジェクトにアクセスすることができます。ResultContext#getResultCount() メソッドは作成された結果オブジェクトの数を返します。ResultContext#stop() メソッドを呼び出すと、それ以上結果を読み込まないよう MyBatis に指示します。ResultHandler を使用する場合に注意すべき点が２つあります。ResultHandler を引数に取るメソッドから返されるデータはキャッシュされません。複雑な ResultMap では複数行のデータがひとつのオブジェクトにマッピングされることもあります。こうした ResultMap を ResultHandler と併用する際、association や collection のデータがマッピングされる前の状態のオブジェクトが渡される場合があります。バッチ更新ステートメントをフラッシュするメソッドバッチ更新用に JDBC ドライバ内に蓄積されたステートメントを任意のタイミングでデータベースへフラッシュ(実行)するメソッドがあります。このメソッドは、  として  を使用している場合に使用することができます。トランザクションを制御するメソッドトランザクションのスコープを制御するメソッドは４つあります。当然ですが、auto-commit を使用する場合や、外部のトランザクションマネージャーを使っている場合、これらのメソッドは効果がありません。しかし、Connection のインスタンスによって管理されている JDBC トランザクションマネージャーを利用している場合は便利なメソッドです。デフォルトでは、データベースの変更を伴うメソッド insert, update, delete,  を有効化した select が実行されない限り MyBatis は commit を実行しません。何らかの理由でこれらのメソッドを使わずにデータを変更した場合は確実にコミットされるように commit メソッドに引数 true を渡してください（ただし、auto-commit モードのセッションや外部のトランザクションマネージャーを使っている場合は true を渡してもコミットされません）。commit が実行されない場合、MyBatis がロールバックを実行するので、通常明示的に rollback() メソッドを呼び出す必要はありません。しかし、一つのセッションの中で複数のコミットやロールバックが必要とされるようなケースでは、rollback() メソッドを使ってより細かい制御を行うことが可能です。 Mybatis-Spring と MyBatis-Guice では宣言的トランザクションがサポートされています。詳細は各サブプロジェクトのドキュメントを参照してください。ローカルキャッシュMyBatis は２種類の内部キャッシュを使用します。新しいセッションが生成される際、同時にローカルキャッシュが作成され、セッションにアタッチされます。このセッション内で実行されるクエリは全てローカルキャッシュに保存され、同一パラメーターで再度呼び出された場合はデータベースに問い合わせずに結果を返します。ローカルキャッシュは update, commit, rollback, close が実行されるとクリアされるようになっています。デフォルトでは、ローカルキャッシュはセッションが破棄されるまで保持されます。ローカルキャッシュは ResultMap の循環参照の解決やネストされたクエリの効率化にも使用されているため、完全に無効化することはできませんが、localCacheScope に STATEMENT を設定することで保持期間をステートメント単位に変更することができます。localCacheScope に SESSION が設定されている場合、MyBatis は同一オブジェクトへの参照を返すという点に注意してください。返されたオブジェクトやリストなどに変更を加えた場合、ローカルキャッシュの内容が変更されることになるので、セッションが有効な間に同じクエリを発行すると意図しない結果が戻ることになります。同一セッション内で同じクエリを繰り返し発行するようなケースでは、結果として返されたオブジェクトを変更しないほうが無難です。また、次のメソッドを呼び出すことにより任意のタイミングでローカルキャッシュをクリアすることも可能です。確実に SqlSession をクローズする最も重要なのは、オープンした session は必ずクローズする必要があるということです。そのためには次のようなパターンでコードを書くのが最も確実です。try (SqlSession session = sqlSessionFactory.openSession()) {
    // following 3 lines pseudocode for "doing some work"
    session.insert(...);
    session.update(...);
    session.delete(...);
    session.commit();
} SqlSessionFactory と同様、getConfiguration() メソッドを呼び出すことで使用中の Configuration のインスタンスを取得することができます。Mapper を使うSqlSession に用意されている insert, update, delete, select などのメソッドは確かに強力ですが、かなり冗長で、型に安全でないため IDE やユニットテストの機能をフルに活用することができません。既にスタートガイドの章で Mapper を使う例が出てきました。マップドステートメントを実行する際は Mapper クラスを使った方法がより一般的です。Mapper クラスは SqlSession のメソッドに対応したメソッド定義を持つインターフェイスです。次の例は、Mapper クラスで定義されているメソッドが SqlSession のメソッドとどのように対応しているかを表しています。基本的に、それぞれの Mapper メソッドのシグネチャは、対応する SqlSession のメソッドのシグネチャからステートメントの ID を指定する String 型の引数を除いたものになっています。ステートメントの ID は引数で指定するのではなくメソッド名から取得されます。戻り値の型について補足しておくと、クエリの結果が単一オブジェクトの場合はその型と一致している必要があり、複数の場合は配列またはコレクションになります。プリミティブ、Map, POJO, JavaBean など通常の型は一通り指定可能です。 Mapper インターフェイスは、他のインターフェイスを実装したり、他のクラスを継承する必要はありません。定義されているメソッドのシグネチャから対応するステートメントを識別できるようになっていれば OK です。 Mapper インターフェイスは他のインターフェイスを継承することができます。Mapper インターフェイスを XML と組み合わせて使う場合は、ステートメントが正しいネームスペースに含まれるように注意してください。また唯一の制限として、継承関係にある複数のインターフェイスに同じシグネチャを持つメソッドを定義することはできません（そもそも良い考えではありません）。Mapper メソッドに複数の引数を渡すこともできます。ステートメントの中では #{param1}, #{param2} のように引数の順番を変数名として使用することができます。数字ではなく分かりやすい名前で引数を参照したい場合は、アノテーションを使って @Param("paramName") のように指定することもできます（引数が複数存在する場合のみ）。引数として RowBounds のインスタンスを渡すとクエリ結果の行数を制限することができます。Mapper アノテーションMyBatis は当初から XML 駆動型のフレームワークでした。設定ファイルは XML でしたし、マップドステートメントも XML で定義されています。MyBatis 3 からは新しいオプションが追加されました。MyBatis 3 は包括的で強力な Java ベースの Configuration API の上に構築されています。この Configuration API が、XML による設定とアノテーションによる設定の基礎となっています。アノテーションを使うと、シンプルなマップドステートメントを無駄なく実装することができます。 残念ながら、アノテーションの表現力と柔軟性には制限があります。調査や試行錯誤に多くの時間を費やしたにも関わらず、複雑なマッピングをアノテーションで実現することはできません。（例えば）C# の Attributes にはこのような制限が無いので、MyBatis.NET では XML の代わりに Attributes を活用することができます。とは言っても、Java のアノテーションにも利点が無いわけではありません。アノテーション一覧：アノテーション対応する XML 要素アノテーションを付加したネームスペース（＝クラス）に対するキャッシュを設定します。属性: プロパティ値またはプレースホルダ(で定義した構成プロパティで置き換えすることができる)を指定します。属性: 。 (MyBatis 3.4.2+で利用可能)
          別のネームスペースに対して定義されているキャッシュの設定を参照します。XML マッパーで宣言されているキャッシュは、namespace に同一 FQCN が指定されていても独立したキャッシュとして扱われます。属性: 
          このアノテーションを使用する場合は、または属性のどちらかを指定する必要があります。
          属性にはネームスペースを示すJava型(ネームスペース名は指定したJava型のFQCNになる)を、
          属性(この属性は3.4.2以降で利用可能)にはネームスペースを示す名前を指定します。
        結果オブジェクトのコンストラクターに渡す結果のグループを指定します。単一値  の配列を取ります。ConstructorArgs に含まれる個々のコンストラクター引数です。属性: ,
        . id は真偽値で、指定したプロパティがオブジェクトをユニークに識別できる値であることを表します。この働きは XML 要素の  に相当します。
        3.5.4以降では、繰り返し可能な注釈として使用することができます。Case使用する結果マップを決定するための Case のグループを構成します。属性: . case の値は  の配列です。値と対応するマッピングを含む個々の判定条件です。属性: . results は Result の配列を値に取るので、この Case アノテーションは次に挙げる  アノテーションによって定義される実際の resultMap に近いものです。ある結果列とプロパティまたはフィールドのマッピング情報を定義する Results のリストです。属性: . value 属性は  アノテーションの配列です。 id 属性でマッピング情報の名前を指定することができます。onemanyある結果列とプロパティまたはフィールドのマッピング情報を定義します。属性: . id は真偽値で、そのプロパティがオブジェクトの比較に使うよう指示します（XML マッピングにおける id 要素とほぼ同じです）。one は XML における association 要素に、many は collection 要素に相当します（クラス名のコンフリクトを避けるため異なる名称が使われています）。
        3.5.4以降では、繰り返し可能な注釈として使用することができます。複雑型のプロパティのマッピング情報を定義します。属性: (3.5.5以降で利用可能), (3.5.5以降で利用可能).
        select は適切な型を読み込むことができるマップドステートメント（Mapper メソッド）の完全修飾名です。
        fetchType はグローバルな設定  をオーバーライドする場合に指定します。
        resultMap は結果列を単一のコンテナオブジェクト(JavaBeanなど)へマッピングするための結果マップの完全修飾名を指定します。
        columnPrefix はネストした結果マップで結果列をグループ化するためのカラム名のプレフィックスを指定します。
         アノテーション API では結合マッピングがサポートされていません。これは Java アノテーションでは循環参照が許可されないためです。(3.5.5以降で利用可能).
        select は適切な型のコレクションを読み込むことができるマップドステートメント（Mapper メソッド）の完全修飾名です。
        fetchType はグローバルな設定  をオーバーライドする場合に指定します。
        resultMap は結果列をコレクションオブジェクト(JavaBeanのリストなど)へマッピングするための結果マップの完全修飾名を指定します。
        columnPrefix はネストした結果マップで結果列をグループ化するためのカラム名のプレフィックスを指定します。
        このアノテーションは Map を返すメソッドに付加します。結果オブジェクトのリストを Map として返すことができます。単一値  は、結果オブジェクトのプロパティで、Map のキーとして使用されます。マップドステートメントの属性useCache=trueflushCache=FlushCachePolicy.DEFAULTresultSetType=DEFAULTstatementType=PREPAREDfetchSize=-1timeout=-1useGeneratedKeys=falsekeyProperty=""keyColumn=""resultSets=""databaseId=""このアノテーションを使うと、通常マップドステートメントの属性として指定される多様なスイッチや設定オプションにアクセスすることができます。 アノテーションによって、各ステートメントのアノテーションを複雑化することなく、一貫したクリーンな方法で設定にアクセスできるよう工夫されています。キー: Attributes:
        .
        Java アノテーションを使う場合、値として  を指定することはできないという制限があります。これはどういうことかというと、 アノテーションを付加したステートメントにはデフォルトのオプションが適用されるということです。予期しない動作を防ぐため、各オプションのデフォルト値を把握しておくようにしてください。
        (3.5.5以降で利用可能)：の設定がある場合は、
        MyBatisはの指定がないものまたはが提供する値と一致するものを利用します。
        もしの指定があるものとないものを両方見つけた場合は、後者は破棄されます。 は特定のデータベース（Oracle や PostgreSQL など）でのみ必須となります。
         に対して指定可能な値については、上で出てきた insert ステートメントについての説明を参照してください。
          これらのアノテーションは、それぞれ実行対象の SQL に対応しています。各アノテーションは String の配列（単一の String でも OK）を引数に取ります。
          渡された String の配列は、スペース区切りで連結されます。これによって、Java のコード内で SQL を構築するときに良くある 'スペースの付け忘れ' によるバグを防ぐことができます。一応、'+' 記号で連結した文字列を引数とすることも可能です。
          ：SQL ステートメントを構成する String の配列です。
          の設定がある場合は、
          MyBatisはが提供する値と一致するアノテーションに指定されているステートメントを利用します。
          もしの指定があるものとないものを両方見つけた場合は、後者は破棄されます。
        これらのアノテーションは動的 SQL を生成するためのものです。実行時に指定されたメソッドが呼び出され、メソッドから返された SQL ステートメントが実行されます (MyBatis 3.4.6以降では、メソッドの返り値として  を指定することができます)。
        マップドステートメントを実行する際、プロバイダーによって指定したクラスのインスタンスが作成され、指定されたメソッドが実行されます。
        なお、メソッド引数にはMapperメソッドの引数に渡したオブジェクトに加え、(MyBatis 3.4.5以降で利用可能)を介して「Mapperインタフェースの型」「Mapperメソッド」「データベースID」を渡すことができます。(MyBatis 3.4以降では、複数の引数を渡すことができます)
        キー:  にはクラスオブジェクトを指定します
        ( の別名で、どちらか一方を指定する必要があります。
        ただし、グローバル設定としてを指定している場合は両方とも省略することができます)。
         にはメソッド名を指定します
        (MyBatis 3.5.1以降では、 属性を省略することができます。その際MyBatisは、 インタフェースを介して対象メソッドの解決を試み、
        対象メソッドが解決できない場合は、という名前のメソッドを代替メソッドとして利用します)。
        が提供する値と一致するアノテーションに指定されているメソッドを利用します。
        もしの指定があるものとないものを両方見つけた場合は、後者は破棄されます。

         次の章で、クリーンで可読性の高いコードで動的 SQL を構築するためのクラスについて説明します。
#{param1}#{param2}RowBounds@Param("person")#{person}Mapper メソッドが複数の引数を取る場合、このアノテーションを付加することで各引数を名前で参照できるようになります。アノテーションがない場合、各引数は位置を表す数字で  のように参照します（ 引数はカウントしません）。
        引数に  というアノテーションを付加すると、この引数は  として参照できるようになります。beforeこのアノテーションを  が付加されたメソッドに追加することで、XML の  に相当する機能を実現することができます（他のメソッドに追加しても無視されます）。 アノテーションが指定されている場合、 アノテーションや設定プロパティによるキーの自動生成に関する設定は無視されます。
        属性:  SQL ステートメントを構成する String の配列です。  は自動生成されたキーの値が設定される引数オブジェクトのプロパティを指定します。 insert の前にステートメントを実行する場合は true、後に実行する場合は false を指定します。 は keyProperty で指定したプロパティの Java タイプです。 はステートメントの種類で STATEMENT, PREPARED, CALLABLE のいずれかを指定します（デフォルトは PREPARED）。
        が提供する値と一致するアノテーションに指定されているステートメントを利用します。
        もし が付加されているメソッドに追加することで、結果のマッピングに XML の Mapper ファイルで定義されている resultMap 要素を利用することができます。の id を指定します。単一値の  には resultMap の id を指定します。このアノテーションは  や  による指定よりも優先されます。ResultHandler を使うメソッドでは戻り値の型が void となるので、このアノテーションを使って各行のデータをどのクラスにマップするかを指定します。XMLの ResultMap が存在する場合は @ResultMap アノテーションで指定することができます。XML の  要素で resultType が指定されている場合はアノテーションによる指定は不要です。それ以外の場合、例えば @Select アノテーションが付加された引数に ResultHandler を含むメソッドの場合は戻り値の型は void である必要があるので、このアノテーション（あるいは @ResultMap）を使って型を指定する必要があります。メソッドの戻り値の型が void 以外の場合、このアノテーションは無視されます。このアノテーションを使用すると、メソッドを Mapper インタフェースに定義したメソッド経由で呼び出すことができます。(MyBatis 3.3以上)Mapper アノテーションのサンプル次のコードは @SelectKey アノテーションを使って insert 前にシーケンスの値を取得する例です。次のコードは @SelectKey アノテーションを使って insert 後に identity の値を取得する例です。次のコードは  アノテーションを使って メソッドを呼び出す例です。次のコードは @Results アノテーションの id 属性で名前を指定する例です。次のコードは SQLプロバイダー用のアノテーションを使用して、パラメータをひとつ受け取る例です。次のコードは SQLプロバイダー用のアノテーションを使用して、複数パラメータをひとつ受け取る例です。@SelectProvider(type = UserSqlBuilder.class, method = "buildGetUsersByName")
List<User> getUsersByName(
    @Param("name") String name, @Param("orderByColumn") String orderByColumn);

class UserSqlBuilder {

  // @Paramを使わない場合は, Mapperメソッドと同じ引数で定義する必要があります。
  public static String buildGetUsersByName(
      final String name, final String orderByColumn) {
    return new SQL(){{
      SELECT("*");
      FROM("users");
      WHERE("name like #{name} || '%'");
      ORDER_BY(orderByColumn);
    }}.toString();
  }

  // @Paramを使う場合は, 必要な引数のみ定義することができます。
  public static String buildGetUsersByName(@Param("orderByColumn") final String orderByColumn) {
    return new SQL(){{
      SELECT("*");
      FROM("users");
      WHERE("name like #{name} || '%'");
      ORDER_BY(orderByColumn);
    }}.toString();
  }
}次のコードは、グローバル設定を利用して全てのマッパーメソッドで同じSQLプロバイダクラスを利用する例です。(3.5.6以降で利用可能)
Configuration configuration = new Configuration();
configuration.setDefaultSqlProviderType(TemplateFilePathProvider.class); // 全てのマッパーメソッドで利用するSQLプロバイダクラスを指定する
// ...
// 各メソッドのSQLプロバイダアノテーションの type または value 属性は省略することができ、
// 省略した場合はMyBaitsはグローバル設定の defaultSqlProviderType に指定されているクラスを適用する
public interface UserMapper {

  @SelectProvider // @SelectProvider(TemplateFilePathProvider.class) と同義
  User findUser(int id);

  @InsertProvider // @InsertProvider(TemplateFilePathProvider.class) と同義
  void createUser(User user);

  @UpdateProvider // @UpdateProvider(TemplateFilePathProvider.class) と同義
  void updateUser(User user);

  @DeleteProvider // @DeleteProvider(TemplateFilePathProvider.class) と同義
  void deleteUser(int id);
}次のコードは、(MyBatis 3.5.1以降で利用可能)のデフォルト実装の利用例です。@SelectProvider(UserSqlProvider.class)
List<User> getUsersByName(String name);

// SQLプロバイダクラスにProviderMethodResolverを実装する
class UserSqlProvider implements ProviderMethodResolver {

  // デフォルト実装では、マッパーメソッドと同名のメソッドが対象メソッドとして扱われます。
  public static String getUsersByName(final String name) {
    return new SQL(){{
      SELECT("*");
      FROM("users");
      if (name != null) {
        WHERE("name like #{value} || '%'");
      }
      ORDER_BY("id");
    }}.toString();
  }

}属性(3.5.5以降で利用可能)の利用例です。
@Select(value = "SELECT SYS_GUID() FROM dual", databaseId = "oracle") // DatabaseIdProviderが提供する値が "oracle" の時にこのステートメントを利用する
@Select(value = "SELECT uuid_generate_v4()", databaseId = "postgres") // DatabaseIdProviderが提供する値が "postgres" の時にこのステートメントを利用する
@Select("SELECT RANDOM_UUID()") // DatabaseIdProviderの設定がないまたはDatabaseIdProviderが提供する値に一致しない時にこのステートメントを利用する
String generateId();

  The ,
  the MyBatis use the 
  that matches the current one. If found with and without the /Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/ja/xdoc/sqlmap-xml.xmlMyBatis 3 | Mapper XML ファイルMapper XML ファイル
        Mapped Statement こそ MyBatis のパワーの源です。
        ここで魔法がかけられているのです。
        Mapper XML ファイルは、そのパワーの割に比較的シンプルです。
        JDBC で同じ処理を書くのと比べると、９割以上のコードが省略できると思います。
        MyBatis は SQL にフォーカスし、可能な限りあなたの邪魔をしないように設計されています。
      
        Mapper XML ファイルの第一階層の要素は下記のとおりです（この順番で定義する必要があります）。
      
          – 指定されたネームスペースに対するキャッシュの設定です。
        
          – 別のネームスペースで定義されているキャッシュ設定を参照します。
        
          – データベースから取得した結果セットを Java オブジェクトにマッピングするための情報を記述する、最も複雑で強力な要素です。
        
            – 非推奨！ パラメーターをマップする古い方法です。インラインパラメーターの使用が推奨されており、この要素は将来削除される予定です。ここでは解説しません。
          
          – 他のステートメントから参照することができる、再利用可能な SQL 文字列です。
        
          – マップされた INSERT ステートメントです。
        
          – マップされた UPDATE ステートメントです。
        
          – マップされた DELETE ステートメントです。
        
          – マップされた SELECT ステートメントです。
        
        次の章では、それぞれの要素について詳しく説明していきます。
        まずはステートメントからです。
      
          select ステートメントは、MyBatis で最も頻繁に使われる要素のひとつです。
          データを取り出すことができてはじめてデータベースにデータを追加する意味があるので、ほとんどのアプリケーションではデータを変更するよりも検索する回数の方が多くなります。
          insert, update, delete のそれぞれに対して、多くの select があるはずです。
          これは MyBatis の大原則の一つであり、クエリ発行と結果のマッピングに注力している理由でもあります。
          シンプルなケースでは、select 要素は非常に簡単です。１つ例を挙げましょう。
        
          これは selectPerson というステートメントで、int （または Integer）型の引数を取り、列名を key、値を value として保持する HashMap を返します。
        
          パラメーターは次のように記述されています。
        
          このように記述すると、MyBatis は PreparedStatement のパラメーターを作成します。
          JDBC では PreparedStatement を作成する場合の '?' に相当します。
        // Similar JDBC code, NOT MyBatis…
String selectPerson = "SELECT * FROM PERSON WHERE ID=?";
PreparedStatement ps = conn.prepareStatement(selectPerson);
ps.setInt(1,id);
          JDBC 単体で select 結果を展開してオブジェクトのインスタンスにマップするためにはもっと多くのコードが必要ですが、MyBatis を使えばそうしたコードは書かずに済みます。
          パラメーターと結果のマッピングについては他にも知っておくべきことが数多くあります。
          これらについては、後ほどそれぞれに独立した章を用意して説明します。
        
          ステートメントに関して細かい設定ができるように、select 要素には多くの属性があります。
        Select Attributes属性このネームスペース内で固有な識別子。ステートメントを参照する際に使用します。このステートメントに渡される引数の型。完全修飾クラス名またはエイリアス。TypeHandler は実際の引数に応じて自動的に導出されるため、この属性は省略可能です。デフォルト値：未設定
              
                  別の場所で定義されている  を参照する非推奨の方法。インラインパラメーターマッピングと  属性を使用してください。
                
                このステートメントから返されるオブジェクトの型。完全修飾クラス名またはエイリアス。ステートメントがコレクションを返す場合は、コレクションの型ではなくコレクションに含まれるオブジェクトの型を指定する必要があります。 は、どちらか一方のみ指定可能です。
              
                別の場所で定義されている  を参照します。 Result Map は MyBatis の中でも最も強力な機能で、深く理解すれば複雑なマッピングが必要となる様々なケースに対応することができます。
                true を指定した場合、ステートメント実行時にローカルキャッシュおよび２次キャッシュがフラッシュ（＝クリア）されます。select ステートメントの場合、デフォルト値は  です。
              
                true を指定した場合、ステートメントの結果が２次キャッシュに保存されます。select ステートメントの場合、デフォルト値は 
                ドライバーがデータベースからの応答が戻らない場合に、ドライバーが例外を投げるまでの最大待機時間（単位：秒）を設定します。デフォルトは未設定（ドライバー依存）です。
              
                ドライバーが結果を返す際に内部的に使用するキャッシュのサイズを指定します（ドライバーに対するヒントです）。デフォルトは未指定（ドライバー依存）です。
              STATEMENTPREPAREDCALLABLEStatementPreparedStatementCallableStatement
                 MyBatis がクエリを実行する際に使用する Statement の種類を指定します。設定可能な値は  で、それぞれ  が使用されます。デフォルトは FORWARD_ONLYSCROLL_SENSITIVESCROLL_INSENSITIVEDEFAULT(未指定と同じ) のいずれかを指定します。デフォルトは未指定（ドライバー依存）です。
              databaseIdProvider が設定されている場合、MyBatis は定義されているステートメントの中で  属性を持ったステートメントをロードします。
                同じステートメントで、 属性が指定されているものと指定されていないものが両方定義されていた場合、指定がないステートメントは無視されます。
              この属性は結果がネストされた select ステートメントでのみ有効です。true が設定された場合、MyBatis はクエリの結果が正しい順番にソートされているという前提でマッピングを実行します。これによりメモリ消費を抑えることができます。
                デフォルトは 複数の ResultSet を利用する場合にのみ有効です。ステートメントが返す ResultSet にそれぞれ任意の名前を付けてリストアップします。名前はカンマで区切ります。
              ResultSet を返す INSERT, UPDATE, DELETE 文を記述する場合に true をセットします。これによりトランザクション制御が正しく実行されるようになります。 も参照してください。 デフォルト：  （3.5.12 以降）
              
          データを変更するステートメントである insert, update, delete は、非常によく似た実装となっています。
        
                  別の場所で定義されている parameterMap を参照する非推奨の方法。インラインパラメーターマッピングと parameterType 属性を使用してください。
                
                true を指定した場合、ステートメント実行時にローカルキャッシュおよび２次キャッシュがフラッシュ（＝クリア）されます。insert, update, delete ステートメントの場合、デフォルト値は 
                ドライバーがデータベースからの応答が戻らない場合に、ドライバーが例外を投げるまでの最大待機時間を設定します。デフォルトは未設定（ドライバー依存）です。
              
                 MyBatis がクエリを実行する際に使用する Statement の種類を指定します。設定可能な値は STATEMENT, PREPARED, CALLABLE で、それぞれ Statement, PreparedStatement, CallableStatement が使用されます。デフォルトは PREPARED です。
              （insert, update のみ）MyBatis に対して、JDBC の getGeneratedKeys メソッドを使ってデータベース側で自動生成されたキーを取得するよう指示します（例えば MySQL や SQL Server のような RDBMS における auto increment が設定された列の値が取得できます）。デフォルト値は false です。
              
                （insert, update のみ）getGeneratedKeys メソッドまたは selectKey 要素で指定されたクエリによって取得したキーの値は、ここで指定したプロパティにセットされます。カンマ区切りでの複数指定にも対応しています。
              （insert, update のみ）テーブル内で自動生成が設定されている列の名前を指定します。この設定は、特定のデータベース（例えば PostgreSQL）で、テーブルの先頭以外の列にキーの自動生成が設定されている場合にのみ必要となります。カンマ区切りでの複数指定にも対応しています。
              以下、insert, update, delete ステートメントの例をいくつか挙げておきます。
          前述のように、insert は自動生成されたキーを扱うため、追加の属性や子要素を持つことができるようになっています。
        
          お使いのデータベースがキーの自動生成に対応しているなら（MySQL や SQL Server は対応しています）、単純に useGeneratedKeys に true を設定し、keyPropoerty でキーが格納されるプロパティを指定するだけです。
          例えば上記の Author テーブルで id 列に自動生成が設定されていた場合、ステートメントは次のように書くことができます。
        
          複数行の一括挿入に対応したデータベースなら、  のリストまたは配列を引数として渡して自動生成された id の値を一括取得することも可能です。
        
          主にキーの自動生成に対応していないデータベースやドライバーのため、MyBatis はもうひとつ別の方法を提供しています。
        
          全く実用的ではありませんが、MyBatis の柔軟さを示す意味も込めて、ID をランダムに生成する例を挙げておきます。
        
          上記の例では、最初に selectKey ステートメントが実行され、Author オブジェクトの id プロパティに生成された乱数がセットされます。
          次に、insert ステートメントが実行されます。
          こうすることで、Java 側でややこしいコードを書かなくても自動生成と同様の結果を得ることができるようになっています。
        
          selectKey 要素は次の属性を持っています。
        selectKey ステートメントの結果がセットされるプロパティを指定します。カンマ区切りでの複数指定にも対応しています。プロパティに対応する結果セット中の列名を指定します。カンマ区切りでの複数指定にも対応しています。
                結果の型を指定します。ほとんどの場合、MyBatis は自動的に型を推測することができますが、念のため設定しておいても害はありません。文字列も含めて、任意の単純型を指定することができます。複数の列が自動生成対象となっている場合、対応するプロパティを持つクラスあるいは Map を指定することができます。
              
                BEFORE または AFTER が指定可能です。BEFORE を指定した場合、最初に selectKey を実行して keyProperty に取得したキーを設定し、その後で insert を実行します。
                AFTER を指定した場合、先に insert を実行してから selectKey ステートメントを実行します。
                後者は、Oracle のように insert ステートメントの中に sequence の呼び出しを含むようなケースで良く使われます。
              
                select などと同じく Statement の種類を指定することができます。設定可能な値は STATEMENT, PREPARED, CALLABLE で、それぞれ Statement, PreparedStatement, CallableStatement が使用されます。
              <select />
          例外として、INSERT, UPDATE, DELETE 文から ResultSet を返す SQL 文（PostgreSQL, MariaDB の  , MS SQL Server の  など）で結果をマップするためには  を使用する必要があります。
        
          この要素を使うと、再利用可能な SQL コードのスニペットを定義しておいて、他のステートメントにインクルードすることができます。このときパラメータを指定することもできますが、インクルードの解決はロード時に行われるので、静的な文字列のみ指定可能です。
          上記の SQL スニペットを他のステートメントにインクルードするには、次のように記述します。
        
          呼び出し側の property 要素で指定された値を、sql 要素に内包された include 要素の refid 属性や property 要素の value 属性として指定することも可能です。
          これまでのステートメントの例では、すべて単純なパラメーターを利用していました。パラメーターは非常に強力な要素です。単純な用途（たぶん全用途の９割くらい）については、特筆すべきことはありません。
          上記は、名前を指定してパラメーターを参照するごく簡単な例です。parameterType が int と指定されていますので、好きな名前を使って参照することができます。プリミティブ型や Integer, String などの単純型はプロパティを持たないので、引数の参照はパラメーターの値そのものに置き換えられます。
          パラメーターとして複合型を渡した場合はもう少し複雑です。次の例を見てください。
        
          User 型のオブジェクトがパラメーターとしてステートメントに渡されると、id, username, password の各プロパティが参照され、その値が PreparedStatement の引数として渡されます。
        
          このように、ステートメントにパラメーターを渡すだけならとても簡単です。しかし、パラメーターマップには更にいろいろな機能があります。
        
          まず、他と同じ様に、より具体的に型を指定することができます。
        
          他と同様、ほとんどの場合 javaType は自動的に検出されますが、例外は HashMap です。パラメーターとして HashMap を使う場合は、正しい TypeHandler が使用されるよう javaType を指定してください。
        重要 JDBC の仕様上、値として null を設定する場合は JDBC タイプが必須となります。
          詳しくは PreparedStatement.setNull() メソッドの javadoc を参照してください。
        
          タイプハンドラーの完全修飾クラス名またはエイリアスを指定して、特定のタイプハンドラーを割り当てることもできます。
        
          だんだんゴチャゴチャしてきましたが、実際のところ、これらの属性を指定することは滅多にないと思います。
        
          数値型に関しては、有効桁数を指定するための numericScale という属性もあります。
        
          最後になりますが、mode 属性で IN, OUT, INOUT パラメーターを指定することができます。
          OUT または INOUT の場合は、パラメーターオブジェクトのプロパティの値が変更されます。
          mode が OUT または INOUT で jdbcType が CURSOR（Oracle の REFCURSOR）の場合は、ResultSet とパラメーターの型をマッピングする resultMap を指定する必要があります。ただし jdbcType として CURSOR を指定した場合 javaType には自動的に ResultSet が設定されますので、javaType の指定は省略可能です。
        
          MyBatis ではより高度な struct のようなデータ型もサポートされていますが、OUT パラメーターを登録するときに型名を指定する必要があります。
        
          このように多くの強力なオプションがあるわけですが、ほとんどの場合、単純にプロパティ名を指定すれば、後は MyBatis がよきに計らってくれるはずです。
          あとは、null が設定可能な列に対して jdbcType を指定するくらいでしょう。
        
          文字列代入
        
          デフォルトでは、#{} という表記を使うと PreparedStatement のプロパティが生成され、PreparedStatement の引数（? の部分）に対して安全な値が設定されるようになっています。
          これは安全かつ高速なので、ほとんどすべてのケースで推奨される方法ですが、時には文字列をそのまま SQL 文に挿入した方が都合が良い場合があります。例えば ORDER BY 句は以下のように記述できます。
        
          この場合、MyBatis は引数として渡された文字列を変更したりエスケープしたりしません。
        
          文字列代入は、メタ情報(例：テーブル名やカラム名など)をSQLステートメントへ動的に埋め込みたい場合に非常に便利な仕組みです。
          例えば、任意のカラム値に一致するレコードを取得する場合に、以下のようにカラム毎にメソッドを用意するのではなく、
          

          指定したカラムの値に一致するレコードを取得するメソッドを一つ用意するだけで、同じことを実現することができます。

           は指定した文字列(カラム名)が直接代入され、 はバインド変数として扱われるため、
          以下のように使用することができます。
          
          この考え方はテーブル名にも適用することができます。
         この方法を使って、ユーザーが入力した文字列を直接 SQL 文に代入するのは危険です。SQL インジェクションの原因となる可能性がありますので、ユーザーによる入力を受け付けないようにしておくか、常にプログラム側で独自にエスケープやチェックの処理を行うようにしてください。
        
          MyBatis の中で最も重要かつ強力なのが resultMap 要素です。resultMap のおかげで、JDBC を使って ResultSet からデータを取得する場合に書かなくてはならないコードの９割を省くことができ、またときには JDBC がサポートすらしていないことも可能となるのです。
          実際、複雑なクエリの結果を結合してマッピングするコードを書く場合、数千行ものコードになってしまう場合もあります。
          ResultMap は、簡単なステートメントなら明示的にマッピングな記述を省略でき、複雑なステートメントの場合でもオブジェクト同士の関連付けを行うための必要最小限のコードのみを記述すれば良いように設計されています。
        
          明示的な resultMap を必要としない、簡単な Mapped Statement については既に例として出てきました。
          この例の場合、resultType で指定された通り、すべての列が自動的に HashMap のキーとしてマップされます。
          便利な時もありますが、HashMap は良いドメインモデルとは言えません。
          ほとんどのアプリケーションではドメインモデルとして JavaBeans や POJO (Plain Old Java Objects) を使っていると思います。MyBatis はどちらもサポートしています。
          次のような JavaBean があったとします。
        
          JavaBeans の仕様によれば、上記のクラスは３つのプロパティ id, username, hashedPassword を持っているということになります。
          これらのプロパティは、先に挙げた select ステートメントの中で指定されている列名と一致しています。
        
          このような条件を満たす JavaBean であれば、HashMap のときと同じように ResultSet にマップすることができます。
        
          タイプエイリアスを使えば何度も完全修飾クラス名を入力しなくて済む、ということも思い出してください。
        
          こうしたケースでは、名前に基づいて列を JavaBean にマップするための ResultMap が MyBatis によって自動的に作成されます。
          もし列名が一致しない場合、select 文で列に別名をつけることで対応可能です（列の別名は標準 SQL の機能です）。
        <select id="selectUsers" resultType="User">
  select
    user_id     as "id",
    user_name     as "userName",
    hashed_password   as "hashedPassword"
  from some_table
  where id = #{id}
</select>
          ResultMap の素晴らしいところは、まだ一つの例も挙げていないにも関わらず、あなたは既にその多くを学んでいるということです。
          これらのシンプルなケースでは既に見てきた以上のことは何も必要ありません。
          列名の不一致を解消するもう一つの方法でもありますが、この最後のサンプルで resultMap を明示的に定義したらどうなるか見てみましょう。
        
          そして、resultMap 属性を使って定義した ResultMap を参照するステートメントは以下のようになります（resultType 属性は削除しています）。
        
          全てがこんなに簡単なら良いのでしょうが、そう甘くはありません。
        高度な結果マッピング
          MyBatis は「データベースは必ずしも希望通りに定義されている訳ではない」という思想に基づいて設計されています。
          すべてのデータベースが完全な第三正規形あるいは BCNF なら最高ですが、実際はそうではありません。
          また、たったひとつで全てのアプリケーションに適合できるようなデータベースを作ることができたら素晴らしいですが、これも現実とは異なります。
          こうした問題に対する MyBatis の答えが Result Map です。
        例えば、こんなステートメントをどうやってマップすれば良いのでしょう？<!-- Very Complex Statement -->
<select id="selectBlogDetails" resultMap="detailedBlogResultMap">
  select
    B.id as blog_id,
    B.title as blog_title,
    B.author_id as blog_author_id,
    A.id as author_id,
    A.username as author_username,
    A.password as author_password,
    A.email as author_email,
    A.bio as author_bio,
    A.favourite_section as author_favourite_section,
    P.id as post_id,
    P.blog_id as post_blog_id,
    P.author_id as post_author_id,
    P.created_on as post_created_on,
    P.section as post_section,
    P.subject as post_subject,
    P.draft as draft,
    P.body as post_body,
    C.id as comment_id,
    C.post_id as comment_post_id,
    C.name as comment_name,
    C.comment as comment_text,
    T.id as tag_id,
    T.name as tag_name
  from Blog B
    left outer join Author A on B.author_id = A.id
    left outer join Post P on B.id = P.blog_id
    left outer join Comment C on P.id = C.post_id
    left outer join Post_Tag PT on PT.post_id = P.id
    left outer join Tag T on PT.tag_id = T.id
  where B.id = #{id}
</select>
          あなたはおそらく、Author によって書かれた、たくさんの Post を持つ Blog といったようなオブジェクトモデルにマップしたいと考えるでしょう。
          次に上げるのは、複雑な ResultMap の完全な例です（Author, Blog, Post, Comments, Tags はすべてタイプエイリアスとします）。
          後ほどひとつずつ説明しますが、とりあえず目を通してみてください。
          最初は難解に思えるかも知れませんが、実際は非常にシンプルです。
        
          resultMap 要素には多くの子要素や階層構造があり、それぞれについて多少説明が必要です。
          以下は resultMap 要素の構成要素です。
         - このコンストラクタ引数が ID であることを明示します。ID 列を明示することによって全体のパフォーマンスが向上します。 - 通常のコンストラクタ引数です。 - クエリ結果をコンストラクタに渡してクラスのインスタンスを作成する場合に使用します。
             – このフィールドまたはプロパティが ID であることを明示します。ID を明示することによって全体のパフォーマンスが向上します。 – フィールドまたは JavaBean のプロパティにセットされる通常のデータです。ネストされた Result Map – アソシエーション自身も resultMap として記述します。他で定義されている resultMap を参照することもできます。
               – 複雑型のアソシエーションを定義します。多くのマッピングはこのタイプに当てはまります。
            ネストされた Result Map – コレクション自身も resultMap として記述します。他で定義されている resultMap を参照することもできます。 – 複雑型のコレクションを定義します。
            ネストされた Result Map – case も Result Map なので、resultMap とほぼ同じ要素を持つことができます。また、別の場所で定義された resultMap を参照することもできます。
                   – case は Result Map の一種で、値が一致した場合に使用されます。
                 – 結果の値を使ってどの resultMap を使用するか決定します。
            ResultMap Attributesこのネームスペース内で固有の識別子。resultMap を参照する際に使用します。Java クラスの完全修飾クラス名またはタイプエイリアスを指定します（前に出てきた標準のタイプエイリアスのリストを参照してください）。
              この resulMap に結果をマッピングする際、自動マッピングを使用するかどうかを true / false で指定します。ここでの指定はグローバルな設定（autoMappingBehavior）より優先されます。デフォルト：未指定
              ベストプラクティス ResultMap は段階的に実装するようにしましょう。ユニットテストも効果的です。
          上で見たような巨大な resultMap を一度に実装しようとするとミスが発生しやすく、作業も困難です。
          シンプルなところからスタートして、ユニットテストを書きながら徐々に拡張しましょう。
          フレームワークの欠点でもありますが、ソースが公開されているかどうかに関わらず、フレームワークはある種のブラックボックスとなり得ます。期待通りに動作していることを確かめるにはユニットテストが一番です。
          ユニットテストはバグを報告する場合も役に立ちます。
        
          次の章ではそれぞれの要素について詳しく見ていきます。
        id と result は結果マッピングの基本となる要素です。
          どちらも、ある列の値を単純型（String, int, double, Date など）のプロパティまたはフィールドにマップするときに使用します。
        
          両者の違いは、 は、その結果が識別子プロパティ（オブジェクトのインスタンスを比較する際に使われます）であることを表すという点のみです。
          これによって全体的なパフォーマンスが向上しますが、特に恩恵をうけるのはキャッシュとネストされた結果マッピング（＝JOIN マッピング）の処理を行うときです。
        
          どちらも多くの属性を持っています。
        id and result Attributes
                結果列の値をマップするフィールドまたはプロパティを指定します。名前が一致する JavaBean プロパティがあれば、そのプロパティが使われます。もしなければ、MyBatis は次に名前が一致するフィールドを探します。
                どちらの場合も、ドット表記を使って複雑型のプロパティを指定することができます。
                例えば、 "username" のような単純なプロパティを指定することもできますし、 "address.street.number" のように複雑なプロパティを指定することもできます。
              
                データベースで定義されている列名、あるいは列の別名を指定します。resultSet.getString(columnName) メソッドの引数として渡される文字列と同じと考えてください。
              
                Java クラスの完全修飾クラス名またはタイプエイリアスを指定します（前に出てきた標準のタイプエイリアスのリストを参照してください）。
                通常、JavaBean にマッピングする場合の javaType は MyBatis によって正しく判別されます。
                ただし、HashMap にマッピングする場合は正しい動作を保証するため適切な javaType を指定するようにしてください。
              
                サポートされている JDBC データ型（この後のテーブルにリストがあります）を指定します。
                JDBC データ型の指定が必須となるのは、insert, update, delete の各ステートメントで null が許可されている列を指定した場合だけです。
                これは JDBC の仕様で MyBatis の仕様ではありません。
                ですから、直接 JDBC を使ったコードを書く場合でも null が許可されている列に対しては、やはりデータ型を指定する必要があります。
              
                デフォルトのタイプハンドラーについては既に説明しました。
                このプロパティを使うと、デフォルトのタイプハンドラーをオーバーライドすることができます。
                タイプハンドラーの完全修飾クラス名またはタイプエイリアスを指定します。
              サポートされている JDBC データ型
          参考として、MyBatis に含まれている JdbcType 列挙型によってサポートされている JDBC データ型を以下に挙げておきます。
        
          ほとんどの DTO (Data Transfer Object) やドメインモデルではプロパティを使って値を設定することができますが、時にはイミュータブルなクラスを使いたい場合もあるかも知れません。
          通常更新されることのない参照用データを含むテーブルなどはイミュータブルクラスに向いています。
          コンストラクタインジェクションを使うとインスタンス化の際に値を設定することができるので、カプセル化の妨げとなる public メソッドの定義が不要となります。
          MyBatis は private として定義されているプロパティやフィールドもサポートしていますが、コンストラクタインジェクションを好む人もいると思います。
           要素を使うとコンストラクタインジェクションによって値をマップすることが可能となります。
        
          次のようなコンストラクタを考えてみます。
        public class User {
   //...
   public User(Integer id, String username, int age) {
  //...
  }
//...
}コンストラクタ経由で値をマップするためには、指定された引数にマッチするコンストラクタを特定する必要があります。
          下記の例では、MyBatis は３つの引数  をこの順番で持つコンストラクタを探します。<constructor>
   <idArg column="id" javaType="int"/>
   <arg column="username" javaType="String"/>
   <arg column="arg" javaType="_int"/>
</constructor>
          上記の指定方法では引数の型を順番通りに並べる必要がありますが、引数の多いコンストラクタを扱うのには向いていません。
          3.4.3 以降では、引数名を指定することによって arg 要素を順不同で記述できるようになりました。引数を名前で指定するためには、各引数に  アノテーションを追加するか、プロジェクトを '-parameters' オプション付きでコンパイルし、 に true （デフォルト値です）を設定します。
          下記の指定では２番めと３番目の引数の順番がコンストラクタの宣言と異なりますが、引数名が指定されているので正しく動作します。
        
          引数と同じ名前、同じ型を持つ書き込み可能なプロパティが存在する場合  は省略可能です。
        
          それ以外の属性とルールについては通常の id, result 要素と同じです。
        
                別の場所で定義されているステートメントの ID を指定します。
                ステートメントの結果として取得したデータがこのプロパティにマップされます。
                指定された select ステートメントには column 属性で指定した列の値が引数として渡されます。
                詳細は association 要素の説明を参照してください。
              
                別の場所で定義されている ResultMap の ID を指定します。ネストされた結果をこのプロパティにマップする際、指定した ResultMap が使われます。
                この方法は、別の select 文を実行する方法の代わりに使うことができ、複数のテーブルを結合して取得した ResultSet をマップすることができます。
                このような ResultSet には重複や繰り返しが含まれているため、正しく分解してからネストされたオブジェクトグラフにマップしてやる必要がありますが、MyBatis ではこの処理を実現するため Result Map を連結できるようになっています。
                コンストラクタ引数の名前を指定します。引数名を指定することで arg 要素を順不同で記述できるようになります。詳細は上記の説明を参照してください。
                導入されたバージョン: 3.4.3
              <association property="author" column="blog_author_id" javaType="Author">
  <id property="id" column="author_id"/>
  <result property="username" column="author_username"/>
</association>
          association 要素は "has-one" タイプのリレーションシップを扱います。
          例えば、上で出てきたサンプルの Blog は１つの Author を持っています。
          アソシエーションは、他の result とほぼ同じように動作します。
          値を設定するプロパティ、値の取得元となる列、プロパティの javaType （ほとんどの場合自動で検出可能）、必要なら jdbcType、またデフォルトのタイプハンドラーをオーバーライドしたい場合は typeHandler を指定します。
        
          association が他と異なるのは、アソシエーションを読み込む方法を MyBatis に伝える必要があるという点です。これには２つの方法があります。
        
            select をネストする：別のマップドステートメントを実行してその結果を読み込む方法です。
          
            結果をネストする：ネストした Result Map を使って結合（Join）した結果を読み込む方法です。
          
          まずは要素の属性を調べてみましょう。
          select, resultMap 以外の属性は result 要素と同じです。
        ネストされた select を使って association を読み込む
                ネストされた select ステートメントに引数として渡される列名、あるいは列の別名を指定します。resultSet.getString(columnName) メソッドの引数として渡される文字列と同じと考えてください。
                Note: 複合キー（composite key）を扱う場合、column="{prop1=col1,prop2=col2} のように記述することで複数の列名を指定することができます。この例ではネストされた select の実行時に prop1 と prop2 が引数として渡されます。
              
                この表の後に詳しいサンプルがあります。
                Note: 複合キー（composite key）を扱う場合、column="{prop1=col1,prop2=col2} のように記述することで複数の列名を指定することができます。この例ではネストされた select の実行時に prop1 と prop2 が引数として渡されます。
              
                任意の属性で、グローバルな  の設定をオーバーライドする場合に指定します。
                指定可能な値は 
          これだけです。
          select ステートメントが二つありますが、一つは Blog、もう一つは Author を読み込むための selct です。
          Blog の resultMap を見ると、author プロパティを読み込むために "selectAuthor" ステートメントを使うように指示されています。
        
          他のプロパティは自動的に読み込まれます（列名とプロパティ名が一致していることが前提となります）。
        
          この方法は簡単ですが、大量のデータやリストを扱うのには向いていません。
          この問題は "N+1 セレクト問題" として知られています。
          要約すると、"N+1 セレクト問題" が発生する仕組みは下記のようなものです。
        レコードのリストを取得するために SQL ステートメントを一つ実行します（これが "+1" です）。結果に含まれる各レコードに対して、その詳細を取得するための select 文が一回ずつ実行されます（これが "N" です）。
          場合によっては数百、数千もの SQL ステートメントが実行されることになるので、あまり良い方法とは言えません。
        
          幸い MyBatis ではこのようなクエリに対して遅延読み込み（Lazy load）を設定することができるので、すべてのクエリが同時に実行されるような状況を避けることも可能です。
          ただし、リストを読み込んだ直後に各要素を反復処理してネストされたデータにアクセスするような処理を行うと、すべての遅延読み込みが実行されるのでパフォーマンスが極端に悪化します。
        
          では、もう一つの方法について説明しましょう。
        ネストされた結果を使って association を読み込む
                実際のサンプルを見た方が分かりやすいと思います。この表の後に例を挙げます。
              
                複数のテーブルを結合して取得した ResultSet では、列名の重複を防ぐため別名を付けなくてはならない場合があります。
                columnPrefix を指定すると、別の場所で定義されている resultMap を使って別名の付けられた列をマップすることができます。後で説明するサンプルを参照してください。
              
                ネストされた結果をマッピングする際、デフォルトでは子オブジェクトのプロパティに対応する列のうち一つでも null でない値がセットされているものがあれば子オブジェクトが生成されます。notNullColumn に列名（複数可）を指定しておくと、指定された列に null 以外の値がセットされた場合にのみ子オブジェクトが生成されます。デフォルト：未指定
              このプロパティに結果をマッピングする際、自動マッピングを使用するかどうかを true / false で指定します。ここでの指定はグローバルな設定（autoMappingBehavior）より優先されます。この設定は別の場所で定義されている ResultMap には適用されませんので、 が指定されている場合は無効となります。デフォルト：未指定
              
          ネストされたアソシエーションについては、既にとても複雑な例を見ていただきました。次のサンプルは、それと比べるとずっと理解しやすいと思います。ここでは、独立した select を実行する代わりに Blog と Author のテーブルを結合するクエリを実行します。
        <select id="selectBlog" resultMap="blogResult">
  select
    B.id       as blog_id,
    B.title     as blog_title,
    B.author_id   as blog_author_id,
    A.id       as author_id,
    A.username    as author_username,
    A.password     as author_password,
    A.email     as author_email,
    A.bio       as author_bio
  from Blog B left outer join Author A on B.author_id = A.id
  where B.id = #{id}
</select>
          テーブルを結合しているだけでなく、全ての列に固有で分かりやすい別名が指定されていることに注意してください。こうしておくとマッピング作業がずっと楽になります。
          これで結果をマップする準備が整いました。
        <resultMap id="blogResult" type="Blog">
  <id property="id" column="blog_id" />
  <result property="title" column="blog_title"/>
  <association property="author" resultMap="authorResult"/>
</resultMap>

<resultMap id="authorResult" type="Author">
  <id property="id" column="author_id"/>
  <result property="username" column="author_username"/>
  <result property="password" column="author_password"/>
  <result property="email" column="author_email"/>
  <result property="bio" column="author_bio"/>
</resultMap>
          この例では、Blog の "author" を読み込むためのアソシエーションで、別の resultMap "authorResult" を指定しています。
        超重要 ネストされた Result Map では、id 要素が重要な役割を果たします。常に、結果の固有性を判定できる一つ以上のプロパティを id として指定するようにしてください。指定がなくても動作はしますが、パフォーマンスに著しい悪影響を与えます。また、結果の固有性を判定するために必要な最小限のプロパティを指定するようにしてください。主キー（複合キーでも可）は良い選択肢です。
        
          上の例では、別の場所で定義した resultMap 要素を指定してアソシエーションを読み込んでいますが、こうすると Author の resultMap を再利用することができます。再利用する必要がない場合や、単に一つの resultMap にマッピングの情報をまとめておきたい場合には、アソシエーションの Result Map をネストすることもできます。この方法で書き直したのが次の例です。
        
          もしこの Blog に共著者 co-author が設定されていたらどうなるでしょうか。
          select ステートメントは下記のようになります。
        
          Author に対する resultMap は下記のように定義されています。
        
          結果に含まれる列名が resultMap で指定されている列名と異なるので、この resultMap を再利用するためには  を指定する必要があります。
        複数の ResultSet を association にマッピングする複数の ResultSet を返すステートメントをマッピングする場合、 で指定した外部キーと対になってリレーションシップを構成する親オブジェクト側の列を指定します（カンマ区切りで複数指定可能）。
               属性で指定した親オブジェクトの列との照合に使用される外部キーを格納する列を指定します。
              読み込み元の ResultSet の名前を指定します。下記の説明を参照してください。
              バージョン 3.2.3 から、N+1 セレクト問題を解決する新しい方法が追加されました。データベースによってはストアドプロシージャから複数の ResultSet を返すことができます。この機能を利用すると、テーブルの結合（Join）を使わず一度の問い合わせで互いに関連する複数のデータを取得することができます。以下の例では、ストアドプロシージャが２つの ResultSet を返します。１つめの ResultSet には複数の Blog のデータが含まれており、２つめの ResultSet には複数の Author のデータが含まれています。ストアドプロシージャを実行する select 要素の  属性で、それぞれの ResultSet に名前を付けておく必要があります（カンマ区切り）。ここでは、それぞれ blogs, authors としています。下記の resultMap では、authors 内の各 Author が、それぞれ対応する Blog にマッピングされます。
          ここまで "has one" タイプのリレーションシップを扱う方法を見て来ましたが、"has many" の場合はどうしたら良いのでしょうか？これは次の章で説明します。
        
          collection 要素の働きは association とほとんど同じです。同じ説明の繰り返しを省くため、association との違いにフォーカスして見て行きます。
        
          引き続き上記のサンプルを使います。Blog に対する Author は一人だけですが、Post は複数存在します。この関係を Blog クラスで表現すると、次のようになると思います。
        
          collection 要素を使ってこのような List 型のプロパティにネストされた結果セットをマップする場合、select をネストする方法と、結果をネストする方法があります。
        ネストされた select を使って collection を読み込む
          まずは、ネストされた select を使って Blog に関連した Post を読み込む例を見てみましょう。
        
          いろいろ気づいたことがあると思いますが、上で見た association 要素と似た部分が多いと思います。
          まず眼を引くのは collection 要素を使っていることでしょう。次に "ofType" という新しい属性があることに気づくでしょう。
          この属性は、JavaBean のプロパティ（またはフィールド）の型と、コレクションに含まれている型を区別するために必要です。
          したがって、このマッピングは次のように読むことができます。
        このように読めます: "投稿のリストは、Post クラスを要素とする ArrayList に格納される。"
        
          ほとんどの場合、javaType 属性はMyBatis によって推測されるため省略可能です。
          ということで、大抵は下記のように短く書くことができます。
        ネストされた結果を使って collection を読み込む
          ここまで来れば、ネストされた結果を collection に読み込む方法について想像できるのではないでしょうか。
          なぜなら、association と全く同じだからです（ただし、ネストされた select と同様、"ofType" 属性の指定が必要です）。
        まずは SQL を見てみましょう。
          Blog と Post テーブルを結合した上で、マッピングを簡単にするため各列に別名を付けています。
          ここまでくれば、次に挙げたシンプルな ResultMap で、Post のリストも含めて Blog のデータを読み込むことができます。
        
          id 要素の重要さはここでも変わりません。まだ読んでいなければ、上の association 要素についての説明を参照してください。
        
          もし、Post のマッピングを再利用したいのであれば、次のように２つの resultMap に分けて書くこともできます。
        複数の ResultSets を collection にマッピングする
          association で説明したのと同様に、２つの ResultSet を返すストアドプロシージャを呼び出すことができます。１つ目の ResultSet には Blog のリスト、２つ目の ResultSet には Post のリストが含まれているものとします。
         属性で、それぞれの ResultSet に名前を付けておく必要があります（カンマ区切り）。ここでは、それぞれ blogs, posts としています。以下の resultMap では、posts に含まれる Post が、対応する Blog にマッピングされます。Note collection と association のマッピングに関して、階層の深さやオブジェクトの大きさに制限はありませんし、両者を組み合わせることも可能です。
          ただ、パフォーマンスのことは忘れないようにしてください。
          ユニットテストと負荷テストを怠らなければ、あなたのアプリケーションにとっての最適なアプローチを見つけることができます。
          幸いなことに、後で別のアプローチに切り替える場合でも、MyBatis ならコードの変更は最小限（あるいはゼロ）で済みます。
        
          association と collection を使った高度なマッピングはかなり深いテーマです。
          ドキュメントで全てを網羅することはできませんが、少し練習すればすぐに全体がクリアになるはずです。
        
          データベースに対して実行した１回のクエリによって、複数の異なる（何らかの関係を持った）データ型を含む結果が戻ってくることがあります。
          discriminator 要素は、こうしたケースをはじめとして、クラスの継承関係を再現する場合など様々な用途を想定して作られています。
          discriminator は、Java における switch 文と同じように働くので理解するのはそれほど難しくないはずです。
        
          discriminator を定義する場合は column と javaType 属性を指定します。
          ここで指定した column は、MyBatis が比較対象の値を参照する際に使用されます。
          javaType は、値が等しいかどうかを調べる際、確実に正しい比較が行われるように指定します（ですが、ほとんどのケースでは String を指定すれば期待通りに動作するはずです）。
          使用例を見てみましょう。
        
          この例では、MyBatis は結果セットのレコードをひとつずつ取り出して vehicle_type の値を比較します。
          もし、vehicle_type の値が case で指定した条件のいずれかに一致した場合、その case 要素で指定されている resultMap を使って結果のマッピングを行います。
          この処理は排他的に行われます。言い換えると、使われなかった resultMap は無視されるということです（ただし resultMap が継承されている場合は別です。これについてはすぐ後で説明します）。
          一致する case が見つからない場合は、discriminator ブロックの外側で定義されている resultMap だけが適用されます。
          仮に、carResult が次のように定義されていたとします。
        
          この場合、doorCount プロパティのみが読み込まれることになります。
          これによって、完全に独立した discriminator case のグループを定義することができます。親の resultMap と全く関連性のない resultMap であっても構いません。
          今回のケースでは車は乗り物の一種（Car is-a Vehicle）なので、car と vehicle の間に関連性があることは明らかです。
          当然、doorCount 以外のプロパティも読み込んで欲しいと思うでしょう。
          resultMap を一箇所変更すれば、希望通りの動作になります。
        
          これで、vehicleResult と carResult の両方で定義されているすべてのプロパティが読み込まれるようになります。
        
          繰り返しになりますが、別々の resultMap を定義するのが面倒だと考える方もいると思います。
          簡潔にまとまった表記が好みだという方のために、別の記法も用意されています。
        思い出してください
          これらは全て Result Map なので、もし result が全く指定されていなければ、MyBatis が自動的に列名と一致する名前を持つプロパティに値を設定します。
          ですから、上で挙げた例の多くは必要以上に冗長になっているといえます。
          ただ、データベースは複雑ですから全てのケースで自動マッピングが使えるということもないでしょう。
        自動マッピング
          前章では、シンプルなケースでは MyBatis の自動マッピングが利用できるということと、複雑なケースではあなた自身で Result Map を記述する必要があるということを説明しました。
          この章では更に、この２つの方法を同時に利用する方法を説明していきます。
          まず、自動マッピングの動作について詳しく見て行きましょう。
        
          結果を自動マッピングする際、MyBatis は列名と同じ名前を持つプロパティを探します（大文字と小文字は区別しません）。
          例えば  という名前の列と  という名前のプロパティが見つかった場合、MyBatis は  プロパティに  列の値をセットします。
        
          通常、データベースの列名は英数字と単語を区切るアンダースコアで定義され、Java のプロパティはキャメルケースで定義されるのが一般的です。
           に true に設定すると、この一般的な命名規則に基づいて自動マッピングを適用することができます。
        
          Result Map が指定されている場合でも自動マッピングは動作します。この場合、ResultSet に含まれる列のうち、各 Result Map で明示的にマッピングが指定されていない列が自動マッピングの対象となります。
          次の例では、 列が password プロパティにマップされ、 列が自動マッピングの対象となります。
        
          自動マッピングには３つのレベルがあります。
         - 自動マッピングを無効化します。明示的にマッピングが指定されたプロパティにのみ値がセットされます。
           - ネストされた Result Map を持たない Result Map のみが自動マッピングの対象となります。
           - 全ての Result Map が自動マッピングの対象となります。
          
          デフォルト値は  で、それには理由があります。
           が指定されていると、JOIN 句によって複数のエンティティに対する結果が一行に結合されているような場合に自動マッピングによって意図しないマッピングが実行されてしまう場合があります。
          次の例を見てください。
        
          この Result Map では、 の両方が自動マッピングの対象となりますが、 というプロパティがあり、ResultSet に  という列が含まれているため、Author の id に Blog の id がセットされることになります。
          自動マッピングで  を指定する場合は、こうした意図しないマッピングが行われないように注意する必要があります。
        
          尚、グローバルな自動マッピング設定とは別に、 属性を指定することで特定のステートメントでの自動マッピング動作を有効／無効化することもできます。
        
          MyBatis には非常に柔軟なトランザクション対応のクエリキャッシング機能が用意されています。
          MyBatis 3 では、より強力で、かつ簡単に設定できるよう、キャッシュの実装に多くの改良が加えられています。
        
          デフォルトでは、セッション生存期間中のデータを保持するローカルセッションキャッシュのみが有効です。
          グローバルな２次キャッシュを有効にするためには、Mapper XML ファイルに次の一行を追加するだけです。
        
          文字通りこれだけです。この行の効果は次の通りです。
        この SQL マップファイルに含まれる select ステートメントの結果は全てキャッシュされます。この SQL マップファイルに含まれる insert, update, delete ステートメントを実行するとキャッシュがフラッシュされます。このキャッシュは LRU アルゴリズムに基づいて置き換えられます。このキャッシュは経過時間によってフラッシュされることはありません（つまり Flush Interval は設定されていないということです）。このキャッシュはクエリ結果のリストまたはオブジェクトへの参照を 1024 個格納します。このキャッシュは読み書き可能なキャッシュとして扱われます。これはつまり、取得したオブジェクトは共有されず、呼び出した側で安全に変更することができる（別の呼び出し元や他スレッドでの変更の影響を受けない）ということを意味しています。 対応する Java マッパーのステートメントをキャッシュの適用対象に含めるためには  アノテーションで XML マッパーのネームスペースを指定する必要があります。
        
          これらのプロパティは cache 要素の属性で変更することができます。
        
          この設定では、以下のようなキャッシュが作成されます。
        FIFO アルゴリズムに基づいて置き換えられる。60 秒ごとにフラッシュされる。結果オブジェクトまたはリストへの参照を 512 個まで格納できる。返されるオブジェクトは読み取り専用（read-only）（変更した場合、他の呼び出し元や別スレッドからの変更とコンフリクトする可能性がある）。
          指定可能な置換（eviction）ポリシーは以下の通りです。
        
            LRU – Least Recently Used: 最も長いこと使われていないオブジェクトを優先的に削除します。
          FIFO – First In First Out: 最初に登録されたオブジェクトから順番に削除します。
            SOFT – Soft Reference: ガベージコレクターの状態と Soft Reference の規則に基づいてオブジェクトを削除します。
          
            WEAK – Weak Reference: ガベージコレクターの状態と Weak Reference の規則に基づいて、より積極的にオブジェクトを削除します。
          デフォルト値は LRU です。
          flushInterval には、適切な時間（ミリ秒）を表す正の整数を指定することができます。
          デフォルト値は指定なしで、キャッシュがフラッシュされるのはステートメント（insert, update, delete または flushCache が設定された select）が実行された場合のみです。
        
          size には任意の正の整数を指定することができますが、実行環境で利用可能なメモリリソースとキャッシュされるオブジェクトのサイズに配慮してください。デフォルト値は 1024 です。
        
          readOnly 属性には true または false を設定することができます。読み取り専用キャッシュはキャッシュされたオブジェクトのインスタンスをそのまま呼び出し元に返しますので、このオブジェクトを変更すべきではありません。
          読み取り専用キャッシュの利点は非常に高速だということです。
          読み書き可能なキャッシュは、キャッシュされたオブジェクトを複製して（シリアライゼーションを使います）返しますので読み取り専用と比較すると遅いですが安全です。
          デフォルト値は false です。
         ２次レベルキャッシュはトランザクションに対応しています。SqlSession が (1) commit された場合、あるいは (2) flushCache=true が指定された insert/delete/update が実行されずに rollback された場合に２次レベルキャッシュが更新されます。
        カスタムキャッシュを使う
          上記のプロパティを使ってキャッシュをカスタマイズする方法の他に、自作のキャッシュ実装や 3rd パーティのキャッシュソリューションのアダプタを作成してキャッシュの挙動を完全にオーバーライドしてしまうこともできます。
        
          上記は、カスタムキャッシュの実装を使用するための設定例です。
          type 属性で指定されているクラスは org.apache.ibatis.cache.Cache インターフェイスを実装している必要があります。
          このインターフェイスは MyBatis の中では複雑な方ですが、その役割を考えればシンプルです。
        
          あなたが作成したキャッシュを設定するには、キャッシュの実装クラスに public な JavaBean プロパティを追加し、cache 要素でプロパティを渡しします。
          例えば次のように設定すると、あなたが作成したキャッシュの実装クラスの "setCacheFile(String file)" というメソッドが呼び出されます。
        コンフィギュレーション用のプロパティ
          設定対象のプロパティは、単純型であれば String 以外でも使用可能です。
          加えて、に定義した値で置き換えるために、プレースホルダ(例：)を指定することができます。
        
          3.4.2以降では, MyBatisはすべてのプロパティを設定した後に初期化メソッドを呼び出す仕組みをサポートしています。
          この機能の使用したい場合は、あなたが作成したキャッシュの実装クラスにインタフェースを実装してください。
        
          ここで重要なのは、キャッシュの設定とキャッシュのインスタンスは Mapper XML ファイルのネームスペースに関連付けられているということです。
          あるネームスペースに対して定義されているキャッシュは、同じネームスペース内で定義されている全てのステートメントに関連付けられます。
          ステートメントごとにキャッシュとの関連性を変更したり無効化することができるように、二つの簡単な属性が用意されています。
          デフォルトでは、各ステートメントは下記のように設定されています。
        
          上記の設定はデフォルトですので、明示的に上記のように設定する必要はありません。
          デフォルトの動作を変更したい場合に限り、flushCache と useCache 属性を設定するようにしてください。
          例えば、特定の select ステートメントの結果をキャッシュの対象から除外したり、ある select ステートメントを実行する際にキャッシュをフラッシュしたい、といった場合です。
          同様に、キャッシュのフラッシュを伴わない update ステートメントを定義したいと思う時があるかも知れません。
        
          前の章で説明した通り、あるネームスペースに対して設定されているキャッシュが適用されるのは同じネームスペース内で定義されているステートメントのみですし、このキャッシュをフラッシュするのも同じネームスペース内で定義されているステートメントのみです。
          あるキャッシュの設定とインスタンスを複数のネームスペースで共有したいと思う時があるかも知れません。
          その場合、cache-ref 要素を使って別のネームスペースで定義されているキャッシュの定義を参照することができます。
        /Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/ja/xdoc/statement-builders.xmlMyBatis 3 | SQL ビルダークラスSQL ビルダークラス問題Java のコードに SQL を埋め込むのは、Java 開発者にとって最も不愉快なことの一つでしょう。通常これは、SQL を動的に生成する必要がある場合に行われます（そうでなければ、別ファイルやストアドプロシージャといった形で外部化できるはずなので）。これまで見てきたように、MyBatis では XML マッピング機能を使って動的に SQL を生成することができます。しかし、時には Java のコード内で SQL ステートメントを構築しなくてはならない場合もあります。こうした場合に '+' 記号や引用符、改行、整形などの典型的な問題や余分なカンマや AND 演算子を扱うために条件式を入れ子にしたりしなくて済むように、MyBatis にはもう一つの方法を提供しています。
        

// THE PROBLEM
String sql = "SELECT P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME, "
"P.LAST_NAME,P.CREATED_ON, P.UPDATED_ON " +
"FROM PERSON P, ACCOUNT A " +
"INNER JOIN DEPARTMENT D on D.ID = P.DEPARTMENT_ID " +
"INNER JOIN COMPANY C on D.COMPANY_ID = C.ID " +
"WHERE (P.ID = A.ID AND P.FIRST_NAME like ?) " +
"OR (P.LAST_NAME like ?) " +
"GROUP BY P.ID " +
"HAVING (P.LAST_NAME like ?) " +
"OR (P.FIRST_NAME like ?) " +
"ORDER BY P.ID, P.FULL_NAME";

        解決策MyBatis 3 ではこうした問題を解決する際の助けとなる便利なクラス 'SQL' が用意されています。SQL クラスのインスタンスを作成し、順番にメソッドを呼び出していくことで SQL 文を構築することができるようになっています。上記のコードは SQL クラスを使うと次のように書き換えることができます。
      
import org.apache.ibatis.jdbc.SQL;

private String selectPersonSql() {
  return new SQL() {{
    SELECT("P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME");
    SELECT("P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON");
    FROM("PERSON P");
    FROM("ACCOUNT A");
    INNER_JOIN("DEPARTMENT D on D.ID = P.DEPARTMENT_ID");
    INNER_JOIN("COMPANY C on D.COMPANY_ID = C.ID");
    WHERE("P.ID = A.ID");
    WHERE("P.FIRST_NAME like ?");
    OR();
    WHERE("P.LAST_NAME like ?");
    GROUP_BY("P.ID");
    HAVING("P.LAST_NAME like ?");
    OR();
    HAVING("P.FIRST_NAME like ?");
    ORDER_BY("P.ID");
    ORDER_BY("P.FULL_NAME");
  }}.toString();
}
        この例の何がそんなに特別なのでしょうか。よく見るとわかりますが、この例では、誤って "AND" が重複してしまうことや、"WHERE" と "AND" のどちらを使うか、あるいはどちらも使わないか、といったことを考慮せずに書くことができています。SQL クラスは、どこに "WHERE" を挿入すれば良いか、どこで "AND" が必要か、といったことを判断しながら文字列を連結します。
        SQL クラスいくつか例を挙げておきます。

// 匿名内部クラス
public String deletePersonSql() {
  return new SQL() {{
    DELETE_FROM("PERSON");
    WHERE("ID = #{id}");
  }}.toString();
}

// メソッドチェーン（Builder / Fluent スタイル）
public String insertPersonSql() {
  String sql = new SQL()
    .INSERT_INTO("PERSON")
    .VALUES("ID, FIRST_NAME", "#{id}, #{firstName}")
    .VALUES("LAST_NAME", "#{lastName}")
    .toString();
  return sql;
}

// 条件分岐あり（匿名内部クラスからアクセスできるよう、引数は final として宣言されています）
public String selectPersonLike(final String id, final String firstName, final String lastName) {
  return new SQL() {{
    SELECT("P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME");
    FROM("PERSON P");
    if (id != null) {
      WHERE("P.ID like #{id}");
    }
    if (firstName != null) {
      WHERE("P.FIRST_NAME like #{firstName}");
    }
    if (lastName != null) {
      WHERE("P.LAST_NAME like #{lastName}");
    }
    ORDER_BY("P.LAST_NAME");
  }}.toString();
}

public String deletePersonSql() {
  return new SQL() {{
    DELETE_FROM("PERSON");
    WHERE("ID = #{id}");
  }}.toString();
}

public String insertPersonSql() {
  return new SQL() {{
    INSERT_INTO("PERSON");
    VALUES("ID, FIRST_NAME", "#{id}, #{firstName}");
    VALUES("LAST_NAME", "#{lastName}");
  }}.toString();
}

public String updatePersonSql() {
  return new SQL() {{
    UPDATE("PERSON");
    SET("FIRST_NAME = #{firstName}");
    WHERE("ID = #{id}");
  }}.toString();
}

メソッドSELECT 句を開始、あるいは SELECT 句に文字列を追加します。このメソッドは複数回呼び出すことができ、その場合は引数として渡した文字列が SELECT 句に追加されます。引数は通常カンマ区切りの列名あるいはエイリアスのリストですが、ドライバが受け付ける文字列であれば何でも構いません。
              SELECT 句を開始、あるいは SELECT 句に文字列を追加します。また、生成されるクエリに DISTINCT キーワードを追加します。このメソッドは複数回呼び出すことができ、その場合は SELECT 句に引数として渡した文字列が追加されます。引数は通常カンマ区切りの列名あるいはエイリアスのリストですが、ドライバが受け付ける文字列であれば何でも構いません。
              FROM 句を開始、あるいは FROM 句に文字列を追加します。このメソッドは複数回呼び出すことができ、その場合は FROM 句に引数として渡した文字列が追加されます。引数は通常カンマ区切りのテーブル名あるいはエイリアスのリストですが、ドライバが受け付ける文字列であれば何でも構いません。
              呼び出されたメソッドに応じて、新しい JOIN 句を追加します。引数には結合対象のテーブルと結合条件の文字列を指定します。
              新しい WHERE 条件を AND で連結して追加します。このメソッドは複数回呼び出すことができ、その場合は引数で指定した新しい条件が AND と共に追加されます。複数の条件を OR で連結する場合は OR() メソッドを使ってください。
              現在の WHERE 条件を OR で分割します。複数回呼ぶことも出来ますが、連続して呼び出すと不正な SQL が生成される場合があります。
              現在の WHERE 条件を AND で分割します。複数回呼ぶこともできますが、連続して呼び出すと不正な SQL が生成される可能性があります。 はどちらも自動的に  を挟んで引数を連結するので、このメソッドを使うことはまずないと思います。あくまでも API の整合性のために用意されていると考えてください。
              カンマを挟んで  句を追加します。複数回呼ぶことができ、その度にカンマを挟んで新しい条件が追加されます。
              AND を挟んで新しい  句を追加します。複数回呼ぶことができ、その度に AND を挟んで新しい条件が追加されます。複数の条件を OR で連結する場合は OR() メソッドを使ってください。
               句を追加します。
                このメソッドは SELECT(), UPDATE(), DELETE() と一緒に使うと有効になり、
                SELECT()使用時は、OFFSET()と一緒に使うように設計されています。 (3.5.2以降で利用可能)
               句を追加します。
                このメソッドは SELECT() と一緒に使うと有効になり、
                LIMIT()と一緒に使うように設計されています。(3.5.2以降で利用可能)
               句を追加します。
                このメソッドは SELECT() と一緒に使うと有効になり、
                FETCH_FIRST_ROWS_ONLY()と一緒に使うように設計されています。 (3.5.2以降で利用可能)
               句を追加します。
                このメソッドは SELECT() と一緒に使うと有効になり、
                OFFSET_ROWS()と一緒に使うように設計されています。 (3.5.2以降で利用可能)
              対象となるテーブルを指定して delete ステートメントを開始します。通常、この後に WHERE メソッドの呼び出しが続きます。
              対象となるテーブルを指定して insert ステートメントを開始します。通常、この後に一回以上 VALUES() 又は INTO_COLUMNS() と INTO_VALUES() メソッドの呼び出しが続きます。
              update ステートメントの set 句に文字列を追加します。対象となるテーブルを指定して update ステートメントを開始します。通常、この後に一回以上の SET() メソッドと WHERE() メソッドの呼び出しが続きます。
              insert ステートメントに values 句を追加します。第一引数は列のリストで、第二引数は値のリストです。
              
                insert ステートメントにカラムリスト追加します。
                このメソッドは、INTO_VALUES() メソッドと一緒に呼び出します。
              
                insert ステートメントに value 句を追加します。
                このメソッドは、INTO_COLUMNS() メソッドと一緒に呼び出します。
              
                一括挿入用に新しい行領域を追加します。 (3.5.2以降で利用可能)
               、 句は生成されたステートメントにそのまま書き込むという点に注意することが重要です。
          言い換えると、これらの句をサポートしていないデータベースに対して、そのデータベースで解釈可能な表現へ変換することはしません。
          そのため、利用するデータベースがこれらの句をサポートしているか否かを事前に把握しておくことが重要になります。
          もし、利用するデータベースがこれらの句をサポートしていない場合は、SQL実行時にエラーになります。
        バージョン3.4.2以降では、次のように可変長引数を使うことができます。バージョン3.5.2以降では、次のように一括挿入用のステートメントを作成することができます。バージョン3.5.2以降では、次のように検索結果行を制限するための検索ステートメントを作成することができます。SqlBuilder および SelectBuilder （非推奨）
          当初は ThreadLocal 変数を使って Java 言語の制限を補うアプローチを採用していましたが、最近はビルダーパターンや匿名内部クラスを使っているフレームワークが主流となってきていることもあり、このアプローチを使っている SelectBuilder, SqlBuilder クラスは非推奨（deprecated）扱いとなりました。
        
          以下は、非推奨となった SqlBuilder, SelectBuilder のみを対象とした説明になります。
        
            /
            SelectBuilder クラスの ThreadLocal の状態をクリアし、新たなステートメント構築に備えます。新しいステートメントを開始するときは BEGIN() を使い、実行中にステートメントをクリアする場合（条件次第で全く別のステートメントが必要となるようなケース）は RESET() を使うようにすると読みやすいコードになります。
          生成された SQL を返すと同時に、 の状態をリセットします（ の呼び出しと同じ効果を持ちます）。従って、このメソッドは一度しか呼び出すことができません。
          SelectBuilder や SqlBuilder クラスは魔法ではないので、仕組みを理解しておく必要があります。SelectBuilder, SqlBuilder は静的インポート（Static Import）と ThreadLocal 変数を組み合わせることで、条件分岐と相性の良いクリーンな構文で SQL に求められるフォーマット処理を可能にしています。まずどちらかのクラスを静的にインポートしておく必要があります（両方ではありません）。
        例えば、次のようなメソッドを書くことができます。
/* DEPRECATED 非推奨 */
public String selectBlogsSql() {
  BEGIN(); // Clears ThreadLocal variable
  SELECT("*");
  FROM("BLOG");
  return SQL();
}
        
/* DEPRECATED 非推奨 */
private String selectPersonSql() {
  BEGIN(); // Clears ThreadLocal variable
  SELECT("P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME");
  SELECT("P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON");
  FROM("PERSON P");
  FROM("ACCOUNT A");
  INNER_JOIN("DEPARTMENT D on D.ID = P.DEPARTMENT_ID");
  INNER_JOIN("COMPANY C on D.COMPANY_ID = C.ID");
  WHERE("P.ID = A.ID");
  WHERE("P.FIRST_NAME like ?");
  OR();
  WHERE("P.LAST_NAME like ?");
  GROUP_BY("P.ID");
  HAVING("P.LAST_NAME like ?");
  OR();
  HAVING("P.FIRST_NAME like ?");
  ORDER_BY("P.ID");
  ORDER_BY("P.FULL_NAME");
  return SQL();
}
        /Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/ko/xdoc/configuration.xml/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/ko/xdoc/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/ko마이바티스 3 | 매퍼 설정 fromm0@gmail.com이동국(한국어 번역)매퍼 설정 마이바티스 XML 설정파일은 다양한 설정과 프로퍼티를 가진다. 문서의 구조는 다음과 같다.:이 설정은 외부에 옮길 수 있다. 자바 프로퍼티 파일 인스턴스에 설정할 수도 있고 properties 엘리먼트의 하위 엘리먼트에 둘 수도 있다. 예를들면:속성들은 파일 도처에 둘 수도 있다. 예를들면:이 예제에서 username과 password는 properties엘리먼트의 설정된 값으로 대체될 수 있다. driver와 url속성은 config.properties파일에 포함된 값으로 대체될 수도 있다. 이것은 설정에 대한 다양한 옵션을 제공하는 셈이다.속성은 SqlSessionFactoryBuilder.build() 메소드에 전달될 수 있다. 예를들면:속성이 한개 이상 존재한다면 마이바티스는 일정한 순서로 로드한다.:properties 엘리먼트에 명시된 속성을 가장 먼저 읽는다.properties 엘리먼트의 클래스패스 자원이나 url 속성으로 부터 로드된 속성을 두번째로 읽는다. 그래서 이미 읽은 값이 있다면 덮어쓴다.마지막으로 메소드 파라미터로 전달된 속성을 읽는다. 앞서 로드된 값을 덮어쓴다.그래서 가장 우선순위가 높은 속성은 메소드의 파라미터로 전달된 값이고 그 다음은 자원 및 url 속성이고 마지막은 properties 엘리먼트에 명시된 값이다.
          Mybatis 3.4.2 부터, placeholder 에 기본값을 아래처럼 지정할 수 있다.
        
<dataSource type="POOLED">
  <!-- ... -->
  <property name="username" value="${username:ut_user}"/> <!-- 만약 'username' 속성이 없다면, username 은 'ut_user' 가 된다. -->
</dataSource>
          이 기능은 기본적으로 비활성화되어 있다. placeholder 에 기본값을 지정한다면,
          이 기능을 활성화하려면 다음과 같이 특별한 속성을 추가해주어야 한다.
        
<properties resource="org/mybatis/example/config.properties">
  <!-- ... -->
  <property name="org.apache.ibatis.parsing.PropertyParser.enable-default-value" value="true"/> <!-- 이 기능을 활성화한다. -->
</properties>db : username
          또한 이미 property key (예 : )로 를 사용하거나
          SQL 정의에서 OGNL 표현식의 삼항 연산자 (예 : )를 사용하는 경우
          다음과 같이 특별한 속성을 추가하여 키와 기본값을 구분하는 문자를 변경해야한다.
        
<properties resource="org/mybatis/example/config.properties">
  <!-- ... -->
  <property name="org.apache.ibatis.parsing.PropertyParser.default-value-separator" value="?:"/> <!-- separator 의 기본값을 변경한다. -->
</properties>런타임시 마이바티스의 행위를 조정하기 위한 중요한 값들이다. 다음 표는 설정과 그 의미 그리고 디폴트 값을 설명한다.설정설명사용가능한 값들디폴트설정에서 각 매퍼에 설정된 캐시를 전역적으로 사용할지 말지에 대한 여부 
                지연로딩을 사용할지에 대한 여부. 사용하지 않는다면 모두 즉시 로딩할 것이다.
                이 값은  속성을 사용해서 대체할 수 있다.
              
                활성화되면 모든 메서드 호출은 객체의 모든 lazy properties 을 로드한다. 그렇지 않으면 각 property 가 필요에 따라 로드된다. ( 참조).
              
                false (3.4.1 부터 true)
              한 개의 구문에서 여러 개의 ResultSet을 허용할지의 여부(드라이버가 해당 기능을 지원해야 함) 칼럼명 대신에 칼럼라벨을 사용.
        드라이버마다 조금 다르게 작동한다.
        문서와 간단한 테스트를 통해 실제 기대하는 것처럼 작동하는지 확인해야 한다.생성키에 대한 JDBC 지원을 허용. 지원하는 드라이버가 필요하다.
        true로 설정하면 생성키를 강제로 생성한다.
        일부 드라이버(예를들면, Derby)에서는 이 설정을 무시한다.마이바티스가 칼럼을 필드/프로퍼티에 자동으로 매핑할지와 방법에 대해 명시.
        PARTIAL은 간단한 자동매핑만 할뿐 내포된 결과에 대해서는 처리하지 않는다.
        FULL은 처리가능한 모든 자동매핑을 처리한다.: 아무것도 하지 않음: 경고 로그를 출력(의 로그레벨은 이어야 한다.) : 매핑이 실패한다. (예외를 던진다.)
                자동매핑 대상 중 알 수 없는 칼럼(이나 알 수 없는 프로퍼티 타입)을 발견했을 때 행위를 명시
                디폴트 실행자(executor) 설정.
        SIMPLE 실행자는 특별히 하는 것이 없다.
        REUSE 실행자는 PreparedStatement를 재사용한다.
        BATCH 실행자는 구문을 재사용하고 수정을 배치처리한다.데이터베이스로의 응답을 얼마나 오래 기다릴지를 판단하는 타임아웃을 설정
        양수
              설정되지 않음(null)
                조회결과를 가져올때 가져올 데이터 크기를 제어하는 용도로 드라이버에 힌트를 설정
        이 파라미터값은 쿼리 설정으로 변경할 수 있다.
              
                양수
              
                설정하지 않음(null)
              
                결과를 가져오는 크기를 제어하는 힌트처럼 드라이버에 설정한다.
        이 파라미터는 쿼리설정으로 변경할 수 있다.
              
                셋팅되지 않음(null)
              
                각 구문의 설정을 생략할 때 스크롤 하는 방법을 지정한다. (3.5.2 부터)
              
                FORWARD_ONLY | SCROLL_SENSITIVE | SCROLL_INSENSITIVE | DEFAULT(설정하지 않을 때와 동일하게 동작)
              
                중첩구문내 RowBound사용을 허용
                허용한다면 false로 설정
              
                중첩구문내 ResultHandler사용을 허용
                허용한다면 false로 설정
              
                전통적인 데이터베이스 칼럼명 형태인 A_COLUMN을 CamelCase형태의 자바 프로퍼티명 형태인 aColumn으로 자동으로 매핑하도록 함
              
                마이바티스는 순환참조를 막거나 반복된 쿼리의 속도를 높히기 위해 로컬캐시를 사용한다.
                디폴트 설정인 SESSION을 사용해서 동일 세션의 모든 쿼리를 캐시한다.
                localCacheScope=STATEMENT 로 설정하면 로컬 세션은 구문 실행할때만 사용하고 같은 SqlSession에서 두 개의 다른 호출 사이에는 데이터를 공유하지 않는다.
              
                JDBC타입을 파라미터에 제공하지 않을때 null값을 처리한 JDBC타입을 명시한다.
                일부 드라이버는 칼럼의 JDBC타입을 정의하도록 요구하지만 대부분은 NULL, VARCHAR 나 OTHER 처럼 일반적인 값을 사용해서 동작한다.
              
                JdbcType 이늄. 대부분은 NULL, VARCHAR 나 OTHER 를 공통적으로 사용한다.
              
                지연로딩을 야기하는 객체의 메소드를 명시
              
                메소드 이름을 나열하고 여러 개일 경우 콤마(,) 로 구분
              
                동적으로 SQL을 만들기 위해 기본적으로 사용하는 언어를 명시
              
                타입별칭이나 패키지 경로를 포함한 클래스명
              
                Enum에 기본적으로 사용되는  를 지정합니다. (3.4.5 부터)
              
                가져온 값이 null일 때 setter나 맵의 put 메소드를 호출할지를 명시
                Map.keySet() 이나 null값을 초기화할때 유용하다.
                int, boolean 등과 같은 원시타입은 null을 설정할 수 없다는 점은 알아두면 좋다.
              
                MyBatis 는 기본적으로 모든 열들의 행이 NULL 이 반환되었을 때 을 반환한다.
                이 설정을 사용하면 MyBatis가 대신 empty 인스턴스를 반환한다.
                nested results(collection 또는 association) 에도 적용된다. 3.4.2 부터
              
                마이바티스가 로거(logger) 이름에 추가할 접두사 문자열을 명시
              
                문자열
              
                설정하지 않음
              
                마이바티스가 사용할 로깅 구현체를 명시
                이 설정을 사용하지 않으면 마이바티스가 사용할 로깅 구현체를 자동으로 찾는다.
              
                마이바티스가 지연로딩을 처리할 객체를 생성할 때 사용할 프록시 툴을 명시
              
                JAVASSIST (마이바티스 3.3과 이상의 버전)
              
                VFS 구현체를 명시
              
                콤마를 사용해서 VFS구현체의 패키지를 포함한 전체 클래스명
              
                메소드 시그니처에 명시된 실제 이름으로 구문파라미터를 참조하는 것을 허용
        이 기능을 사용하려면 프로젝트를 자바 8의 옵션을 사용해서 컴파일해야만 한다.(마이바티스 3.4.1이상의 버전)
               인스턴스를 제공하는 클래스를 지정한다.
                반환된 Configuration 인스턴스는 역직렬화 된 객체의 지연로딩 속성들을 불러오는 데 사용된다.
                이 클래스는  메서드를 가져야 한다. (3.2.3 부터)
              
                SQL에서 여분의 whitespace 문자들을 삭제한다. 이는 SQL의 리터럴 문자열에도 영향을 미친다. (Since 3.5.5)
              
                Provider method를 가지고 있는 sql provider class를 지정한다. (3.5.6 부터).
                이 클래스는 sql provider annotation(예: )의  (혹은 )속성이 누락되었을때 기본으로 적용된다.
              
                'foreach' 태그에서 'nullable' 속성의 기본값을 지정한다. (3.5.9 부터)
              
                생성자 자동 매핑을 적용할 때 칼럼 순서가 아닌 칼럼 이름과 생성자 인수들의 이름을 기반으로 매핑한다. (3.5.10 부터)
              위 설정을 모두 사용한 setting 엘리먼트의 예제이다:타입 별칭은 자바 타입에 대한 짧은 이름이다.
    오직 XML 설정에서만 사용되며, 타이핑을 줄이기 위해 존재한다.
    예를들면:이 설정에서 “Blog”는 여러 군데에서 “domain.blog.Blog” 대신 사용할 수 있다.마이바티스가 빈을 찾도록 패키지를 명시할 수 있다. 예를들면:
         에서 빈을 검색하고 애노테이션이 없을 경우 빈의 이름이 소문자로 변환된 형태의 별칭으로 등록할 것이다.
      이때 빈의 패키지정보도 제거하고 등록된다.
          이를테면 는 로 등록될 것이다.
      만약에  애노테이션을 사용한다면 이 애노테이션에서 지정한 값이 별칭으로 사용될 것이다.
          아래의 예를 보라:
        공통 자바 타입을 위한 여러 내장 타입 별칭이 존재한다. 이들은 대소문자를 구별하지 않으며, 오버로딩된 이름 때문에 원시형 타입은 특별 취급된다는 것을 주의해라.
                별칭
              
                매핑된 타입
              마이바티스가 PreparedStatement에 파라미터를 설정하고 ResultSet에서 값을 가져올때마다 TypeHandler는 적절한 자바 타입의 값을 가져오기 위해 사용된다.
        다음의 표는 디폴트 TypeHandlers를 설명한다.
          3.4.5 버전부터, MyBatis는 JSR-310(Date 와 Time API) 를 기본적으로 지원한다.
        
              타입 핸들러
              
              자바 타입
              
              JDBC 타입
              어떤 호환가능한 BOOLEAN어떤 호환가능한 NUMERIC 또는 BYTE어떤 호환가능한 NUMERIC 또는 SMALLINT어떤 호환가능한 NUMERIC 또는 INTEGER어떤 호환가능한 NUMERIC 또는 BIGINT어떤 호환가능한 NUMERIC 또는 FLOAT어떤 호환가능한 NUMERIC 또는 DOUBLE어떤 호환가능한 NUMERIC 또는 DECIMAL어떤 호환가능한 byte 스트림 타입, 또는 명시하지 않는
               – 문자열 호환타입.
              
                열거형(Enumeration) 타입
              
                코드자체가 아니라 위치를 저장할수 있는  또는 와 호환가능한 타입
              지원하지 않거나 비표준인 타입에 대해서는 당신 스스로 만들어서 타입핸들러를 오버라이드할 수 있다.
        그러기 위해서는 TypeHandler 인터페이스를 구현하고 자바 타입에 TypeHandler를 매핑하면 된다.
    예를들면:이러한 TypeHandler를 사용하는 것은 자바 String프로퍼티와 VARCHAR파라미터 및 결과를 위해 이미 존재하는 핸들러를 오버라이드하게 될 것이다.
        마이바티스는 타입을 판단하기 위해 데이터베이스의 메타데이터를 보지 않는다.
    그래서 파라미터와 결과에 정확한 타입 핸들러를 매핑해야 한다.
        마이바티스가 구문이 실행될때까지는 데이터 타입에 대해 모르기 때문이다.마이바티스는 제네릭타입을 체크해서 TypeHandler로 다루고자 하는 자바타입을 알것이다.
    하지만 두 가지 방법으로 이 행위를 재정의할 수 있다:
        typeHandler 엘리먼트의  속성 추가(예제: TypeHandler클래스에 관련된 자바타입의 목록을 정의하는  애노테이션 추가.
           속성도 함께 정의되어 있다면 는 무시된다.관련된 JDBC타입은 두가지 방법으로 명시할 수 있다:typeHandler 엘리먼트에 TypeHandler클래스에 관련된 JDBC타입의 목록을 정의하는 제한결과매핑한개의에서 타입핸들러를 사용한다고 결정하면 마이바티스가 자바타입은 잘 처리하지만 JDBC타입은 잘 처리하지 못할 수 있다.
      그래서 마이바티스는 타입핸들러를 선택하기 위해 조합을 사용한다.
       애노테이션의 사용은 타입핸들러의  범위를 하고 명시적으로 설정하지 않는한 을 사용하지 못하도록 만든다.
      에서 타입핸들러를 사용할수 있도록 하려면 애노테이션에 를 설정하자.
      자바타입을 다루기 위해  타입핸들러만 등록한다면 에서 자바타입을 다루기 위해 이 타입핸들러를 기본적으로 사용할 것이다.
      한 개의 타입핸들러만 등록할 경우 를 설정하지 않아도 동일하게 동작한다.
        마지막으로 마이바티스로 하여금 TypeHandler를 찾도록 할수 있다:JDBC타입에 대한 자동검색 기능은 애노테이션을 명시한 경우에만 가능하다는 것을 알아둘 필요가 있다. 
          한 개 이상의 클래스를 다루는 제네릭 TypeHandler를 만들수 있다.
          파라미터로 클래스를 가져오는 생성자를 추가하고 마이바티스는 TypeHandler를 만들때 실제 클래스를 전달할 것이다.
         와  는 제네릭 TypeHandler이다.
    이어서 각각을 다룬다.
    을 매핑하고자 한다면  나  를 사용할 필요가 있을 것이다.
        예를들어 순환 방식으로 몇개의 숫자를 사용하는 순환모드를 저장할 필요가 있다고 해보자.
        기본적으로 마이바티스는  값을 각각의 이름으로 변환하기 위해  를 사용한다.
        는 특히 다른 핸들러와 차이가 있다.
        어떤 하나의 특정 클래스를 다루지 않고  을 확장하는 모든 클래스를 다룬다. 아무리 이름을 저장하려해도 DBA는 숫자코드를 고집할수 있다.
    이름 대신 숫자코드를 저장하는 방법은 쉽다.
        설정파일의 에  를 추가하자.
        그러면 각각의 는 순서값을 사용해서 숫자를 매핑할 것이다.
        
      같은 을 사용해서 어떤 곳에는 문자열로 매핑하고 다른 곳에는 숫자로 매핑해야 한다면 무엇을 해야 하나?
    
          자동매퍼는  를 자동으로 사용할 것이다.
          그래서 평범한 순서를 나타내는  를 사용하고자 한다면 SQL구문에 사용할 타입핸들러를 명시적으로 설정한다.
        
          (매퍼 파일은 다음 절까지는 다루지 않는다.
          그래서 문서를 보면서 처음 봤다면 일단 이 부분은 건너띄고 다음에 다시 볼수도 있다. )
        
      여기서 사용한 select구문에서는  대신에 을 사용해야 한다는 점을 알아두자.
    매번 마이바티스는 결과 객체의 인스턴스를 만들기 위해 ObjectFactory를 사용한다.
    디폴트 ObjectFactory 는 디폴트 생성자를 가진 대상 클래스를 인스턴스화하는 것보다 조금 더 많은 작업을 한다.
    ObjectFactory 의 디폴트 행위를 오버라이드하고자 한다면 만들 수 있다.
    예를들면:ObjectFactory인터페이스는 매우 간단한다.
    두 개의 create메소드를 가지고 있으며 하나는 디폴트 생성자를 처리하고 다른 하나는 파라미터를 가진 생성자를 처리한다.
    마지막으로 setProperties 메소드는 ObjectFactory를 설정하기 위해 사용될 수 있다.
    objectFactory엘리먼트에 정의된 프로퍼티는 ObjectFactory인스턴스가 초기화된 후 setProperties에 전달될 것이다.마이바티스는 매핑 구문을 실행하는 어떤 시점에 호출을 가로챈다.
    기본적으로 마이바티스는 메소드 호출을 가로채기 위한 플러그인을 허용한다.이 클래스들의 메소드는 각각 메소드 시그니처를 통해 찾을 수 있고 소스코드는 마이바티스 릴리즈 파일에서 찾을 수 있다.
    오버라이드할 메소드의 행위를 이해해야만 한다.
    주어진 메소드의 행위를 변경하거나 오버라이드하고자 한다면 마이바티스의 핵심기능에 악영향을 줄 수도 있다.
    이러한 로우레벨 클래스와 메소드들은 주의를 해서 사용해야 한다.플러그인을 사용하도록 처리하는 방법은 간단하다.
    Interceptor인터페이스를 구현해서 가로채고(intercept) 싶은 시그니처를 명시해야 한다.위 플러그인은 매핑된 구문의 로우레벨 실행을 책임지는 내부 객체인 Executor인스턴스의 “update” 메소드 호출을 모두 가로챌것이다.참고설정파일 오버라이드하기플러그인을 사용해서 마이바티스 핵심 행위를 변경하기 위해 Configuration클래스 전체를 오버라이드 할 수 있다.
    이 클래스를 확장하고 내부 메소드를 오버라이드하고 SqlSessionFactoryBuilder.build(myConfig)메소드에 그 객체를 넣어주면 된다.
    다시 얘기하지만 이 작업은 마이바티스에 큰 영향을 줄수 있으니 주의해서 해야 한다.마이바티스는 여러 개의 환경으로 설정할 수 있다.
    여러가지 이유로 여러 개의 데이터베이스에 SQL Map을 적용하는데 도움이 된다.
    예를들어, 개발, 테스트, 리얼 환경을 위해 별도의 설정을 가지거나 같은 스키마를 여러 개의 DBMS 제품을 사용할 경우들이다.
    그 외에도 많은 경우가 있을 수 있다.중요하게 기억해야 할 것은 다중 환경을 설정할 수는 있지만 SqlSessionFactory 인스턴스마다 한 개만 사용할 수 있다는 것이다.두 개의 데이터베이스에 연결하고 싶다면 SqlSessionFactory 인스턴스를 두 개 만들 필요가 있다.
    세 개의 데이터베이스를 사용한다면 역시 세 개의 인스턴스를 필요로 한다.
    기억하기 쉽게데이터베이스별로 하나의 SqlSessionFactory환경을 명시하기 위해 SqlSessionFactoryBuilder에 옵션으로 추가 파라미터를 주면 된다.
    환경을 선택하는 두가지 시그니처는environment 파라미터가 없으면 디폴트 환경이 로드된다.environments 엘리먼트는 환경을 설정하는 방법을 정의한다.중요한 부분을 살펴보면디폴트 환경(Environment) ID (예를 들면. default=”development”).각각의 환경을 정의한 환경(Environment) ID (예를 들면. id=”development”).TransactionManager 설정 (예를 들면. type=”JDBC”)DataSource 설정 (예를 들면. type=”POOLED”)디폴트 환경(environment)과 환경(environment) ID 는 용어 자체가 역할을 설명한다.마이바티스는 두 가지 타입의 TransactionManager를 제공한다.JDBC - 이 설정은 간단하게 JDBC 커밋과 롤백을 처리하기 위해 사용된다.
      트랜잭션의 스코프를 관리하기 위해 dataSource 로 부터 커넥션을 가져온다. By default, it enables auto-commit when closing the connection for compatibility with some drivers. However, for some drivers, enabling auto-commit is not only unnecessary, but also is an expensive operation. So, since version 3.5.10, you can skip this step by setting the "skipSetAutoCommitOnClose" property to true. For example:
            MANAGED - 이 설정은 어떤것도 하지 않는다.
      결코 커밋이나 롤백을 하지 않는다.
      대신 컨테이너가 트랜잭션의 모든 생명주기를 관리한다.
      디플트로 커넥션을 닫긴 한다.
      하지만 몇몇 컨테이너는 커넥션을 닫는 것 또한 기대하지 않기 때문에 커넥션 닫는 것으로 멈추고자 한다면 “closeConnection”프로퍼티를 false로 설정하라.
      예를 들면:
            당신은 마이바티스를 스프링과 함께 사용하는 경우에는 구성할 필요가 없습니다
          스프링 모듈 자체의 설정 때문에 어떤 TransactionManager 이전에 설정된 구성을 무시합니다.TransactionManager 타입은 어떠한 프로퍼티도 필요하지 않다.
    어쨌든 둘다 타입 별칭이 있다.
    즉 TransactionFactory를 위한 클래스 명이나 타입 별칭 중 하나를 사용할 수 있다.XML에 설정된 프로퍼티는 인스턴스를 만든 뒤 setProperties()메소드에 전달할 것이다.
    당신의 구현체가 Transaction구현체를 만들 필요가 있을 것이다.:이 두 개의 인터페이스를 사용하여 마이바티스가 트랜잭션을 처리하는 방법을 완벽하게 정의할 수 있다.dataSource엘리먼트는 표준 JDBC DataSource인터페이스를 사용하여 JDBC Connection객체의 소스를 설정한다.대부분의 마이바티스 애플리케이션은 예제처럼 dataSource를 설정할 것이다.여기엔 3 가지의 내장된 dataSource타입이 있다. - 이 구현체는 매번 요청에 대해 커넥션을 열고 닫는 간단한 DataSource이다.
      조금 늦긴 하지만 성능을 크게 필요로 하지 않는 간단한 애플리케이션을 위해서는 괜찮은 선택이다.
      UNPOOLED DataSource에는 다음과 같은 속성이 있습니다. - JDBC드라이버의 패키지 경로를 포함한 결제 자바 클래스명 - 데이터베이스 인스턴스에 대한 JDBC URL - 데이터베이스에 로그인 할 때 사용할 사용자명 - 데이터베이스에 로그인 할 때 사용할 패스워드 - 커넥션에 대한 디폴트 트랜잭션 격리 레벨 for details.필수는 아니지만 선택적으로 데이터베이스 드라이버에 프로퍼티를 전달할 수도 있다.
    그러기 위해서는 다음 예제처럼 “driver.” 로 시작하는 접두어로 프로퍼티를 명시하면 된다.이 설정은 “encoding” 프로퍼티를 “UTF8”로 설정하게 된다.
    이 방법외에도 DriverManager.getConnection(url, driverProperties)메소드를 통해서도 프로퍼티를 설정할 수 있다. - DataSource에 풀링이 적용된 JDBC 커넥션을 위한 구현체이다.
      이는 새로운 Connection 인스턴스를 생성하기 위해 매번 초기화하는 것을 피하게 해준다.
      그래서 빠른 응답을 요구하는 웹 애플리케이션에서는 가장 흔히 사용되고 있다.UNPOOLED DataSource에 비해 많은 프로퍼티를 설정할 수 있다. - 주어진 시간에 존재할 수 있는 활성화된(사용중인) 커넥션의 수.
      디폴트는 10이다. - 주어진 시간에 존재할 수 있는 유휴 커넥션의 수강제로 리턴되기 전에 풀에서 “체크아웃” 될 수 있는 커넥션의 시간.
      디폴트는 20000ms(20 초) - 풀이 로그 상태를 출력하고 비정상적으로 긴 경우 커넥션을 다시 얻을려고 시도하는 로우 레벨 설정.
      디폴트는 20000ms(20 초) – 이것은 모든 쓰레드에 대해 bad Connection이 허용되는 정도에 대한 낮은 수준의 설정입니다.
            만약 쓰레드가 bad connection 을 얻게 되어도 유효한 또 다른 connection 을 다시 받을 수 있습니다.
            하지만 재시도 횟수는  과  의 합보다 많아야 합니다.
            디폴트는 3이다. (3.4.5 부터)
           - 커넥션이 작업하기 좋은 상태이고 요청을 받아서 처리할 준비가 되었는지 체크하기 위해 데이터베이스에 던지는 핑쿼리(Ping Query).
      디폴트는 “핑 쿼리가 없음” 이다.
      이 설정은 대부분의 데이터베이스로 하여금 에러메시지를 보게 할수도 있다. - 핑쿼리를 사용할지 말지를 결정.
      사용한다면 오류가 없는(그리고 빠른) SQL 을 사용하여 poolPingQuery 프로퍼티를 설정해야 한다.
      디폴트는 false 이다. - poolPingQuery가 얼마나 자주 사용될지 설정한다.
      필요이상의 핑을 피하기 위해 데이터베이스의 타임아웃 값과 같을 수 있다.
      디폴트는 0이다.
      디폴트 값은 poolPingEnabled가 true일 경우에만 모든 커넥션이 매번 핑을 던지는 값이다. - 이 DataSource 구현체는 컨테이너에 따라 설정이 변경되며 JNDI 컨텍스트를 참조한다.
      이 DataSource 는 오직 두 개의 프로퍼티만을 요구한다. - 이 프로퍼티는 InitialContext 에서 컨텍스트를 찾기(예를 들어 initialContext.lookup(initial_context))위해 사용된다.
      이 프로퍼티는 선택적인 값이다.
      이 설정을 생략하면 data_source프로퍼티가 InitialContext에서 직접 찾을 것이다. - DataSource인스턴스의 참조를 찾을 수 있는 컨텍스트 경로이다.
      initial_context 룩업을 통해 리턴된 컨텍스트에서 찾을 것이다.
      initial_context 가 지원되지 않는다면 InitialContext 에서 직접 찾을 것이다.다른 DataSource설정과 유사하게 다음처럼 “env.”를 접두어로 프로퍼티를 전달할 수 있다.이 설정은 인스턴스화할 때 InitialContext생성자에 “encoding”프로퍼티를 “UTF8”로 전달한다. 인터페이스를 구현해서 또다른 DataSource구현체를 만들수 있다.
    는 새로운 데이터소스를 만들기 위한 상위 클래스처럼 사용할 수 있다.
      예를 들면 다음의 코드를 사용해서 C3P0를 사용할 수 있다.
    마이바티스가 호출할 setter메소드가 사용하는 프로퍼티를 추가해서 설정한다.
        다음의 설정은 PostgreSQL데이터베이스에 연결할때 사용한 샘플 설정이다. 마이바티스는 데이터베이스 제품마다 다른 구문을 실행할 수 있다.
    여러 개의 데이터베이스 제품을 가진 업체 제품은  속성을 사용한 매핑된 구문을 기반으로 지원한다.
        마이바티스는 속성이 없거나 속성을 가진 모든 구문을 로드한다.
        같은 구문인데 하나는 속성이 있고 하나는 속성이 없을때 뒤에 나온 것이 무시된다.
        다중 지원을 사용하기 위해서는 mybatis-config.xml파일에 다음처럼 를 추가하라:
        DB_VENDOR구현체 databaseIdProvider는 에 의해 리턴된 문자열로 databaseId를 설정한다.
    이때 리턴되는 문자열이 너무 길거나 같은 제품의 서로 다른 버전으로 다른 값을 리턴하는 경우 다음처럼 프로퍼티를 추가해서 짧게 처리할 수도 있다:
    프로퍼터가 제공되면 DB_VENDOR databaseIdProvider는 리턴된 데이터베이스 제품명에서 찾은 첫번째 프로퍼티값이나 일치하는 프로퍼티가 없다면 "null" 을 찾을 것이다.
    이 경우 가 "Oracle (DataDirect)"를 리턴한다면 databaseId는 "oracle"로 설정될 것이다.  인터페이스를 구현해서 자신만의 DatabaseIdProvider를 빌드하고 mybatis-config.xml파일에 등록할 수 있다:
    이제 우리는 매핑된 SQL 구문을 정의할 시간이다.
    하지만 먼저 설정을 어디에 둘지 결정해야 한다.
    자바는 자동으로 리소스를 찾기 위한 좋은 방법을 제공하지 않는다.
    그래서 가장 좋은 건 어디서 찾으라고 지정하는 것이다.
    클래스패스에 상대적으로 리소스를 지정할 수도 있고 url 을 통해서 지정할 수 도 있다.
    예를 들면<!-- 클래스패스의 상대경로의 리소스 사용 -->
<mappers>
  <mapper resource="org/mybatis/builder/AuthorMapper.xml"/>
  <mapper resource="org/mybatis/builder/BlogMapper.xml"/>
  <mapper resource="org/mybatis/builder/PostMapper.xml"/>
</mappers><!-- 절대경로의 url을 사용 -->
<mappers>
  <mapper url="file:///var/mappers/AuthorMapper.xml"/>
  <mapper url="file:///var/mappers/BlogMapper.xml"/>
  <mapper url="file:///var/mappers/PostMapper.xml"/>
</mappers><!-- 매퍼 인터페이스를 사용 -->
<mappers>
  <mapper class="org.mybatis.builder.AuthorMapper"/>
  <mapper class="org.mybatis.builder.BlogMapper"/>
  <mapper class="org.mybatis.builder.PostMapper"/>
</mappers><!-- 매퍼로 패키지내 모든 인터페이스를 등록 -->
<mappers>
  <package name="org.mybatis.builder"/>
</mappers>SQL 매핑 파일에 대해서 자세히 알아보자./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/ko/xdoc/dynamic-sql.xml마이바티스 3 | 동적 SQL동적 SQL마이바티스의 가장 강력한 기능 중 하나는 동적 SQL을 처리하는 방법이다.
    JDBC나 다른 유사한 프레임워크를 사용해본 경험이 있다면 동적으로 SQL 을 구성하는 것이 얼마나 힘든 작업인지 이해할 것이다.
    간혹 공백이나 콤마를 붙이는 것을 잊어본 적도 있을 것이다.
    동적 SQL 은 그만큼 어려운 것이다.동적 SQL 을 사용하는 것은 결코 파티가 될 수 없을 것이다.
    마이바티스는 강력한 동적 SQL 언어로 이 상황을 개선한다.동적 SQL 엘리먼트들은 JSTL이나 XML기반의 텍스트 프로세서를 사용해 본 사람에게는 친숙할 것이다.
    마이바티스의 이전 버전에서는 알고 이해해야 할 엘리먼트가 많았다.
    마이바티스 3 에서는 이를 크게 개선했고 실제 사용해야 할 엘리먼트가 반 이하로 줄었다.
    마이바티스의 다른 엘리먼트의 사용을 최대한 제거하기 위해 OGNL 기반의 표현식을 가져왔다.동적 SQL 에서 가장 공통적으로 사용되는 것으로 where의 일부로 포함될 수 있다.
    예를 들면:이 구문은 선택적으로 문자열 검색 기능을 제공할 것이다.
    만약에 title 값이 없다면 모든 active 상태의 Blog 가 리턴될 것이다.
    하지만 title 값이 있다면 그 값과 비슷한 데이터를 찾게 될 것이다.title과 author를 사용하여 검색하고 싶다면?
    먼저 의미가 좀더 잘 전달되도록 구문의 이름을 변경할 것이다.
    그리고 다른 조건을 추가한다.우리는 종종 적용 할 모든 조건을 원하는 대신에 한가지 경우만을 원할 수 있다.
    자바에서는 switch 구문과 유사하며 마이바티스에서는 choose 엘리먼트를 제공한다.위 예제를 다시 사용해보자.
    지금은 title만으로 검색하고 author가 있다면 그 값으로 검색된다.
    둘다 제공하지 않는다면 featured 상태의 blog가 리턴된다.앞서 예제는 악명높게 다양한 엘리먼트가 사용된 동적 SQL 이다.
    “if” 예제를 사용해보자.어떤 조건에도 해당되지 않는다면 어떤 일이 벌어질까?
    아마도 다음과 같은 SQL 이 만들어질 것이다.아마도 이건 실패할 것이다.
    두번째 조건에만 해당된다면 무슨 일이 벌어질까?
    아마도 다음과 같은 SQL이 만들어질 것이다.이것도 아마 실패할 것이다.
    이 문제는 조건만 가지고는 해결되지 않았다.
    이렇게 작성했다면 다시는 이렇게 작성하지 않게 될 것이다.실패하지 않기 위해서 조금 수정해야 한다.
    조금 수정하면 아마도 다음과 같을 것이다.where 엘리먼트는 태그에 의해 컨텐츠가 리턴되면 단순히 “WHERE”만을 추가한다.
    게다가 컨텐츠가 “AND”나 “OR”로 시작한다면 그 “AND”나 “OR”를 지워버린다.만약에 where 엘리먼트가 기대한 것처럼 작동하지 않는다면 trim 엘리먼트를 사용자 정의할 수도 있다.
    예를들어 다음은 where 엘리먼트에 대한 trim 기능과 동일하다.override 속성은 오버라이드하는 텍스트의 목록을 제한한다.
    결과는 override 속성에 명시된 것들을 지우고 with 속성에 명시된 것을 추가한다.다음 예제는 동적인 update 구문의 유사한 경우이다.
    set 엘리먼트는 update 하고자 하는 칼럼을 동적으로 포함시키기 위해 사용될 수 있다.
    예를 들어:여기서 set 엘리먼트는 동적으로 SET 키워드를 붙히고 필요없는 콤마를 제거한다.아마도 trim 엘리먼트로 처리한다면 아래와 같을 것이다.이 경우 접두사는 추가하고 접미사를 오버라이딩 한다.동적 SQL 에서 공통적으로 필요한 것은 collection 에 대해 반복처리를 하는 것이다.
    종종 IN 조건을 사용하게 된다.
    예를들면foreach엘리먼트는 매우 강력하고 collection 을 명시하는 것을 허용한다.
    엘리먼트 내부에서 사용할 수 있는 item, index두가지 변수를 선언한다.
    이 엘리먼트는 또한 열고 닫는 문자열로 명시할 수 있고 반복간에 둘 수 있는 구분자도 추가할 수 있다. 컬렉션 파라미터로 Map이나 배열객체와 더불어 List, Set등과 같은 반복가능한 객체를 전달할 수 있다. 반복가능하거나 배열을 사용할때 index값은 현재 몇번째 반복인지를 나타내고 value항목은 반복과정에서 가져오는 요소를 나타낸다. Map을 사용할때 index는 key객체가 되고 항목은 value객체가 된다. XML설정 파일과 XML 매핑 파일에 대해서는 이 정도에서 정리하고 다음 섹션에서는 Java API 에 대해 좀더 상세하게 살펴볼 것이다.애노테이션을 사용한 매퍼 클래스에서 동적 SQL을 사용하는 경우  태그를 사용할 수 있다. 예를 들어: 엘리먼트는 OGNL표현을 사용해서 변수를 만든 뒤 컨텍스트에 바인딩한다.
  예를들면 Multi-db vendor support"_databaseId" 변수로 설정된 databaseIdProvider가 동적인 코드에도 사용가능하다면 데이터베이스 제품별로 서로다른 구문을 사용할 수 있다.
    다음의 예제를 보라:Pluggable Scripting Languages For Dynamic SQL마이바티스 3.2부터는 플러그인 형태로 스크립트 언어를 사용할 수 있다.
    그래서 언어별 드라이버를 장착하고 동적 SQL쿼리를 작성할때 그 언어를 사용할 수 있다. 두개의 내장된 언어가 있다. raw 언어는 설정하지 않을때 기본으로 사용하는 값이다.
    을 사용하면 이전에 다룬 모든 동적태그를 실행할 수 있다.  언어는 사실 기능이 조금 부족하다.
    설정을 사용하면 마이바티스는 파라미터를 치환해서 데이터베이스 드라이버에 구문을 전달한다.
    짐작하는 것처럼  언어는  언어보다 조금더 빠르다.
    다음처럼  속성을 추가해서 구문에서 사용할 언어를 명시할 수 있다.
    <select id="selectBlog" lang="raw">
  SELECT * FROM BLOG
</select>또는 매퍼를 사용하는 경우라면  애노테이션을 사용한다. public interface Mapper {
  @Lang(RawLanguageDriver.class)
  @Select("SELECT * FROM BLOG")
  List<Blog> selectBlog();
}다음의 인터페이스를 구현해서 자신만의 언어 드라이버를 구현할 수도 있다. /Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/ko/xdoc/java-api.xml마이바티스 3 | 자바 API자바 API이제 마이바티스를 설정하는 방법과 매핑을 만드는 방법을 알게 되었다.
  이미 충분히 잘 사용할 준비가 된 셈이다.
  마이바티스 자바 API 는 당신의 노력에 대한 보상을 얻게 할 것이다.
  JDBC 와 비교해보면 마이바티스는 코드를 굉장히 단순하게 만들고 깔끔하게 만든다.
  이해하기 쉬워서 유지보수도 편하게 해준다.
  마이바티스 3은 SQL Map을 사용하는 많은 수의 개선 내용을 소개했다.디렉터리 구조자바 API 를 살펴보기 전에 디렉터리 구조에 대해 전반적으로 이해하는 것이 중요하다.
  마이바티스는 매우 유연하고 파일을 사용해서 어떤 것도 할 수 있다.
  하지만 프레임워크이기 때문에 선호하는 방법이 있다.전형적인 애플리케이션 디렉터리 구조를 살펴보자.<-- 마이바티스 *.jar 파일이 여기 있다.<-- 마이바티스 산출물이 여기 있다. Mapper 클래스, XML 설정, XML 매핑 파일들<-- XML 설정파일에 포함된 프로퍼티들이 여기 있다.이건 선호되는 형태이지 반드시 따라야 하는 요구사항이 아님을 기억해두라.
  하지만 이러한 공통적인 형태를 사용하면 많은 사람들이 쉽게 이해할 것이다. 이 섹션의 나머지 예제는 디렉터리 구조가 이렇게 되어 있다고 가정하고 설명한다.마이바티스를 사용하기 위한 기본적인 자바 인터페이스는 SqlSession이다.
  이 인터페이스를 통해 명령어를 실행하고 매퍼를 얻으며 트랜잭션을 관리 할 수 있다.
  우리는 SqlSession에 대해서 좀더 얘기해볼 것이지만 먼저 SqlSession의 인스턴스를 만드는 방법을 배워보자.
  SqlSession은 SqlSessionFactory인스턴스를 사용해서 만든다.
  SqlSessionFactory는 몇가지 방법으로 SqlSession인스턴스를 생성하기 위한 메소드를 포함하고 있다.
  SqlSessionFactory자체는 XML, 애노테이션 또는 자바 설정에서 SqlSessonFactory를 생성할 수 있는 SqlSessionFactoryBuilder를 통해 만들어진다.
  스프링이나 쥬스와 같은 의존성 삽입 프레임워크와 함께 사용할때 SqlSessions은 DI프레임워크에 의해 생성되고 삽입된다.
  그래서 SqlSessionFactoryBuilder나 SqlSessionFactory가 필요하지 않을 것이기 때문에 SqlSession섹션으로 바로 넘어가도 무방하다.
  추가적인 정보는 MyBatis-Spring이나 MyBatis-Guice를 참고하길 바란다. SqlSessionFactoryBuilder는 5개의 build() 메소드를 가진다.
  각각은 서로 다른 소스에서 SqlSessionFactory을 빌드한다.처음 4개의 메소드가 가장 공통적이다.
  XML 문서를 나타내는 Reader 인스턴스를 가진다.
  SqlMapConfig.xml 파일은 위에서 다루었다.
  선택적으로 사용가능한 프로퍼티는 environment와 properties이다.
  environment는 데이터소스와 트랜잭션 관리자를 포함하여 로드할 환경을 판단한다.
  예를들면:environment파라미터를 가진 메소드를 호출한다면 마이바티스는 사용할 환경을 위한 설정을 사용할 것이다.
  물론 잘못된 환경설정을 사용하면 에러를 보게 될 것이다.
  environment파라미터를 가지지 않는 메소드 중 하나를 호출한다면 디폴트 환경(위 예제에서 default=“development”)이 사용될 것이다.properties인스턴스를 가진 메소드를 호출하면 마이바티스는 프로퍼티들을 로드해서 설정에서 사용가능한 부분을 사용할 것이다.
  프로퍼티들은 ${propName}와 같은 문법을 사용해서 설정의 값으로 대체될 수 있다.프로퍼티들은 SqlMapConfig.xml파일에서 사용되거나 직접 명시할 수 있다.
  그러므로 프로퍼티들의 우선순위를 이해하는 것이 중요하다.
  우리는 앞서 언급하긴 했지만 쉽게 이해할 수 있도록 다시 보여주도록 하겠다.프로퍼티가 한개 이상 존재한다면 마이바티스는 일정한 순서로 로드한다.properties엘리먼트에 명시된 속성을 가장 먼저 읽는다.properties엘리먼트의 클래스패스 자원이나 url 속성으로 부터 로드된 속성을 두번재로 읽는다.
  그래서 이미 읽은 값이 있다면 덮어쓴다.,마지막으로 메소드 파라미터로 전달된 속성을 읽는다.
  앞서 로드된 값을 덮어쓴다그래서 가장 우선순위가 높은 속성은 메소드의 파라미터로 전달된 값이고
  그 다음은 자원및 url 속성이고 마지막은 properties 엘리먼트에 명시된 값이다.요약해보면 처음 4개의 메소드는 사실 같지만 environment 그리고/또는 properties에 명시한 값을 오버라이드한다.
  mybatis-config.xml파일에서 SqlSessionFactory를 빌드하는 예제이다.Resources유틸리티 클래스를 사용하고 있는 것을 주의깊게 보면 된다.
  이 클래스는 org.apache.ibatis.io 패키지에 있다.
  Resources 클래스는 그 이름이 나타내는 것처럼 클래스패스나 파일 시스템 또는 웹 URL 에서 자원으로 로드하도록 해준다.
  IDE를 통해 클래스의 소스 코드를 보는 것으로 유용한 메소드를 보게 될 것이다.
  그 유용한 메소드 목록들이다.마지막 build메소드는 Configuration의 인스턴스를 가진다.
  Configuration클래스는 SqlSessionFactory 인스턴스에 대해 알 필요가 있는 모든 것으로 가지고 있다.
  Configuration클래스는 SQL Map을 찾거나 관리하는 것을 포함하여 설정을 살펴보기 위해 유용하다.
  Configuration클래스는 앞서 봤던 모든 설정을 처리할 수 있으며 자바 API 로 나타낼 수 있다.
  SqlSessionFactory를 생성하기 위해 Configuration인스턴스를 build()메소드에 전달하는 예제이다.이제 SqlSessionFactory를 만들었다.
  SqlSession인스턴스를 만들기 위해 사용해보자.SqlSessionFactory는 SqlSession인스턴스를 생성하기 위해 사용할 수 있는 6개의 메소드를 가지고 있다.
  6개의 메소드가 선택해서 사용하는 것들을 보자.: 세션에서 트랜잭션 스코프 또는 자동 커밋을 사용하고 싶은가?: 설정된 DataSource에서 Connection 을 회득하고 싶은가?: PreparedStatements그리고/또는 배치(insert, delete를 포함해서) 업데이트를 재사용하고 싶은가?오버로드된 메소드인 openSession() 이 3가지를 적절히 혼합해서 사용할 수 있다.파라미터를 가지지 않는 디폴트 openSession()메소드는 다음과 같은 성격을 가진 SqlSession을 만들것이다.트랜잭션 스코프는 시작될 것이다.Connection 객체는 활성화된 환경에 의해 설정된 DataSource인스턴스를 획득할 것이다.트랜잭션 격리 레벨은 드라이버나 데이터소스가 디폴트로 제공하는 옵션을 사용할 것이다.PreparedStatements는 재사용되지 않을 것이다.
  그리고 update또한 배치처리되지 않을 것이다.메소드 대부분은 그 이름과 파라미터가 그 역할을 충분히 설명한다.
  자동커밋을 활성화하기 위해서 autoCommit파라미터에 “true” 값을 설정하라.
  자체적인 커넥션을 제공하기 위해서는 connection파라미터에 Connection인스턴스를 설정하라.Connection 과 autoCommit 둘다 설정하는 것을 오버라이드하지 않는다.
  왜냐하면 마이바티스는 제공된 connection 객체를 설정할때마다 현재 사용중인 것을 사용한다.
  마이바티스는 TransactionIsolationLevel라고 불리는 트랜잭션 격리 레벨을 위한 자바 enum 래퍼를 사용한다.
  JDBC를 5가지를 지원한다(NONE, READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE).새롭게 보일수 있는 하나의 파라미터는 ExecutorType이다.
  enum으로는 3개의 값을 정의한다.: 이 타입의 실행자는 아무것도 하지 않는다.
  구문 실행마다 새로운 PreparedStatement를 생성한다.: 이 타입의 실행자는 PreparedStatements를 재사용할 것이다.: 이 실행자는 모든 update구문을 배치처리하고 중간에 select 가 실행될 경우 필요하다면 경계를 표시한다.
  이러한 과정은 행위를 좀더 이해하기 쉽게 하기 위함이다. SqlSessionFactory에서 언급하지 않는 한개 이상의 메소드가 있다.
  getConfiguration() 메소드인데 이 메소드는 런타임시 마이바티스 설정을 조사하는 Configuration인스턴스를 리턴할 것이다. 마이바티스 이전 버전을 사용했다면 세션, 트랜잭션 그리고 배치들을 여기저기서 찾게 될 것이다.
  이것들은 더이상 사용되지 않는다.
  세가지 모두 세션의 범위에 모두 포함되었다.
  이것들이 제공하던 모든 기능을 사용하기 위해 각각이 필요한 것 아니다.앞서 언급한 것처럼 SqlSession인스턴스는 마이바티스에서 굉장히 강력한 클래스이다.
  구문을 실행하고 트랜잭션을 커밋하거나 롤백하는 그리고 mapper인스턴스를 습득하기 위해 필요한 모든 메소드를 찾을 수 있을 것이다.SqlSession에는 20개 이상의 메소드가 있다.
  좀더 적절히 모아서 보도록 하자.구문을 실행하는 메소드이 메소드들은 SQL 매핑 XML 파일에 정의된 SELECT, INSERT, UPDATE 그리고 DELETE 구문을 실행하기 위해 사용된다.
  메소드 이름 자체가 그 역할을 설명하도록 명명되었다.
  메소드 각각은 구문의 ID 와 파라미터 객체(원시타입, 자바빈, POJO 또는 Map)을 가진다.selectOne과 selectList의 차이점은 selectOne메소드는 오직 하나의 객체만을 리턴해야 한다는 것이다.
  한개 이상을 리턴하거나 null 이 리턴된다면 예외가 발생할 것이다.
  얼마나 많은 객체가 리턴될지 모른다면 selectList를 사용하라.
  객체의 존재여부를 체크하고 싶다면 개수를 리턴하는 방법이 더 좋다.
  selectMap은 결과 목록을 Map으로 변환하기 위해 디자인된 특별한 경우이다.
  이 경우 결과 객체의 프로퍼티 중 하나를 키로 사용하게 된다.
  모든 구문이 파라미터를 필요로 하지는 않기 때문에 파라미터 객체를 요구하지 않는 형태로 오버로드되었다.insert, update 그리고 delete 메소드에 의해 리턴되는 값은 실행된 구문에 의해 영향을 받은 레코드수를 표시한다. 마지막으로 리턴되는 데이터의 범위를 제한하거나 결과를 핸들링 하는 로직을 부여할 수 있는 3개의 select 메소드가 있다.RowBounds 파라미터는 마이바티스로 하여금 특정 개수 만큼의 레코드를 건너띄게 한다.
  RowBounds클래스는 offset과 limit 둘다 가지는 생성자가 있다.가장 좋은 성능을 위해 결과셋의 타입을 SCROLL_SENSITIVE나 SCROLL_INSENSITIVE로 사용하라.ResultHandler파라미터는 레코드별로 다룰수 있도록 해준다.
  List에 추가할수도 있고 Map, Set을 만들수도 있으며 각각의 결과를 그냥 던질수도 있다.
  ResultHandler로 많은 것을 할 수 있고 마이바티스는 결과셋을 다루기 위해 내부적으로 사용한다.인터페이스는 매우 간단하다.ResultContext파라미터는 결과 객체에 접근할 수 있도록 해준다.배치 수정시 flush메소드어떤 시점에 JDBC드라이버 클래스에 저장된 배치 수정구문을 지울(flushing(executing)) 방법이 있다.
  이 방법은 을 로 설정한 경우 사용가능하다. 트랙잭션 제어 메소드트랜잭션을 제어하기 위해 4개의 메소드가 있다.
  물론 자동커밋을 선택하였거나 외부 트랜잭션 관리자를 사용하면 영향이 없다.
  어쨌든 Connection인스턴스에 의해 관리되고 JDBC 트랜잭션 관리자를 사용하면 이 4개의 메소드를 사용할 수 있다.기본적으로 마이바티스는 insert, update, delete 또는 가 활성화된select 를 호출하여 데이터베이스가 변경된 것으로 감지하지 않는 한 실제로 커밋하지 않는다.
  이러한 메소드 호출없이 변경되면 커밋된 것으로 보장하기 위해 commit 와 rollback 메소드에 true 값을 전달한다. MyBatis-Spring 과 MyBatis-Guice는 선언적인 트랜잭션 관리기법을 제공한다.
  그래서 스프링이나 쥬스와 함께 마이바티스를 사용한다면 해당되는 메뉴얼을 꼭 참고하길 바란다. 세션 레벨의 캐시를 지우기SqlSession인스턴스는 update, commit, rollback 또는 close 할때마다 지워지는 로컬 캐시이다.
  명시적으로 닫기 위해서는 clearCache()메소드를 호출할 수 있다.SqlSession 을 반드시 닫도록 한다.반드시 기억해야 하는 중요한 것은 당신이 열었던 세션을 닫아주는 것이다.
  확실히 하기 위해 가장 좋은 방법은 다음과 같은 형태로 개발하는 것이다.try (SqlSession session = sqlSessionFactory.openSession()) {
    // 다음의 3줄은 "어떤 작업을 하는"을 나타낸다.
    session.insert(...);
    session.update(...);
    session.delete(...);
    session.commit();
} SqlSessionFactory 처럼 SqlSession이 getConfiguration()메소드를 호출하여 Configuration 인스턴스를 얻을 수 있다.Mappers 사용하기다양한 insert, update, delete 그리고 select 메소드는 강력하지만 다소 장황하고 타입에 안전하지 않다.
  더군다나 IDE나 단위 테스트에 그다지 도움이 되지 않는 형태이다.
  우리는 Mapper를 사용하는 예제는 이미 시작하기 섹션에서 봤다.그러므로 매핑된 구문을 실행하기 위해 좀더 공통적인 방법은 Mapper클래스를 사용하는 것이다.
  Mapper클래스는 SqlSession 메소드에 일치하는 메소드와 간단히 연동된다.
  다음의 예제 클래스는 몇가지 메소드 시그니처와 SqlSession에 매핑하는 방법을 보여준다.public interface AuthorMapper {
  // (Author) selectOne("selectAuthor",5);
  Author selectAuthor(int id);
  // (List<Author>) selectList(“selectAuthors”)
  List<Author> selectAuthors();

  // (Map<Integer,Author>) selectMap("selectAuthors", "id")
  @MapKey("id")
  List<Author> selectAuthorsAsMap();
  // insert("insertAuthor", author)
  int insertAuthor(Author author);
  // updateAuthor("updateAuthor", author)
  int updateAuthor(Author author);
  // delete("deleteAuthor",5)
  int deleteAuthor(int id);
}아주 간결하게 각각의 Mapper메소드 시그니처는 SqlSession 의 메소드 시그니처와 일치해야만 한다.
  String 파라미터 ID가 없지만 대신 메소드명은 매핑된 구문의 ID 와 같아야 한다.추가로 리턴 타입은 기대하는 결과 타입과 일치해야만 한다.
  원시타입과 Map, POJO 그리고 자바빈등 대부분의 타입이 지원된다. Mapper 인터페이스는 어떠한 인터페이스를 구현할 필요가 없고 어떠한 클래스를 확장할 필요도 없다.
  메소드 시그니처는 관련된 매핑된 구문을 유일하게 확인하기 위해 사용될 수 있다. Mapper 인터페이스는 다른 인터페이스를 확장할 수 있다.
  적절한 명명공간의 구문은 Mapper 인터페이스에 XML바인딩을 사용한다.
  오직 하나의 제한점은 두개의 인터페이스에 같은 메소드 시그니처를 사용할 수 없다는 것이다.mapper 메소드에 여러개의 파라미터를 전달 할 수 있다.
  여러개의 파라미터를 전달하면 파라미터 목록의 위치에 따라 명명될 것이다.
  예를 들면 #{param1}, #{param2} 기타 등등 이런 식이다.
  만약 파라미터의 이름을 변경하고자 한다면 파라미터의 @Param(“paramName”)애노테이션을 사용할 수 있다.쿼리 결과를 제한하기 위해 메소드에 RowBounds인스턴스를 전달 할 수 있다.Mapper 애노테이션이 프레임워크가 만들어진 이후로 마이바티스는 XML 기반의 프레임워크이다.
  설정은 XML기반이고 매핑된 구문또한 XML 에 정의한다.
  마이바티스 3 에서는 새로운 추가 옵션이 생겼다.
  마이바티스 3 은 편리하고 강력한 자바 기반의 설정 API 를 제공한다.
  설정 API 는 XML 기반의 마이바티스 설정의 기초가 된다.
  이는 새로운 애노테이션 기반의 설정에도 그대로 적용된다.
  애노테이션은 소개하는데 많은 시간이 할애하지 않아도 될 정도로 매핑된 구문을 구현하는 간단한 방법을 제공한다. 자바 애노테이션은 복잡하고 유연해야 하는 경우에 대해서는 다소 제한적이다.
  조사하는데 많은 시간이 소요됨에도 불구하고 가장 강력한 마이바티스 매핑은 애노테이션으로 처리되지는 못한다.
  C# 속성은 이러한 제한사항이 없어서 MyBatis.NET 버전은 XML 대안으로 자바보다 다소 더 풍부한 기능을 제공한다.
  하지만 자바 애노테이션 기반의 설정이 장점이 없지는 않다.사용가능한 애노테이션은 아래에서 설명한다.애노테이션 대상 XML 엘리먼트 명명공간을 위한 캐시 설정
    사용가능한 속성들 : implementation, eviction, flushInterval, size, readWrite, blocking 그리고 properties.
        property 값 또는 placeholder( 에 정의된 configuration properties 로 대체 할 수 있음) 를 지정한다. 사용가능한 속성들: . (MyBatis 3.4.2 이상에서 사용 가능)
          다른 명명공간의 캐시에 대한 참조 Note that caches declared in an XML mapper file are considered a separate namespace, even if they share the same FQCN. 사용가능한 속성들 : .
          이 annotation 을 사용하려면  속성을 지정해야 한다.
           속성은 namespace(namespace 이름은 지정된 java type 의 FQCN 이 된다) 를 나타내는 java type 을 지정한다,
          그리고  속성(이 속성은 3.4.2 부터 사용가능하다) 은 namespace 를 나타내는 이름을 지정한다.
        결과 객체 생성자에 전달되는 결과들
    사용가능한 속성들 : value(인자의 배열)ConstructorArgs 의 일부로 한개의 생성자 인자
    사용가능한 속성들 : id, column, javaType, jdbcType, typeHandler, select 그리고 resultMap.
    id 속성은 비교하기 위해 사용되는 값이다.
    XML에서는  엘리먼트와 유사하다.
    Since 3.5.4, it can be used as repeatable annotation.결과매핑을 할때 사용될 수 있는 경우에 대한 값들
    사용가능한 속성들 : column, javaType, jdbcType, typeHandler, cases.
    cases 속성은 경우(case)의 배열이다.case 의 값과 매핑
    사용가능한 속성들 : value, type, results.
    results 속성은 Result 의 배열이다.
    게다가 이 Case 애노테이션은 Results애노테이션에서 명시된 ResultMap과 유사하다.결과 칼럼이 프로퍼티나 필드에 매핑되는 방법에 대한 상세 설정을 포함하는 결과 매핑의 목록
    사용가능한 속성들 : value(Result 애노테이션의 배열), id (결과매핑의 이름)칼럼이 프로퍼티나 필드에 매핑되는 한개의 결과 매핑
    사용가능한 속성들 : id, column, property, javaType, jdbcType, typeHandler, one, many.
    id 속성은 프로퍼티를 비교할 때 사용할지를 표시하는 boolean 값이다. (XML 에서 <id> 와 유사하다.)
    one 속성은 한개의 관계(associations)이고 <association> 과 유사하다.
    many 속성은 collection이고  <collection> 과 유사하다.
    클래스의 명명규칙 충돌을 피하기 위해 명명되었다.
    Since 3.5.4, it can be used as repeatable annotation.복잡한 타입의 한개의 프로퍼티를 위한 매핑이다.
    사용가능한 속성들 : select(매핑 구문의 이름, 예를들어 매퍼 메소드).
    , which supersedes the global configuration parameter  for this mapping.
    (available since 3.5.5), which is the fully qualified name of a result map that map to a single container object from select result.
    (available since 3.5.5), which is column prefix for grouping select columns at nested result map.
    Note: 조인 매핑은 애노테이션 API 를 통해서는 지원되지 않는다는 것을 알아야 한다.
    순환(circular) 참조를 허용하지 않는 자바 애노테이션의 제약사항때문이다.복잡한 타입의 collection 프로퍼티를 위한 매핑이다.
    사용가능한 속성들 : select(매핑 구문의 이름, 예를들어 매퍼 메소드)
    (available since 3.5.5), which is the fully qualified name of a result map that map to collection object from select result.
    리턴 타입이 Map 인 메소드에서 사용된다.
    결과객체의 List 를 객체의 프로퍼티에 기초한 Map으로 변환하기 위해 사용된다.매핑 구문의  속성들 이 애노테이션은 매핑된 구문에 속성으로 존재하는 많은 분기(switch)와 설정 옵션에 접근할 수 있다.
    각 구문을 복잡하게 만들기 보다 Options 애노테이션으로 일관되고 깔끔한 방법으로 설정 할수 있게 한다.
    사용가능한 속성들 : useCache=true,
    flushCache=FlushCachePolicy.DEFAULT,
    resultSetType=DEFAULT,
    statementType=PREPARED,
    fetchSize=-1,
    timeout=-1,
    useGeneratedKeys=false,
    keyProperty=“”,
    keyColumn=“”,
    resultSets=“”,
    databaseId="".
    자바 애노테이션을 이해하는 것이 중요하다.
    자바 애노테이션은 “null”을 설정 할 수 없다.
    그래서 일단 Options 애노테이션을 사용하면 각각의 속성은 디폴트 값을 사용하게 된다.
    디폴트 값이 기대하지 않은 결과를 만들지 않도록 주의해야 한다.
    The ,
    the MyBatis use the 
    that matches the current one. If found with and without the 
    keyColumn은 키 칼럼이 테이블의 첫번째 칼럼이 아닌 특정 데이터베이스에서만(PostgreSQL 같은) 필요하다.각각의 애노테이션은 실행하고자 하는 SQL을 표현한다.
    각각 문자열의 배열(또는 한개의 문자열)을 가진다.
    문자열의 배열이 전달되면, 각각 공백을 두고 하나로 합친다.
    자바 코드에서 SQL 을 만들때 발행할 수 있는 “공백 누락” 문제를 해결하도록 도와준다.
    사용가능한 속성들 : value(한개의 SQL 구문을 만들기 위한 문자열의 배열).
    The ,
    the MyBatis use a statement with no 실행시 SQL 을 리턴할 클래스 과 메소드명을 명시하도록 해주는 대체수단의 애노테이션이다 (Since 3.4.6, you can specify the  as a method return type).
    매핑된 구문을 실행할 때 마이바티스는 클래스의 인스턴스를 만들고 메소드를 실행한다.
    Mapper 메서드의 인수인 "Mapper interface type" and "Database ID" 과 (Mybatis 3.4.5 부터) 를 이용한 "Mapper method" 로 전달 된 객체를 메서드 매개변수로 전달할 수 있다.(마이바티스 3.4이상에서는 복수 파라미터를 허용한다.)
    사용가능한 속성들 : value, type, method.
    value and type 속성은 클래스 (The , you must be specify either one.
    But both attributes can be omit when specify the  as global configuration).
    method 속성은 메소드명이다
    (Since 3.5.1, you can omit  attribute, the MyBatis will resolve a target method via the
     interface.
    If not resolve by it, the MyBatis use the reserved fallback method that named ).
    The ,
    the MyBatis will use a provider method with no  the latter will be discarded.
    Note: 이 섹션은 클래스에 대한 설명으로 동적 SQL 을 좀더 깔끔하고 읽기 쉽게 만드는데 도움이 될 수 있다.매퍼 메소드가 여러개의 파라미터를 가진다면 이 애노테이션은 이름에 일치하는 매퍼 메소드 파라미터에 적용된다.
    반면에 여러개의 파라미터는 순서대로 명명된다.
    예를들어 #{param1}, #{param2} 등이 디폴트다.
    @Param(“person”)을 사용하면 파라미터는 #{person}로 명명된다.이 애노테이션은 @Insert, @InsertProvider, @Update 또는 @UpdateProvider 애노테이션을 사용하는 메소드에서 <selectKey>와 똑같다.
    다른 메소드에서는 무시된다.
    @SelectKey애노테이션을 명시하면 마이바티스는 @Options애노테이션이나 설정 프로퍼티를 통해 설정된 key프로퍼티를 무시할 것이다.
    사용가능한 속성들 : statement는 실행할 SQL 구문을 만드는 문자열의 배열이다.
    keyProperty는 새로운 값으로 수정될 파라미터 객체의 프로퍼티이다.
    SQL이 insert 전후에 실행되는 것을 나타내기 위해 true나 false가 되어야 한다.
    resultType은 keyProperty의 자바 타입이다.
    statementType=PREPARED.
    The ,
    the MyBatis will use a statement with no 이 애노테이션은 @Select또는 @SelectProvider애노테이션을 위해 XML 매퍼의 <resultMap> 엘리먼트의 id를 제공하기 위해 사용된다.
    XML 에 정의된 결과매핑을 재사용하도록 해준다.
    이 애노테이션은 @Results나 @ConstructorArgs를 오버라이드 할 것이다.이 애노테이션은 결과 핸들러를 사용할때 사용한다.
    이 경우 리턴타입은 void이고 마이바티스는 각각의 레코드 정보를 가지는 객체의 타입을 결정하는 방법을 가져야만 한다.
    XML 결과매핑이 있다면  @ResultMap 애노테이션을 사용하자.
        결과타입이 XML에서  엘리먼트에 명시되어 있다면 다른 애노테이션이 필요하지 않다.
        결과타입이 XML에서  엘리먼트에 명시되어 있지 않은 경우에 이 애노테이션을 사용하자.
        예를들어 @Select 애노테이션이 선언되어 있다면 메소드는 결과 핸들러를 사용할 것이다.
        결과 타입은 void여야만 하고 이 애노테이션(이나 @ResultMap)을 반드시 사용해야 한다.
        이 애노테이션은 메소드 리턴타입이 void가 아니라면 무시한다. 이 애노테이션을 사용하면 매퍼 인터페이스에 정의한 메소드를 통해 를 호출한다.(마이바티스 3.3과 이상의 버전)Mapper애노테이션 예제이 예제는 insert 하기전에 일련번호를 가져오기 위해 @SelectKey 애노테이션을 사용하는 것을 보여준다.이 예제는 insert한 후에 값을 가져오기 위해 @SelectKey애노테이션을 사용하는 것으로 보여준다.이 예제는 를 호출하기 위해 애노테이션을 사용했다. 다음 예제는 @Results애노테이션의 id속성을 명시해서 결과매핑을 명명하는 방법을 보여준다. 다음 예제는 Sql 프로바이더 애노테이션을 사용해서 파라미터 한개를 처리하는 방법을 보여준다.다음 예제는 Sql 프로바이더 애노테이션을 사용해서 파라미터 여러개를 처리하는 방법을 보여준다.@SelectProvider(type = UserSqlBuilder.class, method = "buildGetUsersByName")
List<User> getUsersByName(
    @Param("name") String name, @Param("orderByColumn") String orderByColumn);

class UserSqlBuilder {

  // @Param애노테이션을 사용하지 않으면 매퍼 메소드와 동일한 인자를 정의해야만 한다.
  public static String buildGetUsersByName(
      final String name, final String orderByColumn) {
    return new SQL(){{
      SELECT("*");
      FROM("users");
      WHERE("name like #{name} || '%'");
      ORDER_BY(orderByColumn);
    }}.toString();
  }

  // @Param애노테이션을 사용한다면, 오직 사용할 인자만 정의할 수 있다.
  public static String buildGetUsersByName(@Param("orderByColumn") final String orderByColumn) {
    return new SQL(){{
      SELECT("*");
      FROM("users");
      WHERE("name like #{name} || '%'");
      ORDER_BY(orderByColumn);
    }}.toString();
  }
}/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/ko/xdoc/sqlmap-xml.xml마이바티스 3 | 매퍼 XML 파일Mapper XML 파일마이바티스의 가장 큰 장점은 매핑구문이다.
    이건 간혹 마법을 부리는 것처럼 보일 수 있다.
    SQL Map XML 파일은 상대적으로 간단하다.
    더군다나 동일한 기능의 JDBC 코드와 비교하면 아마도 95% 이상 코드수가 감소하기도 한다.
    마이바티스는 SQL을 작성하는데 집중하도록 만들어졌다.SQL Map XML파일은 첫번째(first class)엘리먼트만을 가진다. - 해당 네임스페이스을 위한 캐시 설정
         - 다른 네임스페이스의 캐시 설정에 대한 참조 - 데이터베이스 결과데이터를 객체에 로드하는 방법을 정의하는 엘리먼트 - 비권장됨! 예전에 파라미터를 매핑하기 위해 사용되었으나 현재는 사용하지 않음 - 다른 구문에서 재사용하기 위한 SQL 조각 - 매핑된 INSERT 구문.
         - 매핑된 UPDATE 구문.
         - 매핑된 DELETE 구문.
         - 매핑된 SELECT 구문.
        다음 섹션에서는 각각에 대해 세부적으로 살펴볼 것이다.select구문은 마이바티스에서 가장 흔히 사용할 엘리먼트이다.
    데이터베이스에서 데이터를 가져온다.
    아마도 대부분의 애플리케이션은 데이터를 수정하기보다는 조회하는 기능이 많다.
    그래서 마이바티스는 데이터를 조회하고 그 결과를 매핑하는데 집중하고 있다.
    조회는 다음 예제처럼 단순한 경우에는 단순하게 설정된다.이 구문의 이름은 selectPerson이고 int타입의 파라미터를 가진다.
    그리고 결과 데이터는 HashMap 에 저장된다. 파라미터 표기법을 보자.이 표기법은 마이바티스에게 PreparedStatement파라미터를 만들도록 지시한다.
    JDBC를 사용할 때 PreparedStatement에는 “?”형태로 파라미터가 전달된다.
    즉 결과적으로 위 설정은 아래와 같이 작동하게 되는 셈이다.// JDBC 코드와 유사함, 마이바티스 코드는 아님…
String selectPerson = "SELECT * FROM PERSON WHERE ID=?";
PreparedStatement ps = conn.prepareStatement(selectPerson);
ps.setInt(1,id);물론 JDBC 를 사용하면 결과를 가져와서 객체의 인스턴스에 매핑하기 위한 많은 코드가 필요하겠지만
    마이바티스는 그 코드들을 작성하지 않아도 되게 해준다.select 엘리먼트는 각각의 구문이 처리하는 방식에 대해 세부적으로 설정하도록 많은 속성을 설정할 수 있다.Select 엘리먼트 속성속성구문을 찾기 위해 사용될 수 있는 네임스페이스내 유일한 구분자구문에 전달될 파라미터의 패키지 경로를 포함한 전체 클래스명이나 별칭외부 parameterMap을 찾기 위한 비권장된 접근방법.
        인라인 파라미터 매핑과 parameterType을 대신 사용하라.이 구문에 의해 리턴되는 기대타입의 패키지 경로를 포함한 전체 클래스명이나 별칭.
        collection인 경우 collection 타입 자체가 아닌 collection 이 포함된 타입이 될 수 있다.
        resultType이나 resultMap을 사용하라.외부 resultMap 의 참조명.
        결과맵은 마이바티스의 가장 강력한 기능이다.
        resultType이나 resultMap을 사용하라.이 값을 true 로 셋팅하면 구문이 호출될때마다 로컬, 2nd 레벨 캐시가 지워질것이다(flush).
        디폴트는 false이다.이 값을 true 로 셋팅하면 구문의 결과가 2nd 레벨 캐시에 캐시 될 것이다.
        디폴트는 true이다.예외가 던져지기 전에 데이터베이스의 요청 결과를 기다리는 최대시간을 설정한다.
        디폴트는 셋팅하지 않는 것이고 드라이버에 따라 다소 지원되지 않을 수 있다.지정된 수만큼의 결과를 리턴하도록 하는 드라이버 힌트 형태의 값이다.
        디폴트는 셋팅하지 않는 것이고 드라이버에 따라 다소 지원되지 않을 수 있다.STATEMENT, PREPARED 또는 CALLABLE 중 하나를 선택할 수 있다.
        마이바티스에게 Statement, PreparedStatement 또는 CallableStatement를 사용하게 한다.
        디폴트는 PREPARED이다.FORWARD_ONLY|SCROLL_SENSITIVE|SCROLL_INSENSITIVE|DEFAULT(same as unset)중 하나를 선택할 수 있다.
        디폴트는 셋팅하지 않는 것이고 드라이버에 다라 다소 지원되지 않을 수 있다.설정된 databaseIdProvider가 있는 경우 마이바티스는  속성이 없는 모든 구문을 로드하거나 일치하는 와 함께 로드될 것이다.
              같은 구문에서 가 있거나 없는 경우 모두 있다면 뒤에 나온 것이 무시된다.
              이 설정은 내포된 결과를 조회하는 구문에서만 적용이 가능하다.
              true로 설정하면 내포된 결과를 가져오거나 새로운 주요 결과 레코드를 리턴할때 함께 가져오도록 한다.
              이전의 결과 레코드에 대한 참조는 더 이상 발생하지 않는다.
              이 설정은 내포된 결과를 처리할때 조금 더 많은 메모리를 채운다.
              디폴트값은  이다.
              데이터를 변경하는 구문인 insert, update, delete는 매우 간단하다.Insert, Update 와 Delete 엘리먼트 속성외부 parameterMap 을 찾기 위한 비권장된 접근방법.
        인라인 파라미터 매핑과 parameterType을 대신 사용하라.이 값을 true 로 셋팅하면 구문이 호출될때마다 캐시가 지원질것이다(flush).
        디폴트는 false 이다.STATEMENT, PREPARED 또는 CALLABLE중 하나를 선택할 수 있다.
        마이바티스에게 Statement, PreparedStatement 또는 CallableStatement를 사용하게 한다.
        디폴트는 PREPARED 이다.(입력(insert, update)에만 적용) 데이터베이스에서 내부적으로 생성한 키
        (예를들어 MySQL또는 SQL Server와 같은 RDBMS의 자동 증가 필드)를 받는 JDBC getGeneratedKeys메소드를 사용하도록 설정하다.
        디폴트는 false 이다.(입력(insert, update)에만 적용) getGeneratedKeys 메소드나 insert 구문의 selectKey 하위 엘리먼트에 의해 리턴된 키를 셋팅할 프로퍼티를 지정.
        디폴트는 셋팅하지 않는 것이다.
        여러개의 칼럼을 사용한다면 프로퍼티명에 콤마를 구분자로 나열할수 있다. (입력(insert, update)에만 적용) 생성키를 가진 테이블의 칼럼명을 셋팅.
        키 칼럼이 테이블이 첫번째 칼럼이 아닌 데이터베이스(PostgreSQL 처럼)에서만 필요하다.
        여러개의 칼럼을 사용한다면 프로퍼티명에 콤마를 구분자로 나열할수 있다. Insert, update, delete 구문의 예제이다.앞서 설명했지만 insert는 key생성과 같은 기능을 위해 몇가지 추가 속성과 하위 엘리먼트를 가진다.먼저 사용하는 데이터베이스가 자동생성키(예를들면 MySQL과 SQL서버)를 지원한다면
    useGeneratedKeys=”true” 로 설정하고 대상 프로퍼티에 keyProperty 를 셋팅할 수 있다.
    예를들어 Author 테이블이 id 칼럼에 자동생성키를 적용했다고 하면 구문은 아래와 같은 형태일 것이다.사용하는 데이터베이스가 다중레코드 입력을 지원한다면, 의 목록이나 배열을 전달할수 있고 자동생성키를 가져올 수 있다. 마이바티스는 자동생성키 칼럼을 지원하지 않는 다른 데이터베이스를 위해 다른 방법 또한 제공한다.이 예제는 랜덤 ID 를 생성하고 있다.위 예제에서 selectKey구문이 먼저 실행되고 Author id프로퍼티에 셋팅된다.
    그리고 나서 insert 구문이 실행된다.
    이건 복잡한 자바코드 없이도 데이터베이스에 자동생성키의 행위와 비슷한 효과를 가지도록 해준다.selectKey 엘리먼트는 다음처럼 설정가능하다.selectKey 엘리먼트 속성selectKey구문의 결과가 셋팅될 대상 프로퍼티. 리턴되는 결과셋의 칼럼명은 프로퍼티에 일치한다.
              여러개의 칼럼을 사용한다면 칼럼명의 목록은 콤마를 사용해서 구분한다.
              결과의 타입.
        마이바티스는 이 기능을 제거할 수 있지만 추가하는게 문제가 되지는 않을것이다.
        마이바티스는 String을 포함하여 키로 사용될 수 있는 간단한 타입을 허용한다.BEFORE 또는 AFTER를 셋팅할 수 있다.
        BEFORE로 설정하면 키를 먼저 조회하고 그 값을 keyProperty 에 셋팅한 뒤 insert 구문을 실행한다.
        AFTER로 설정하면 insert 구문을 실행한 뒤 selectKey 구문을 실행한다.
        오라클과 같은 데이터베이스에서는 insert구문 내부에서 일관된 호출형태로 처리한다.위 내용과 같다.
        마이바티스는 Statement, PreparedStatement 그리고 CallableStatement을 매핑하기 위해 STATEMENT, PREPARED 그리고 CALLABLE 구문타입을 지원한다.이 엘리먼트는 다른 구문에서 재사용가능한 SQL구문을 정의할 때 사용된다.
    로딩시점에 정적으로 파라미터처럼 사용할 수 있다.
    다른 프로퍼티값은 포함된 인스턴스에서 달라질 수 있다. SQL 조각은 다른 구문에 포함시킬수 있다.프로퍼티값은 다음처럼 refid속성이나 include절 내부에서 프로퍼티값으로 사용할 수 있다. 앞서 본 구문들에서 간단한 파라미터들의 예를 보았을 것이다.
    Parameters는 마이바티스에서 매우 중요한 엘리먼트이다.
    대략 90%정도 간단한 경우 이러한 형태로 설정할 것이다.위 예제는 매우 간단한 명명된 파라미터 매핑을 보여준다.
    parameterType은 “int”로 설정되어 있다.
    Integer과 String과 같은 원시타입 이나 간단한 데이터 타입은 프로퍼티를 가지지 않는다.
    그래서 파라미터 전체가 값을 대체하게 된다.
    하지만 복잡한 객체를 전달하고자 한다면 다음의 예제처럼 상황은 조금 다르게 된다.User타입의 파라미터 객체가 구문으로 전달되면 id, username, password 프로퍼티는 찾아서 PreparedStatement파라미터로 전달된다.비록 파라미터들을 구문에 전달하는 괜찮은 예제이지만 파라미터 매핑을 위한 다른 기능 또한 더 있다.먼저 파라미터에 데이터 타입을 명시할 수 있다.javaType은 파라미터 객체의 타입을 판단하는 기준이 된다.
    javaType은 TypeHandler를 사용하여 정의할 수도 있다. 만약 특정 칼럼에 null 이 전달되면 JDBC 타입은 null가능한 칼럼을 위해 필요하다.
      처리 방법에 대해서는 PreparedStatement.setNull()메소드의 JavaDoc을 보라.다양하게 타입 핸들링하기 위해서는 TypeHandler클래스를 명시할 수 있다.
    다소 설정이 장황하게 보일수 있지만 실제로 이렇게 설정할일은 거의 없다.
    숫자 타입을 위해서 크기를 판단하기 위한 numericScale속성도 있다.마지막으로 mode속성은 IN, OUT 또는 INOUT 파라미터를 명시하기 위해 사용한다.
    파라미터가 OUT 또는 INOUT 이라면 파라미터의 실제 값은 변경될 것이다.
    mode=OUT(또는 INOUT) 이고 jdbcType=CURSOR(예를들어 오라클 REFCURSOR)라면 파라미터의 타입에 ResultSet 를 매핑하기 위해 resultMap을 명시해야만 한다.마이바티스는 structs와 같은 향상된 데이터 타입을 지원하지만 파라미터를 등록할 때 타입명을 구문에 전달해야 한다.
    예를들면,이런 강력한 옵션들에도 불구하고 대부분은 프로퍼티명만 명시하거나 null 가능한 칼럼을 위해 jdbcType 정도만 명시할 것이다.
        문자열 대체(String Substitution)
        #{} 문법은 마이바티스로 하여금 PreparedStatement프로퍼티를 만들어서 PreparedStatement파라미터(예를들면 ?)에 값을 셋팅하도록 할 것이다.
    이 방법이 안전하기는 하지만 빠른 방법이 선호되기도 한다.
    가끔은 SQL 구문에 변하지 않는 값으로 삽입하길 원하기도 한다.
    예를들면 ORDER BY와 같은 구문들이다.여기서 마이바티스는 문자열을 변경하거나 이스케이프 처리하지 않는다.
          문자열 대체는 SQL 구문의 메타데이터(예를 들어 테이블 이름, 칼럼 이름)가 동적일 때 매우 유용하게 사용할 수 있다.
          예를 들면, 테이블의 칼럼 중 하나로 테이블의 데이터를 하고 싶을 때 아래와 같이 작성하는 대신:
          
          다음과 같이 작성할 수 있다:
          
          여기서 은 지정한 문자열로 직접 대체되고, 는 "prepared" 될 것이므로
          아래와 같이 사용할 수 있다:
          
          이 아이디어는 테이블 이름을 대체하는 데에도 적용할 수 있다.
         사용자로부터 받은 값을 이 방법으로 변경하지 않고 구문에 전달하는 건 안전하지 않다.
      이건 잠재적으로 SQL 주입 공격에 노출된다.
      그러므로 사용자 입력값에 대해서는 이 방법을 사용하면 안된다.
      사용자 입력값에 대해서는 언제나 자체적으로 이스케이프 처리하고 체크해야 한다.resultMap엘리먼트는 마이바티스에서 가장 중요하고 강력한 엘리먼트이다.
    ResultSet에서 데이터를 가져올때 작성되는 JDBC코드를 대부분 줄여주는 역할을 담당한다.
    사실 join매핑과 같은 복잡한 코드는 굉장히 많은 코드가 필요하다.
    ResultMap은 간단한 구문에서는 매핑이 필요하지 않고 복잡한 구문에서 관계를 서술하기 위해 필요하다.이미 앞에서 명시적인 resultMap을 가지지 않는 간단한 매핑 구문은 봤을 것이다.모든 칼럼의 값이 결과가 되는 간단한 구문에서는 HashMap에서 키 형태로 자동으로 매핑된다.
    하지만 대부분의 경우 HashMap은 매우 좋은 도메인 모델이 되지는 못한다.
    그래서 대부분 도메인 모델로는 자바빈이나 POJO 를 사용할 것이다.
    마이바티스는 둘다 지원한다.
    자바빈의 경우를 보자.자바빈 스펙에 기반하여 위 클래스는 3개의 프로퍼티(id, username, hashedPassword)를 가진다.
    이 프로퍼티는 select구문에서 칼럼명과 정확히 일치한다.그래서 자바빈은 HashMap과 마찬가지로 매우 쉽게 ResultSet에 매핑될 수 있다.그리고 TypeAliases 가 편리한 기능임을 기억해두는게 좋다.
    TypeAliases를 사용하면 타이핑 수를 줄일 수 있다.
    예를들면,<!-- XML설정파일에서 -->
<typeAlias type="com.someapp.model.User" alias="User"/>

<!-- SQL매핑 XML파일에서 -->
<select id="selectUsers" resultType="User">
  select id, username, hashedPassword
  from some_table
  where id = #{id}
</select>이 경우 마이바티스는 칼럼을 자바빈에 이름 기준으로 매핑하여 ResultMap을 자동으로 생성할 것이다.
    만약 칼럼명이 프로퍼티명과 다르다면 SQL구문에 별칭을 지정할 수 있다.
    예를들면.ResultMap에 대한 중요한 내용은 다 보았다.
    하지만 다 본건 아니다.
    칼럼명과 프로퍼티명이 다른 경우에 대해 데이터베이스 별칭을 사용하는 것과 다른 방법으로 명시적인 resultMap 을 선언하는 방법이 있다.구문에서는 resultMap속성에 이를 지정하여 참조한다.
    예를들면대부분 이런 유형이라면 지극히 간단할 것이다. 복잡한 결과매핑마이바티스는 한가지 기준으로 만들어졌다.
    데이터베이스는 당신이 원하거나 필요로 하는 것이 아니다.
        정규화 개념 중 3NF나 BCNF가 완벽히 되도록 하는게 좋지만 실제로는 그렇지도 않다.
        그래서 하나의 데이터베이스를 모든 애플리케이션에 완벽히 매핑하는 것이 가능하다면 그것이 가장 좋겠지만 그렇지도 않다.
        마이바티스가 이 문제를 해결하기 위해 제공하는 답은 결과매핑이다.
        이런 복잡한 구문은 어떻게 매핑할까?<!-- 매우 복잡한 구문 -->
<select id="selectBlogDetails" resultMap="detailedBlogResultMap">
  select
       B.id as blog_id,
       B.title as blog_title,
       B.author_id as blog_author_id,
       A.id as author_id,
       A.username as author_username,
       A.password as author_password,
       A.email as author_email,
       A.bio as author_bio,
       A.favourite_section as author_favourite_section,
       P.id as post_id,
       P.blog_id as post_blog_id,
       P.author_id as post_author_id,
       P.created_on as post_created_on,
       P.section as post_section,
       P.subject as post_subject,
       P.draft as draft,
       P.body as post_body,
       C.id as comment_id,
       C.post_id as comment_post_id,
       C.name as comment_name,
       C.comment as comment_text,
       T.id as tag_id,
       T.name as tag_name
  from Blog B
       left outer join Author A on B.author_id = A.id
       left outer join Post P on B.id = P.blog_id
       left outer join Comment C on P.id = C.post_id
       left outer join Post_Tag PT on PT.post_id = P.id
       left outer join Tag T on PT.tag_id = T.id
  where B.id = #{id}
</select>아마 Author에 의해 작성되고 Comments 이나 태그를 가지는 많은 포스트를 가진 Blog 를 구성하는 괜찮은 객체 모델에 매핑하고 싶을 것이다.
    이건 복잡한 ResultMap 으로 충분한 예제이다.
    복잡해보이지만 단계별로 살펴보면 지극히 간단하다.resultMap엘리먼트는 많은 하위 엘리먼트를 가진다.
    다음은 resultMap 엘리먼트의 개념적인 뷰(conceptual view)이다. - ID 인자. ID 와 같은 결과는 전반적으로 성능을 향상시킨다. - 생성자에 삽입되는 일반적인 결과 - 인스턴스화되는 클래스의 생성자에 결과를 삽입하기 위해 사용됨
             – ID 결과. ID 와 같은 결과는 전반적으로 성능을 향상시킨다. – 필드나 자바빈 프로퍼티에 삽입되는 일반적인 결과중첩된 결과 매핑 – resultMap 스스로의 연관관계
               – 복잡한 타입의 연관관계. 많은 결과는 타입으로 나타난다.
            중첩된 결과 매핑 – resultMap 스스로의 연관관계 – 복잡한 타입의 컬렉션
            중첩된 결과 매핑 – 이 경우 또한 결과매핑 자체이고 이러한 동일한 엘리먼트를 많이 포함하거나 외부 resultMap을 참조할 수 있다.
                   – 몇가지 값에 기초한 결과 매핑
                 – 사용할 resultMap 을 판단하기 위한 결과값을 사용
            resultMap 엘리먼트 속성결과매핑을 참조하기 위해 사용할 수 있는 값으로 네임스페이스에서 유일한 식별자 패키지를 포함한 자바 클래스명이나 타입별칭(내장된 타입별칭이 목록은 위 표를 보자).
              이 설정을 사용하면 마이바티스는 결과매핑을 자동매핑으로 처리할지 말지를 처리한다.
              이 속성은 autoMappingBehavior 라는 전역설정을 덮는다.
        디폴트는 unset이다.
              가장 좋은 형태:  매번 ResultMap 을 추가해서 빌드한다.
      이 경우 단위 테스트가 도움이 될 수 있다.
      한번에 모든 resultMap 을 빌드하면 작업하기 어려울 것이다.
      간단히 시작해서 단계별로 처리하는 것이 좋다.
      프레임워크를 사용하는 것은 종종 블랙박스와 같다.
      가장 좋은 방법은 단위 테스트를 통해 기대하는 행위를 달성하는 것이다.
      이건 버그가 발견되었을때 디버깅을 위해서도 좋은 방법이다.다음 섹션은 각각의 엘리먼트에 대해 상세하게 살펴볼 것이다.이건 결과 매핑의 가장 기본적인 형태이다.
    id와 result 모두 한개의 칼럼을 한개의 프로퍼티나 간단한 데이터 타입의 필드에 매핑한다.둘 사이의 차이점은 id 값은 객체 인스턴스를 비교할 때 사용되는 구분자 프로퍼티로 처리되는 점이다.
    이 점은 일반적으로 성능을 향상시키지만 특히 캐시와 내포된(nested) 결과 매핑(조인 매핑)의 경우에 더 그렇다.둘다 다수의 속성을 가진다.id 와 result 엘리먼트 속성속성 결과 칼럼에 매핑하기 위한 필드나 프로퍼티.
        자바빈 프로퍼티가 해당 이름과 일치한다면 그 프로퍼티가 사용될 것이다.
        반면에 마이바티스는 해당 이름이 필드를 찾을 것이다.
        점 표기를 사용하여 복잡한 프로퍼티 검색을 사용할 수 있다.
        예를들어 “username”과 같이 간단하게 매핑될 수 있거나 “address.street.number” 처럼 복잡하게 매핑될수도 있다.데이터베이스의 칼럼명이나 별칭된 칼럼 라벨.
        resultSet.getString(columnName) 에 전달되는 같은 문자열이다.패키지 경로를 포함한 클래스 전체명이거나 타입 별칭.
        자바빈을 사용한다면 마이바티스는 타입을 찾아낼 수 있다.
        반면에 HashMap으로 매핑한다면 기대하는 처리를 명확히 하기 위해 javaType 을 명시해야 한다.지원되는 타입 목록에서 설명하는 JDBC 타입.
        JDBC타입은 insert, update 또는 delete 하는 null 입력이 가능한 칼럼에서만 필요하다.
        JDBC의 요구사항이지 마이바티스의 요구사항이 아니다.
        JDBC로 직접 코딩을 하다보면 null이 가능한 값에 이 타입을 지정할 필요가 있을 것이다.이 문서 앞에서 이미 타입 핸들러에 대해 설명했다.
        이 프로퍼티를 사용하면 디폴트 타입 핸들러를 오버라이드 할 수 있다.
        이 값은 TypeHandler구현체의 패키지를 포함한 전체 클래스명이나 타입별칭이다.지원되는 JDBC 타입상세한 설명전에 마이바티스는 jdbcType열거를 통해 다음의 JDBC 타입들을 지원한다.프로퍼티가 데이터 전송 객체(DTO) 타입 클래스로 작동한다.
    변하지 않는 클래스를 사용하고자 하는 경우가 있다.
    거의 변하지 않는 데이터를 가진 테이블은 종종 이 변하지 않는 클래스에 적합하다.
    생성자 주입은 public 메소드가 없어도 인스턴스화할 때 값을 셋팅하도록 해준다.
    마이바티스는 private 프로퍼티와 private 자바빈 프로퍼티를 지원하지만 많은 사람들은 생성자 주입을 선호한다.
    constructor엘리먼트는 이러한 처리를 가능하게 한다.다음의 생성자를 보자.
          결과를 생성자에 주입하려면 MyBatis 가 어떻게든 생성자를 식별해야 한다.
          다음 예제에서 MyBatis는  의 순서로 세 개의 매개 변수로 선언 된 생성자를 검색한다.
        
          많은 매개 변수를 가진 생성자를 다루는 경우, arg 엘리먼트의 순서를 유지하는 것은 오류가 발생하기 쉽다. 
          3.4.3 부터, 각 매개 변수의 이름을 지정하여 임의의 순서로 arg 엘리먼트를 작성할 수 있다. 이름으로 생성자 매개변수를 참조하려면,  annotation 을 추가하거나 '-parameters' 컴파일러 옵션을 통해 프로젝트를 컴파일하고  을 활성화 할 수 있다. (이 옵션은 기본적으로 활성화 되어있다).
          다음 예제는 2번째 및 3번째 매개변수의 순서가 선언 된 순서와 일치하지 않더라도 동일한 생성자에 대해 유효하다.
        
          같은 이름과 형태의 쓰기 가능한 property 가 있는 경우는  를 생략 할 수 있다.
        나머지 속성과 규칙은 id와 result엘리먼트와 동일하다.데이터베이스의 칼럼명이나 별칭된 칼럼 라벨.
        resultSet.getString(columnName)에 전달되는 같은 문자열이다.패키지 경로를 포함한 클래스 전체명이거나 타입 별칭.
        자바빈을 사용한다면 마이바티스는 타입을 찾아낼 수 있다.
        반면에 HashMap 으로 매핑한다면 기대하는 처리를 명확히 하기 위해 javaType을 명시해야 한다.지원되는 타입 목록에서 설명하는 JDBC 타입.
        JDBC타입은 insert, update 또는 delete 하는 null 입력이 가능한 칼럼에서만 필요하다.
        JDBC의 요구사항이지 마이바티스의 요구사항이 아니다.
        JDBC로 직접 코딩을 하다보면 null 이 가능한 값에 이 타입을 지정할 필요가 있을 것이다.다른 매핑된 구문의 ID 는 이 프로퍼티 매핑이 필요로 하는 복잡한 타입을 로드할 것이다.
        column 속성의 칼럼으로 부터 가져온 값은 대상 select 구문에 파라미터로 전달될 것이다.
        세부적인 설명은 association엘리먼트를 보라.이 인자의 내포된 결과를 적절한 객체로 매핑할 수 있는 ResultMap 의 ID이다.
        다른 select구문을 호출하기 위한 대체방법이다.
        여러개의 테이블을 조인하는 것을 하나의 ResultSet 으로 매핑하도록 해준다.
        ResultSet 은 사본을 포함할 수 있고 데이터를 반복할 수도 있다.
        가능하게 하기 위해서 내포된 결과를 다루도록 결과맵을 “연결”하자.
        자세히 알기 위해서는 association엘리먼트를 보라.
                생성자 매개변수의 이름. name 을 지정함으로써 순서에 상관없이 arg 엘리먼트를 작성할 수 있다. 위의 설명을 보아라. 3.4.3 부터 가능하다.
              association 엘리먼트는 “has-one”타입의 관계를 다룬다.
    예를들어 Blog는 하나의 Author를 가진다.
    association 매핑은 다른 결과와 작동한다.
    값을 가져오기 위해 대상 프로퍼티를 명시한다.마이바티스는 관계를 정의하는 두가지 방법을 제공한다.내포된(Nested) Select: 복잡한 타입을 리턴하는 다른 매핑된 SQL 구문을 실행하는 방법.내포된(Nested) Results: 조인된 결과물을 반복적으로 사용하여 내포된 결과 매핑을 사용하는 방법.먼저 엘리먼트내 프로퍼티들을 보자.
    보이는 것처럼 select와 resultMap 속성만을 사용하는 간단한 결과 매핑과는 다르다.이 문서 앞에서 이미 타입 핸들러에 대해 설명했다.
        이 프로퍼티를 사용하면 디폴트 타입 핸들러를 오버라이드 할 수 있다.
        이 값은 TypeHandler 구현체의 패키지를 포함한 전체 클래스명이나 타입별칭이다.연관(Association)을 위한 중첩된 Select데이터베이스의 칼럼명이나 별칭된 칼럼 라벨.
        resultSet.getString(columnName)에 전달되는 같은 문자열이다.
        Note: 복합키를 다루기 위해서 column=”{prop1=col1,prop2=col2}” 문법을 사용해서 여러개의 칼럼명을 내포된 select 구문에 명시할 수 있다.
        이것은 대상의 내포된 select 구문의 파라미터 객체에 prop1, prop2 형태로 셋팅하게 될 것이다.다른 매핑된 구문의 ID는 이 프로퍼티 매핑이 필요로 하는 복잡한 타입을 로드할 것이다.
        column 속성의 칼럼으로 부터 가져온 값은 대상 select 구문에 파라미터로 전달될 것이다.
        노트: 복합키를 다루기 위해서 column=”{prop1=col1,prop2=col2}” 문법을 사용해서 여러개의 칼럼명을 내포된 select 구문에 명시할 수 있다.
        이것은 대상의 내포된 select 구문의 파라미터 객체에 prop1, prop2 형태로 셋팅하게 될 것이다.
                선택가능한 속성으로 사용가능한 값은 와 이다.
                이 속성을 사용하면 전역 설정파라미터인 를 대체한다.
              예를들면.여기엔 두개의 select 구문이 있다.
    하나는 Blog를 로드하고 다른 하나는 Author를 로드한다.
    그리고 Blog의 resultMap은 author프로퍼티를 로드하기 위해 “selectAuthor”구문을 사용한다.다른 프로퍼티들은 칼럼과 프로퍼티명에 일치하는 것들로 자동으로 로드 될 것이다.이 방법은 간단한 반면에 큰 데이터나 목록에는 제대로 작동하지 않을 것이다.
    이 방법은 “N+1 Selects 문제” 으로 알려진 문제점을 가진다.
    N+1 조회 문제는 처리과정의 특이성으로 인해 야기된다.레코드의 목록을 가져오기 위해 하나의 SQL 구문을 실행한다. (“+1” 에 해당).리턴된 레코드별로 각각의 상세 데이터를 로드하기 위해 select 구문을 실행한다. (“N” 에 해당).이 문제는 수백 또는 수천의 SQL 구문 실행이라는 결과를 야기할 수 있다.
    아마도 언제나 바라는 형태의 처리가 아닐 것이다.목록을 로드하고 내포된 데이터에 접근하기 위해 즉시 반복적으로 처리한다면
    지연로딩으로 호출하고 게다가 성능은 많이 나빠질 것이다.그래서 다른 방법이 있다.관계를 위한 내포된 결과(Nested Results)이 인자의 내포된 결과를 적절한 객체로 매핑할 수 있는 ResultMap의 ID 이다.
        다른 select구문을 호출하기 위한 대체방법이다.
        여러개의 테이블을 조인하는 것을 하나의 ResultSet으로 매핑하도록 해준다.
        ResultSet은 사본을 포함할 수 있고 데이터를 반복할 수도 있다.
        가능하게 하기 위해서 내포된 결과를 다루도록 결과맵을 “연결”하자.
        자세히 알기 위해서는 association엘리먼트를 보라.
                여러개의 테이블을 조인할때 ResultSet에서 칼럼명의 중복을 피하기 위해 칼럼별칭을 사용할 수 있다.
                칼럼을 외부 결과매핑에 매핑하기 위해 columnPrefix를 명시하자.
        이 절의 뒤에 나오는 에제를 보자.
              
                기본적으로 자식객체는 칼럼중 적어도 하나를 null이 아닌 자식객체의 프로퍼티에 매핑할때 만들어진다.
                이 속성을 사용해서 칼럼이 값을 가져야만 하는 것을 명시해서 행위를 변경할 수 있다.
                그래서 마이바티스는 이러한 칼럼이 null이 아닐때만 자식 객체를 만들것이다.
                여러개의 칼럼명은 구분자로 콤마를 사용해서 명시한다.
                디폴트값은 unset이다.
              이 속성을 사용하면 마이바티스는 결과를 프로퍼티에 매핑할때 자동매핑을 사용할지 말지를 정한다.
              이 속성은 전역설정인 autoMappingBehavior를 무시하게 한다.
              외부 결과매핑에는 영향을 주지 않는다.
              그래서  속성을 함께 사용하는 것은 의미가 없다.
              디폴트값은 unset이다.
              위에서 내포된 관계의 매우 복잡한 예제를 보았을 것이다.
    다음은 작동하는 것을 보기 위한 간단한 예제이다.
    개별구문을 실행하는 것 대신에 Blog와 Author테이블을 함께 조인했다.조인을 사용할 때 결과의 값들이 유일하거나 명확한 이름이 되도록 별칭을 사용하는 것이 좋다.
    이제 결과를 매핑할 수 있다.<resultMap id="blogResult" type="Blog">
  <id property="id" column="blog_id" />
  <result property="title" column="blog_title"/>
  <association property="author" column="blog_author_id" javaType="Author" resultMap="authorResult"/>
</resultMap>

<resultMap id="authorResult" type="Author">
  <id property="id" column="author_id"/>
  <result property="username" column="author_username"/>
  <result property="password" column="author_password"/>
  <result property="email" column="author_email"/>
  <result property="bio" column="author_bio"/>
</resultMap>위 예제에서 Author인스턴스를 로드하기 위한 “authorResult” 결과매핑으로 위임된 Blog의 “author”관계를 볼 수 있을 것이다.매우 중요 : id 엘리먼트는 내포된 결과 매핑에서 매우 중요한 역할을 담당한다.
    결과 중 유일한 것을 찾아내기 위한 한개 이상의 프로퍼티를 명시해야만 한다.
    가능하면 결과 중 유일한 것을 찾아낼 수 있는 프로퍼티들을 선택하라.
    기본키가 가장 좋은 선택이 될 수 있다.이제 위 예제는 관계를 매핑하기 위해 외부의 resultMap 엘리먼트를 사용했다.
    이 외부 resultMap은 Author resultMap을 재사용가능하도록 해준다.
    어쨌든 재사용할 필요가 있거나 한개의 resultMap 에 결과 매핑을 함께 위치시키고자 한다면 association 결과 매핑을 내포시킬수 있다.
    다음은 이 방법을 사용한 예제이다.
          블로그에 공동저자가 있다면 어쩌지?
          select구문은 다음과 같을 것이다.
        
          저자(Author)를 위한 결과매핑은 다음처럼 정의했다.
        
          결과의 칼럼명은 결과매핑에 정의한 칼럼과는 다르기 때문에 공동저자 결과를 위한 결과매핑을 재사용하기 위해 를 명시할 필요가 있다.
        지금까지 “has one” 관계를 다루는 방법을 보았다.
    하지만 “has many” 는 어떻게 처리할까?
    그건 다음 섹션에서 다루어보자.collection 엘리먼트는 관계를 파악하기 위해 작동한다.
    사실 이 내용이 중복되는 내용으로 차이점에 대해서만 주로 살펴보자.위 예제를 계속 진행하기 위해 Blog는 오직 하나의 Author를 가진다.
    하지만 Blog는 많은 Post 를 가진다.
    Blog 클래스에 다음처럼 처리될 것이다.List에 내포된 결과를 매핑하기 위해 collection엘리먼트를 사용한다.
    association 엘리먼트와는 달리 조인에서 내포된 select나 내포된 결과를 사용할 수 있다.Collection 을 위한 내포된(Nested) Select먼저 Blog의 Post를 로드하기 위한 내포된 select 를 사용해보자.바로 눈치챌 수 있는 몇가지가 있지만 대부분 앞서 배운 association 엘리먼트와 매우 유사하다.
    먼저 collection 엘리먼트를 사용한 것이 보일 것이다.
    그리고 나서 새로운 “ofType” 속성을 사용한 것을 알아차렸을 것이다.
    이 속성은 자바빈 프로퍼티 타입과 collection 의 타입을 구분하기 위해 필요하다.독자 왈: “Post의 ArrayList타입의 글 목록”
        javaType 속성은 그다지 필요하지 않다.
    마이바티스는 대부분의 경우 이 속성을 사용하지 않을 것이다.
    그래서 간단하게 설정할 수 있다.Collection을 위한 내포된(Nested) Results이 시점에 collection 을 위한 내포된 결과가 어떻게 작동하는지 짐작할 수 있을 것이다.
    왜냐하면 association와 정확히 일치하기 때문이다.
    하지만 “ofType” 속성이 추가로 적용되었다.먼저 SQL을 보자.다시보면 Blog와 Post테이블을 조인했고 간단한 매핑을 위해 칼럼명에 적절한 별칭을 주었다.
    이제 Post의 Collection을 가진 Blog의 매핑은 다음처럼 간단해졌다.다시 여기서 id엘리먼트의 중요성을 기억해두거나 기억이 나지 않으면 association섹션에서 다시 읽어둬라.혹시 결과 매핑의 재사용성을 위해 긴 형태를 선호한다면 다음과 같은 형태로도 가능하다. associations과 collections에서 내포의 단계 혹은 조합에는 제한이 없다.
    매핑할때는 성능을 생각해야 한다.
    단위테스트와 성능테스트는 애플리케이션에서 가장 좋은 방법을 찾도록 지속해야 한다.
    마이바티스는 이에 수정비용을 최대한 줄이도록 해줄 것이다.복잡한 association 과 collection 매핑은 어려운 주제다.
    문서에서는 여기까지만 설명을 할수 있다.
    연습을 더 하면 명확하게 이해할 수 있을것이다.
        종종 하나의 데이터베이스 쿼리는 많고 다양한 데이터 타입의 결과를 리턴한다.
    discriminator엘리먼트는 클래스 상속 관계를 포함하여 이러한 상황을 위해 고안되었다.
    discriminator는 자바의 switch와 같이 작동하기 때문에 이해하기 쉽다.discriminator정의는 colume과 javaType속성을 명시한다.
    colume은 마이바티스로 하여금 비교할 값을 찾을 것이다.
    javaType은 동일성 테스트와 같은 것을 실행하기 위해 필요하다.
    예를들어이 예제에서 마이바티스는 결과데이터에서 각각의 레코드를 가져와서 vehicle_type값과 비교한다.
    만약 discriminator비교값과 같은 경우가 생기면 이 경우에 명시된 resultMap을 사용할 것이다.
    해당되는 경우가 없다면 무시된다.
    만약 일치하는 경우가 하나도 없다면 마이바티스는 discriminator블럭 밖에 정의된 resultMap을 사용한다.
    carResult가 다음처럼 정의된다면doorCount프로퍼티만이 로드될 것이다.
    discriminator경우들의 독립적인 결과를 만들어준다.
    이 경우 우리는 물론 car와 vehicle간의 관계를 알 수 있다.
    그러므로 나머지 프로퍼티들도 로드하길 원하게 된다.
    그러기 위해서는 간단하게 하나만 변경하면 된다.vehicleResult와 carResult의 모든 프로퍼티들이 로드 될 것이다.한가지 더 도처에 설정된 외부 정의를 찾게 될지도 모른다.
    그러므로 간결한 매핑 스타일의 문법이 있다.
    예를들면 모든 결과 매핑이 있고 모두 명시하고 싶지 않다면
      마이바티스는 칼럼과 프로퍼티 명으로 자동으로 매핑할 것이다.
      이 예제는 실제로 필요한 내용보다 많이 서술되어 있다.Auto-mapping
          이전의 절에서 이미 본것처럼 간단한 경우 마이바티스는 결과를 자동으로 매핑할 수 있고 간단하지 않은 경우에는 직접 결과매핑을 만들필요가 있다.
          하지만 이 절에서 보는것처럼 두가지 방법을 적절히 혼용할수도 있다.
          자동매핑을 처리하는 방법을 조금 더 보자.
        
          결과를 자동매핑할때 마이바티스는 칼럼명을 가져와서 대소문자를 무시한 같은 이름의 프로퍼티를 찾을 것이다.
          칼럼명이 라면  이름의 프로퍼티를 찾는다는 것을 뜻한다.
          마이바티스는  칼럼값을 사용해서  프로퍼티를 설정할것이다.
        
          대개 데이터베이스 칼럼은 대문자를 사용해서 명명하고 단어 사이사이에는 밑줄을 넣는다.
          자바 프로퍼티는 대개 낙타표기법을 사용해서 명명한다.
          이런 둘사이의 자동매핑을 가능하게 하기 위해서는  를 true로 설정하자.
        
          자동매핑은 결과매핑을 선언한 경우에도 동작한다.
          이런 경우 각각의 결과매핑에서 ResultSet의 모든 칼럼은 자동매핑이 아니라 수동매핑으로 처리한다.
          다음 샘플에서  칼럼은 자동매핑되고  칼럼은 수동으로 매핑한다. 
          자동매핑에는 3가지가 있다.
         - 자동매핑을 사용하지 않는다.
      오직 수동으로 매핑한 프로퍼티만을 설정할것이다.
           - 조인 내부에 정의한 내포된 결과매핑을 제외하고 자동매핑한다.
           - 모든것을 자동매핑한다.
          
          디폴트값은 이다.
           을 사용할때 자동매핑은 조인결과나 같은 레코드의 여러가지 다른 엔터티를 가져올때 예상치 못한 문제를 야기할 수 있다.
          이런 위험을 이해하기 위해 다음의 샘플을 보자.
         는 자동매핑으로 처리하지만  프로퍼티를 가지고 ResultSet은  칼럼을 가진다.
          그래서 기대한 것과는 달리 저자(Author)의 id는 블로그(Blog)의 id로 채워질것이다.
           는 이런 위험을 가진다.
        
          자동매핑 설정에 상관없이 구문별로 속성을 추가해서 자동매핑을 사용하거나 사용하지 않을수도 있다.
        마이바티스는 쉽게 설정가능하고 변경가능한 쿼리 캐싱 기능을 가지고 있다.
    마이바티스 3 캐시 구현체는 강력하고 쉽게 설정할 수 있도록 많은 부분이 수정되었다.성능을 개선하고 순환하는 의존성을 해결하기 위해 필요한 로컬 세션 캐싱을 제외하고 기본적으로 캐시가 작동하지 않는다.
    캐싱을 활성화하기 위해서 SQL 매핑 파일에 한줄을 추가하면 된다.하나의 간단한 구문에 다음과 같은 순서로 영향을 준다.매핑 구문 파일내 select 구문의 모든 결과가 캐시 될 것이다.매핑 구문 파일내 insert, update 그리고 delete 구문은 캐시를 지울(flush) 것이다.캐시는 Least Recently Used (LRU) 알고리즘을 사용할 것이다.캐시는 스케줄링 기반으로 시간순서대로 지워지지는 않는다. (예를들면. no Flush Interval)캐시는 리스트나 객체에 대해 1024 개의 참조를 저장할 것이다. (쿼리 메소드가 실행될때마다)캐시는 읽기/쓰기 캐시처럼 처리될 것이다. 이것은 가져올 객체는 공유되지 않고 호출자에 의해 안전하게 변경된다는 것을 의미한다. 캐시는 cache 태그를 사용한 매퍼에 선언된 구문에만 적용된다.
          XML 매퍼와 함께 Java API를 사용하는 경우 Java 매퍼에 작성된 구문을 캐시 적용 대상에 포함시키려면 을 사용하여 XML 매퍼의 namespace를 지정해야 한다.
        모든 프로퍼티는 cache 엘리먼트의 속성을 통해 변경가능하다.
    예를들면많은 프로퍼티가 셋팅된 이 설정은 60 초마다 캐시를 지우는 FIFO 캐시를 생성한다.
    이 캐시는 결과 객체 또는 결과 리스트를 512개까지 저장하고 각 객체는 읽기 전용이다.
    캐시 데이터를 변경하는 것은 개별 쓰레드에서 호출자간의 충돌을 야기할 수 있다.사용가능한 캐시 전략은 4가지이다. – Least Recently Used: 가장 오랜시간 사용하지 않는 객체를 제거 – First In First Out: 캐시에 들어온 순서대로 객체를 제거 – Soft Reference: 가비지 컬렉터의 상태와 강하지 않은 참조(Soft References )의 규칙에 기초하여 객체를 제거 – Weak Reference: 가비지 컬렉터의 상태와 약한 참조(Weak References)의 규칙에 기초하여 점진적으로 객체 제거디폴트 값은 LRU 이다.flushInterval 은 양수로 셋팅할 수 있고 밀리세컨드로 명시되어야 한다.
    디폴트는 셋팅되지 않으나 플러시(flush) 주기를 사용하지 않으면 캐시는 오직 구문이 호출될때마다 캐시를 지운다.size는 양수로 셋팅할 수 있고 캐시에 객체의 크기를 유지하지만 메모리 자원이 충분해야 한다.
    디폴트 값은 1024 이다.readOnly 속성은 true 또는 false 로 설정 할 수 있다.
    읽기 전용 캐시는 모든 호출자에게 캐시된 객체의 같은 인스턴스를 리턴 할 것이다.
    게다가 그 객체는 변경할 수 없다.
    이건 종종 성능에 잇점을 준다.
    읽고 쓰는 캐시는 캐시된 객체의 복사본을 리턴 할 것이다.
    이건 조금 더 늦긴 하지만 안전하다.
    디폴트는 false 이다.사용자 지정 캐시 사용하기앞서 본 다양한 설정방법에 더해 자체적으로 개발하거나 써드파티 캐시 솔루션을 사용하여 캐시 처리를 할 수 있다.이 예제는 사용자 지정 캐시 구현체를 사용하는 방법을 보여준다.
    type속성에 명시된 클래스는 org.apache.ibatis.cache.Cache인터페이스를 반드시 구현해야 한다.
    이 인터페이스는 마이바티스 프레임워크의 가장 복잡한 구성엘리먼트 중 하나이다.
    하지만 하는 일은 간단하다.캐시를 설정하기 위해 캐시 구현체에 public 자바빈 프로퍼티를 추가하고 cache 엘리먼트를 통해 프로퍼티를 전달한다.
    예를들어 다음 예제는 캐시 구현체에서 “setCacheFile(String file)” 를 호출하여 메소드를 호출할 것이다.
      모든 간단한 타입의 자바빈 프로퍼티를 사용할 수 있다. 마이바티스는 변환할 것이다.
       에 정의된 값을 대체할 placeholder(예: ) 를 지정할 수 있다.
    
      3.4.2 부터, MyBatis 는 모든 properties 를 설정한 후 초기화 메서드를 호출하도록 지원한다.
      이 기능을 사용하려면, custom 캐시 클래스에서  interface 를 구현해야 한다.
    캐시 설정과 캐시 인스턴스가 SQL Map 파일의 네임스페이스에 묶여지는(bound) 것을 기억하는게 중요하다.
    게다가 같은 네임스페이스내 모든 구문은 묶여진다.
    구문별로 캐시와 상호작동하는 방법을 변경할 수 있거나 두개의 간단한 속성을 통해 완전히 배제될 수도 있다.
    디폴트로 구문은 아래와 같이 설정된다.이러한 방법으로 구문을 설정하는 하는 방법은 굉장히 좋지 않다.
    대신 디폴트 행위를 변경해야 할 경우에만 flushCache와 useCache 속성을 변경하는 것이 좋다.
    예를들어 캐시에서 특정 select 구문의 결과를 제외하고 싶거나 캐시를 지우기 위한 select 구문을 원할 것이다.
    유사하게 실행할때마다 캐시를 지울 필요가 없는 update구문도 있을 것이다.이전 섹션 내용을 돌이켜보면서 특정 네임스페이스을 위한 캐시는 오직 하나만 사용되거나 같은 네임스페이스내에서는 구문마다 캐시를 지울수 있다.
    네임스페이스간의 캐시 설정과 인스턴스를 공유하고자 할때가 있을 것이다.
    이 경우 cache-ref 엘리먼트를 사용해서 다른 캐시를 참조할 수 있다./Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/ko/xdoc/statement-builders.xml마이바티스 3 | SQL BUilder 클래스SQL Builder 클래스문제점자바코드에서 SQL을 작성하는 작업은 자바 개발자를 가장 힘들게 하는 것중 하나이다.
    대개는 동적 SQL을 작성해야 하지만 종종 파일이나 저장프로시저에 작성해야 할수도 있다.
    이미 본것처럼 마이바티스는 XML매핑 기능으로 동적 SQL을 처리하는 강력한 기능을 제공한다.
    하지만 종종 자바 코드를 사용해서 SQL구문을 만들어야 할수도 있다.
    마이바티스는 이런 경우를 위한 기능도 제공한다.
    더하기 기호나 따옴표, 개행처리, 포매팅 그리고 콤마나 문자열을 합치는 등의 다양한 조건을 처리하지 않아도 되도록 해준다.
    정말 자바코드에서 SQL을 동적으로 만드는 것은 악몽과 같다.
    예를들어보자.
        해결방법마이바티스 3은 이런 문제를 해결하기 위해 편리한 클래스를 제공한다.
    SQL클래스를 사용해서 인스턴스를 만들고 SQL구문을 만드는 메소드를 호출하자.
    위 문제가 되는 예제를 SQL클래스를 사용해서 재작성하면 다음과 같다.
      이 예제가 특별한게 뭘까? 자 조금더 자세히 보자.
    "AND" 키워드가 중복으로 나오는 것이나 "WHERE"과 "AND"를 선택하는데 걱정할 필요가 없다.
    SQL클래스는 "WHERE"가 필요한 위치를 이해하고 처리한다.
    그리고 "AND"를 사용하고 문자열을 합쳐야 하는 부분에 대해서도 알고 처리한다.
        SQL 클래스여기에 몇가지 예제가 있다. 
// 익명 내부 클래스
public String deletePersonSql() {
  return new SQL() {{
    DELETE_FROM("PERSON");
    WHERE("ID = #{id}");
  }}.toString();
}

// 빌더 / 깔끔한 형태
public String insertPersonSql() {
  String sql = new SQL()
    .INSERT_INTO("PERSON");
    .VALUES("ID, FIRST_NAME", "#{id}, #{firstName}");
    .VALUES("LAST_NAME", "#{lastName}")
    .toString();
  return sql;
}

// 분기처리를 포함한 형태 (final 파라미터, 파라미터에 접근하는 익명 내부 클래스가 필요함)
public String selectPersonLike(final String id, final String firstName, final String lastName) {
  return new SQL() {{
    SELECT("P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME");
    FROM("PERSON P");
    if (id != null) {
      WHERE("P.ID like #{id}");
    }
    if (firstName != null) {
      WHERE("P.FIRST_NAME like #{firstName}");
    }
    if (lastName != null) {
      WHERE("P.LAST_NAME like #{lastName}");
    }
    ORDER_BY("P.LAST_NAME");
  }}.toString();
}

public String deletePersonSql() {
  return new SQL() {{
    DELETE_FROM("PERSON");
    WHERE("ID = #{id}");
  }}.toString();
}

public String insertPersonSql() {
  return new SQL() {{
    INSERT_INTO("PERSON");
    VALUES("ID, FIRST_NAME", "#{id}, #{firstName}");
    VALUES("LAST_NAME", "#{lastName}");
  }}.toString();
}

public String updatePersonSql() {
  return new SQL() {{
    UPDATE("PERSON");
    SET("FIRST_NAME = #{firstName}");
    WHERE("ID = #{id}");
  }}.toString();
}
메소드절로 시작하거나 덧붙이기.
        한번 이상 호출할 수 있고 파라미터는 절에 덧붙일것이다.
        파라미터는 칼럼과 별칭의 목록을 콤마를 구분자로 나열하지만 드라이버에 따라 처리가 안될수도 있다.
              DISTINCT절로 시작하거나 덧붙이기.
        생성된 쿼리에 를 추가한다.
        한번 이상 호출할 수 있고 파라미터는 절에 덧붙일것이다.
        파라미터는 테이블명과 별칭이지만 드라이버에 따라 처리가 안될수도 있다.
              새로운 적절한 타입의 절을 추가.
        타입은 호출하는 메소드에 따라 다르다.
        파라미터는 조인을 구성하는 칼럼과 조건이다.
              새로운 절과 로 합친 조건을 덧붙인다.
        여러번 호출할 수 있고 를 사용할때마다 새로운 조건을 합친다.
        로 분리하려면 를 사용하자.
              SQL를 사용해서 조건절을 분리한다.
        여러번 호출할 수 있지만 한개의 로우에 여러번 호출할 경우 에러를 가진 을 만들수도 있다.
              를 가진 절을 분리한다.
        여러번 호출할 수 있지만 여러번 호출할 경우 에러를 가진 을 만들수도 있다.
         두가지는 를 자동으로 붙이기 때문에
        흔하게 사용하지 않고 필요할때만 사용한다.
              절을 콤마를 더해서 덧붙인다.
        여러번 호출할 수 있고 개별 조건을 콤마를 붙여서 합칠 수 있다.
              절을 AND를 더해서 덧붙인다.
        여러번 호출할 수 있고 개별 조건을 를 붙여서 합칠 수 있다.
        로 분리하기 위해서는 절을 콤마를 더해서 덧붙인다.
        여러번 호출할 수 있고 개별조건을 콤마를 붙여서 합칠수 있다.
              
                Appends a  clause.
                This method valid when use together with SELECT(), UPDATE() and DELETE().
                And this method is designed to use together with OFFSET() when use SELECT(). (Available since 3.5.2)
               clause.
                This method valid when use together with SELECT().
                And this method is designed to use together with LIMIT(). (Available since 3.5.2)
               clause.
                This method valid when use together with SELECT().
                And this method is designed to use together with FETCH_FIRST_ROWS_ONLY(). (Available since 3.5.2)
               clause.
                This method valid when use together with SELECT().
                And this method is designed to use together with OFFSET_ROWS(). (Available since 3.5.2)
              delete구문을 시작하고 삭제할 테이블을 명시한다.
        대개는 WHERE구문이 뒤에 붙여서 삭제한 대상 조건을 명시한다.
              insert구문을 시작하고 입력한 테이블을 명시한다.
        VALUES() or INTO_COLUMNS() and INTO_VALUES() 메소드 호출은 여러번 해서 입력한 칼럼과 값을 명시한다.
              update구문에서 "set" 대상 목록을 덧붙인다. update구문을 시작하고 update수정할 테이블을 명시한다.
        수정할 칼럼과 값을 명시하기 위해 SET()메소드 호출을 여러번 할수 있고 대개 수정할 대상 데이터를 한정하기 위해 WHERE()메소드도 호출한다.
              insert구문에 덧붙인다.
        첫번째 파라미터는 입력한 칼럼이고 두번째 파라미터는 입력할 값이다.
              
                insert 구문에 columns 절을 추가한다.
                반드시 INTO_VALUES()와 함께 호출되어야 한다.
              
                insert 구문에 values 절을 추가한다.
                반드시 INTO_COLUMNS()와 함께 호출되어야 한다.
              
                Add new row for bulk insert. (Available since 3.5.2)
              3.4.2 버전부터, variable-length 매개변수를 아래와 같이 사용할 수 있습니다.SqlBuilder 와 SelectBuilder (향후 제거예정)3.2버전 이전에는 다른 방법을 사용했다.
    자바 DSL을 다루기 힘든 언어의 제한점을 가리기 위해 ThreadLocal변수를 사용했다.
    하지만 이 방법은 이제 사용하지 않길 바란다.
    최근에는 빌더 타입의 패턴과 익명 내부 클래스를 사용하는 추세이다.
    그러므로 SelectBuilder 와 SqlBuilder는 향후 제거할 예정이다.
        
        다음에 나열된 메소드는 SqlBuilder 와 SelectBuilder클래스에서만 사용할 수 있다.
        이 메소드는 SelectBuilder클래스의 ThreadLocal상태를 지우고 새로운 구문을 만들 준비를 한다.
      은 새로운 구문을 시작할때 사용하는게 좋다.
      은 처리중인 구문의 상태를 몇가지 사유로 지워야 할때 사용하는게 좋다.
      (아마도 몇가지 사유로 완전히 다른 구문을 실행해야 할때 사용할것이다.)
          생성된 를 리턴하고 상태를 재설정(마치 이나 을 호출한것처럼)한다.
      이 메소드는 한번만 호출할 수 있다.
          
    SelectBuilder와 SqlBuilder클래스가 신기하지는 않지만 이 클래스가 동작하는 방식을 아는게 중요하다.
    SelectBuilder와 SqlBuilder는 문법을 명확히 처리하기 위해 Static Imports와 ThreadLocal변수의 조합을 사용한다.
    이 두가지 클래스를 사용하기 위해 다음처럼 정적인 방법으로 import할 필요가 있다.
        다음처럼 메소드를 생성하도록 해준다. 
/* 향후 제거예정 */
public String selectBlogsSql() {
  BEGIN(); // ThreadLocal 변수 제거
  SELECT("*");
  FROM("BLOG");
  return SQL();
}
        
/* 향후 제거예정 */
private String selectPersonSql() {
  BEGIN(); // ThreadLocal 변수 제거
  SELECT("P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME");
  SELECT("P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON");
  FROM("PERSON P");
  FROM("ACCOUNT A");
  INNER_JOIN("DEPARTMENT D on D.ID = P.DEPARTMENT_ID");
  INNER_JOIN("COMPANY C on D.COMPANY_ID = C.ID");
  WHERE("P.ID = A.ID");
  WHERE("P.FIRST_NAME like ?");
  OR();
  WHERE("P.LAST_NAME like ?");
  GROUP_BY("P.ID");
  HAVING("P.LAST_NAME like ?");
  OR();
  HAVING("P.FIRST_NAME like ?");
  ORDER_BY("P.ID");
  ORDER_BY("P.FULL_NAME");
  return SQL();
}
        /Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/pdf.xmlhttp://maven.apache.org/DOCUMENT/1.0.1http://maven.apache.org/DOCUMENT/1.0.1 https://maven.apache.org/xsd/document-1.0.1.xsdoutputName${project.artifactId}-${project.version}metaMyBatis - the world's most popular SQL Mapping framework.The MyBatis TeamtocTable of ContentsIntroductionrefindex.xmlGetting Startedgetting-started.xmlConfiguration XMLconfiguration.xmlMapper XML Filessqlmap-xml.xmlDynamic SQLdynamic-sql.xmljava-api.xmlStatement Buildersstatement-builders.xmlLogginglogging.xmlcovercoverTitle${project.name}coverSubTitlev. ${project.version}coverTypeUser GuideprojectNameprojectLogohttps://mybatis.org/images/mybatis-logo.pngcompanyName${project.organization.name}/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/site.xmlhttp://maven.apache.org/SITE/2.0.0http://maven.apache.org/SITE/2.0.0 https://maven.apache.org/xsd/site-2.0.0.xsdmenuReference Documentationindex.htmlgetting-started.htmlconfiguration.htmlcollapseconfiguration.html#settingsconfiguration.html#typealiasesconfiguration.html#typehandlersconfiguration.html#objectfactoryconfiguration.html#pluginsconfiguration.html#environmentsconfiguration.html#databaseidproviderconfiguration.html#mapperssqlmap-xml.htmlsqlmap-xml.html#selectsqlmap-xml.html#insert-update-and-deletesqlmap-xml.html#parameterssqlmap-xml.html#result-mapssqlmap-xml.html#auto-mappingsqlmap-xml.html#cachedynamic-sql.htmljava-api.htmljava-api.html#directory-structurejava-api.html#sqlsessionsSQL Builder Classstatement-builders.htmllogging.htmlreports/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/site_es.xmlManual de ReferenciaIntroducciónPrimeros pasosconfiguration.html#typeAliasesconfiguration.html#typeHandlersconfiguration.html#objectFactoryconfiguration.html#databaseIdProvidersqlmap-xml.html#insert_update_and_deletesqlmap-xml.html#Parameterssqlmap-xml.html#Result_Mapssqlmap-xml.html#Auto-mapeojava-api.html#directoryStructurejava-api.html#sqlSessions/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/site_fr.xmlCorePremiers pasFichiers Mappers XMLinsert, update et deleteParamètresResultMapssqlmap-xml.html#Auto-mappingSQL DynamiqueAPI JavaArborescence des répertoiresSessions SQLConstruction de requêtesstatement-builders.html#SelectBuilderstatement-builders.html#SqlBuilderJournalisation/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/site_ja.xmlイントロダクションスタートガイドステートメントビルダーロギング/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/site_ko.xml소개시작하기매퍼 설정로깅/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/site_zh.xml参考文档简介入门XML 配置设置类型别名类型处理器对象工厂插件环境配置数据库厂商标识映射器XML 映射文件insert, update 和 delete参数结果映射自动映射缓存动态 SQL目录结构SQL 语句构建器日志/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/zh_CN/xdoc/configuration.xml/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/zh_CN/xdoc/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/zh_CNMyBatis 3 | 配置nanlei1987@gmail.comNan Leiechowdx@gmail.comDongxu Wang配置MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。
      配置文档的顶层结构如下：properties（属性）settings（设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境配置）transactionManager（事务管理器）dataSource（数据源）
                  environment（环境变量）
                  databaseIdProvider（数据库厂商标识）mappers（映射器）
          configuration（配置）
          属性（properties）这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。例如：设置好的属性可以在整个配置文件中用来替换需要动态配置的属性值。比如:
        这个例子中的 username 和 password 将会由 properties 元素中设置的相应值来替换。
          driver 和 url 属性将会由 config.properties 文件中对应的值来替换。这样就为配置提供了诸多灵活选择。也可以在 SqlSessionFactoryBuilder.build() 方法中传入属性值。例如：SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);

// ... 或者 ...

SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props);
如果一个属性在不只一个地方进行了配置，那么，MyBatis 将按照下面的顺序来加载：首先读取在 properties 元素体内指定的属性。
          然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据
          url 属性指定的路径读取属性文件，并覆盖之前读取过的同名属性。
          最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。
          因此，通过方法参数传递的属性具有最高优先级，resource/url
        属性中指定的配置文件次之，最低优先级的则是 properties 元素中指定的属性。
        从 MyBatis 3.4.2 开始，你可以为占位符指定一个默认值。例如：
        
<dataSource type="POOLED">
  <!-- ... -->
  <property name="username" value="${username:ut_user}"/> <!-- 如果属性 'username' 没有被配置，'username' 属性的值将为 'ut_user' -->
</dataSource>
      这个特性默认是关闭的。要启用这个特性，需要添加一个特定的属性来开启这个特性。例如：
        
<properties resource="org/mybatis/example/config.properties">
  <!-- ... -->
  <property name="org.apache.ibatis.parsing.PropertyParser.enable-default-value" value="true"/> <!-- 启用默认值特性 -->
</properties>提示${tableName != null ?
          tableName : 'global_constants'}
          如果你在属性名中使用了 
          字符（如：），或者在 SQL
          映射中使用了 OGNL 表达式的三元运算符（如： ），就需要设置特定的属性来修改分隔属性名和默认值的字符。例如：
        
<properties resource="org/mybatis/example/config.properties">
  <!-- ... -->
  <property name="org.apache.ibatis.parsing.PropertyParser.default-value-separator" value="?:"/> <!-- 修改默认值的分隔符 -->
</properties>设置（settings）这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。
        下表描述了设置中各项设置的含义、默认值等。设置名描述有效值默认值
                全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。
              
                延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。
                特定关联关系中可通过设置 
                属性来覆盖该项的开关状态。
              
                开启时，任一方法的调用都会加载该对象的所有延迟加载属性。
                否则，每个延迟加载属性会按需加载（参考 )。
              
                false （在 3.4.1 及之前的版本中默认为 true）
              
                是否允许单个语句返回多结果集（需要数据库驱动支持）。
              
                使用列标签代替列名。实际表现依赖于数据库驱动，具体可参考数据库驱动的相关文档，或通过对比测试来观察。
              
                允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为
                true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。
              
                指定 MyBatis 应如何自动映射列到字段或属性。
                NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。
                FULL 会自动映射任何复杂的结果集（无论是否嵌套）。
              : 不做任何反应:
                  输出警告日志（
                  的日志等级必须设置为 ）: 映射失败 (抛出 
        指定发现自动映射目标未知列（或未知属性类型）的行为。
                
                配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（PreparedStatement）；
                BATCH 执行器不仅重用语句还会执行批量更新。
              
                设置超时时间，它决定数据库驱动等待数据库响应的秒数。
              
                任意正整数
              
                未设置 (null)
              
                为驱动的结果集获取数量（fetchSize）设置一个建议值。此参数只可以在查询设置中被覆盖。
              
                指定语句默认的滚动策略。（新增于 3.5.2）
              
                FORWARD_ONLY | SCROLL_SENSITIVE | SCROLL_INSENSITIVE | DEFAULT（等同于未设置）
              
                是否允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。
              
                是否允许在嵌套语句中使用结果处理器（ResultHandler）。如果允许使用则设置为 false。
              
                是否开启驼峰命名自动映射，即从经典数据库列名
                A_COLUMN 映射到经典 Java 属性名 aColumn。
              
                MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。
                默认值为 SESSION，会缓存一个会话中执行的所有查询。
                若设置值为 STATEMENT，本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。
              
                当没有为参数指定特定的 JDBC 类型时，空值的默认 JDBC 类型。
                某些数据库驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。
              
                JdbcType 常量，常用值：NULL、VARCHAR 或 OTHER。
              
                指定对象的哪些方法触发一次延迟加载。
              
                用逗号分隔的方法列表。
              
                指定动态 SQL 生成使用的默认脚本语言。
              
                一个类型别名或全限定类名。
              
                指定 Enum 使用的默认  。（新增于 3.4.5）
              
                指定当结果集中值为 null 的时候是否调用映射对象的 setter（map
                对象时为 put）方法，这在依赖于 Map.keySet() 或 null
                值进行初始化时比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。
              
        当返回行的所有列都是空时，MyBatis默认返回 。
        当开启这个设置时，MyBatis会返回一个空实例。
        请注意，它也适用于嵌套的结果集（如集合或关联）。（新增于 3.4.2）
              
                指定 MyBatis 增加到日志名称的前缀。
              
                任何字符串
              
                未设置
              
                指定 MyBatis 所用日志的具体实现，未指定时将自动查找。
              
                SLF4J | LOG4J（3.5.9 起废弃） | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING
              
                指定 Mybatis 创建可延迟加载对象所用到的代理工具。
              
                CGLIB （3.5.10 起废弃） | JAVASSIST
              
                JAVASSIST （MyBatis 3.3 以上）
              
                指定 VFS 的实现
              
                自定义 VFS 的实现的类全限定名，以逗号分隔。
              
                允许使用方法签名中的名称作为语句参数名称。
            为了使用该特性，你的项目必须采用 Java 8 编译，并且加上  选项。（新增于 3.4.1）
              
                指定一个提供  实例的类。
                这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。
                这个类必须包含一个签名为 的方法。（新增于 3.2.3）
              
                一个类型别名或完全限定类名。
              
                从SQL中删除多余的空格字符。请注意，这也会影响SQL中的文字字符串。 (新增于 3.5.5)
              
                指定一个拥有 provider 方法的 sql provider 类 （新增于 3.5.6）.
                这个类适用于指定 sql provider 注解上的（或 ） 属性（当这些属性在注解中被忽略时）。 (e.g. )
              
                类型别名或者全限定名
              
                为 'foreach' 标签的 'nullable' 属性指定默认值。（新增于 3.5.9）
              
               当应用构造器自动映射时，参数名称被用来搜索要映射的列，而不再依赖列的顺序。（新增于 3.5.10）
              
          一个配置完整的 settings 元素的示例如下：
        类型别名（typeAliases）类型别名可为 Java 类型设置一个缩写名字。
        它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如：当这样配置时， 可以用在任何使用  的地方。也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：
        每一个在包  中的 Java Bean，在没有注解的情况下，会使用
        Bean 的首字母小写的非限定类名来作为它的别名。
          比如  的别名为
          ；若有注解，则别名为其注解值。见下面的例子：下面是一些为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。
                别名
              
                映射的类型
              类型处理器（typeHandlers）MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时，
          都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器。
         从 3.4.5 开始，MyBatis 默认支持 JSR-310（日期和时间 API） 。
        
                类型处理器
              
                Java 类型
              
                JDBC 类型
              
                数据库兼容的  或 
                数据库兼容的字节流类型
               或未指定类型
              
                VARCHAR 或任何兼容的字符串类型，用来存储枚举的名称（而不是索引序数值）
              
                任何兼容的 
                类型，用来存储枚举的序数值（而不是名称）。
              
          你可以重写已有的类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。
          具体做法为：实现  接口，
          或继承一个很便利的类 ，
          并且可以（可选地）将它映射到一个 JDBC 类型。比如：
        
          使用上述的类型处理器将会覆盖已有的处理 Java String 类型的属性以及
          VARCHAR 类型的参数和结果的类型处理器。
          要注意 MyBatis 不会通过检测数据库元信息来决定使用哪种类型，所以你必须在参数和结果映射中指明字段是 VARCHAR 类型，
          以使其能够绑定到正确的类型处理器上。这是因为 MyBatis 直到语句被执行时才清楚数据类型。
        
          通过类型处理器的泛型，MyBatis 可以得知该类型处理器处理的 Java 类型，不过这种行为可以通过两种方法改变：
        
            在类型处理器的配置元素（typeHandler 元素）上增加一个
             属性（比如：）；
            
            在类型处理器的类上增加一个
             注解指定与其关联的 Java 类型列表。
            如果在  属性中也同时指定，则注解上的配置将被忽略。
          可以通过两种方式来指定关联的 JDBC 类型：
            在类型处理器的配置元素上增加一个 
            属性（比如：）；
          
            在类型处理器的类上增加一个 
            注解指定与其关联的 JDBC 类型列表。
            如果在 javaType=[Java 类型], jdbcType=null限制只有一个
          当在  中决定使用哪种类型处理器时，此时 Java
          类型是已知的（从结果类型中获得），但是 JDBC 类型是未知的。
        因此 Mybatis 使用 
          的组合来选择一个类型处理器。
        这意味着使用 
          注解可以类型处理器的作用范围，并且可以确保，除非显式地设置，否则类型处理器在
           中将不会生效。
        如果希望能在  中隐式地使用类型处理器，那么设置
           注解的  即可。
        然而从 Mybatis 3.4.0 开始，如果某个 Java 类型注册的类型处理器，即使没有设置 ，那么这个类型处理器也会是  使用 Java
          类型时的默认处理器。
        最后，可以让 MyBatis 帮你查找类型处理器：注意在使用自动发现功能的时候，只能通过注解方式来指定 JDBC 的类型。你可以创建能够处理多个类的泛型类型处理器。为了使用泛型类型处理器，
          需要增加一个接受该类的 class 作为参数的构造器，这样 MyBatis

          会在构造一个类型处理器实例的时候传入一个具体的类。 和 
        都是泛型类型处理器，我们将会在接下来的部分详细探讨。处理枚举类型若想映射枚举类型 ，则需要从 
        或者  中选择一个来使用。比如说我们想存储取近似值时用到的舍入模式。默认情况下，MyBatis 会利用
         来把  值转换成对应的名字。注意 
        在某种意义上来说是比较特别的，其它的处理器只针对某个特定的类，而它不同，它会处理任意继承了
         的类。不过，我们可能不想存储名字，相反我们的 DBA 会坚持使用整形值代码。那也一样简单：在配置文件中把
           加到  中即可，
          这样每个  将通过他们的序数值来映射成对应的整形数值。
        但要是你想在一个地方将  映射成字符串，在另外一个地方映射成整形值呢？
          自动映射器（auto-mapper）会自动地选用  来处理枚举类型，
          所以如果我们想用普通的 ，就必须要显式地为那些 SQL 语句设置要使用的类型处理器。
        （下一节才开始介绍映射器文件，如果你是首次阅读该文档，你可能需要先跳过这里，过会再来看。）注意，这里的 select 语句必须指定  而不是 。对象工厂（objectFactory）每次 MyBatis 创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成实例化工作。
          默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认无参构造方法，要么通过存在的参数映射来调用带有参数的构造方法。
          如果想覆盖对象工厂的默认行为，可以通过创建自己的对象工厂来实现。比如：ObjectFactory 接口很简单，它包含两个创建实例用的方法，一个是处理默认无参构造方法的，另外一个是处理带参数的构造方法的。
          另外，setProperties 方法可以被用来配置 ObjectFactory，在初始化你的 ObjectFactory 实例后，
          objectFactory 元素体中定义的属性会被传递给 setProperties 方法。插件（plugins）
          MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：
        这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。
          如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。
          因为在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis 的核心模块。
          这些都是更底层的类和方法，所以使用插件的时候要特别当心。通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用，
          这里的 Executor 是负责执行底层映射语句的内部对象。覆盖配置类除了用插件来修改 MyBatis 核心行为以外，还可以通过完全覆盖配置类来达到目的。只需继承配置类后覆盖其中的某个方法，再把它传递到 SqlSessionFactoryBuilder.build(myConfig) 方法即可。再次重申，这可能会极大影响 MyBatis 的行为，务请慎之又慎。环境配置（environments）
          MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中，
          现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema
          的多个生产数据库中使用相同的 SQL 映射。还有许多类似的使用场景。不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory
          实例只能选择一种环境。
          所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory
          实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单：
        每个数据库对应一个 SqlSessionFactory 实例
          为了指定创建哪种环境，只要将它作为可选的参数传递给
          SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是：
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);如果忽略了环境参数，那么将会加载默认环境，如下所示：
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, properties);environments 元素定义了如何配置环境。
        
          注意一些关键点:
        
            默认使用的环境 ID（比如：default="development"）。
          
            每个 environment 元素定义的环境 ID（比如：id="development"）。
          
            事务管理器的配置（比如：type="JDBC"）。
          
            数据源的配置（比如：type="POOLED"）。
          
          默认环境和环境 ID 顾名思义。
          环境可以随意命名，但务必保证默认的环境 ID 要匹配其中一个环境 ID。
        事务管理器（transactionManager）在 MyBatis 中有两种类型的事务管理器（也就是 type="[JDBC|MANAGED]"）：
            JDBC – 这个配置直接使用了 JDBC 的提交和回滚功能，它依赖从数据源获得的连接来管理事务作用域。默认情况下，为了与某些驱动程序兼容，它在关闭连接时启用自动提交。然而，对于某些驱动程序来说，启用自动提交不仅是不必要的，而且是一个代价高昂的操作。因此，从 3.5.10 版本开始，你可以通过将 "skipSetAutoCommitOnClose" 属性设置为 "true" 来跳过这个步骤。例如：
            
            MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。
            默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为。例如:
            
          如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器，因为
          Spring 模块会使用自带的管理器来覆盖前面的配置。
        
          这两种事务管理器类型都不需要设置任何属性。它们其实是类型别名，换句话说，你可以用
          TransactionFactory 接口实现类的全限定名或类型别名代替它们。
        public interface TransactionFactory {
  default void setProperties(Properties props) { // 从 3.5.2 开始，该方法为默认方法
    // 空实现
  }
  Transaction newTransaction(Connection conn);
  Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit);
}在事务管理器实例化后，所有在 XML 中配置的属性将会被传递给 setProperties()
        方法。你的实现还需要创建一个 Transaction 接口的实现类，这个接口也很简单：使用这两个接口，你可以完全自定义 MyBatis 对事务的处理。数据源（dataSource）dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。大多数 MyBatis
          应用程序会按示例中的例子来配置数据源。虽然数据源配置是可选的，但如果要启用延迟加载特性，就必须配置数据源。
          有三种内建的数据源类型（也就是 type="[UNPOOLED|POOLED|JNDI]"）：– 这个数据源的实现会每次请求时打开和关闭连接。虽然有点慢，但对那些数据库连接可用性要求不高的简单应用程序来说，是一个很好的选择。
          性能表现则依赖于使用的数据库，对某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形。UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性： – 这是 JDBC 驱动的 Java 类全限定名（并不是 JDBC 驱动中可能包含的数据源类）。
           – 这是数据库的 JDBC URL 地址。
           – 登录数据库的用户名。
           – 登录数据库的密码。
           – 默认的连接事务隔离级别。
           – 等待数据库操作完成的默认网络超时时间（单位：毫秒）。查看  的 API 文档以获取更多信息。
          作为可选项，你也可以传递属性给数据库驱动。只需在属性名加上“driver.”前缀即可，例如：
        UTF8encoding这将通过 DriverManager.getConnection(url, driverProperties) 方法传递值为
         的  属性给数据库驱动。
        – 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。
          这种处理方式很流行，能使并发 Web 应用快速响应请求。
        除了上述提到 UNPOOLED 下的属性外，还有更多属性用来配置 POOLED 的数据源： – 在任意时间可存在的活动（正在使用）连接数量，默认值：10
           – 任意时间可能存在的空闲连接数。
           – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒）
           – 这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直失败且不打印日志），默认值：20000 毫秒（即 20 秒）。
           – 这是一个关于坏连接容忍度的底层设置，
            作用于每一个尝试从缓存池获取连接的线程。
            如果这个线程获取到的是一个坏的连接，那么这个数据源允许这个线程尝试重新获取一个新的连接，但是这个重新尝试的次数不应该超过 
            与  之和。 默认值：3（新增于 3.4.5）
           – 发送到数据库的侦测查询，用来检验连接是否正常工作并准备接受请求。默认是“NO PING QUERY SET”，这会导致多数数据库驱动出错时返回恰当的错误消息。
           – 是否启用侦测查询。若开启，需要设置  属性为一个可执行的 SQL 语句（最好是一个速度非常快的 SQL 语句），默认值：false。
           – 配置 poolPingQuery 的频率。可以被设置为和数据库连接超时时间一样，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。
           – 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。这种数据源配置只需要两个属性：
         – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么将会直接从 InitialContext 中寻找 data_source 属性。
           – 这是引用数据源实例位置的上下文路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。
          和其他数据源配置类似，可以通过添加前缀“env.”直接把属性传递给 InitialContext。比如：
        这就会在 InitialContext 实例化时往它的构造方法传递值为  属性。
        
          你可以通过实现接口  来使用第三方数据源实现：
         可被用作父类来构建新的数据源适配器，比如下面这段插入 C3P0 数据源所必需的代码：
        为了令其工作，记得在配置文件中为每个希望 MyBatis 调用的 setter 方法增加对应的属性。
        下面是一个可以连接至 PostgreSQL 数据库的例子：数据库厂商标识（databaseIdProvider）
          MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的  属性。
          MyBatis 会加载带有匹配当前数据库  属性和所有不带  属性的语句。
          如果同时找到带有  和不带  的相同语句，则后者会被舍弃。
          为支持多厂商特性，只要像下面这样在 mybatis-config.xml 文件中加入  即可：
        
          databaseIdProvider 对应的 DB_VENDOR 实现会将 databaseId 设置为
           返回的字符串。
          由于通常情况下这些字符串都非常长，而且相同产品的不同版本会返回不同的值，你可能想通过设置属性别名来使其变短：
        
          在提供了属性别名时，databaseIdProvider 的 DB_VENDOR 实现会将 databaseId
          设置为数据库产品名与属性中的名称第一个相匹配的值，如果没有匹配的属性，将会设置为 “null”。
          在这个例子中，如果 
          返回“Oracle (DataDirect)”，databaseId 将被设置为“oracle”。
        
          并在 mybatis-config.xml 中注册来构建自己的 DatabaseIdProvider：
        public interface DatabaseIdProvider {
  default void setProperties(Properties p) { // 从 3.5.2 开始，该方法为默认方法
    // 空实现
  }
  String getDatabaseId(DataSource dataSource) throws SQLException;
}映射器（mappers）file:///
          既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要来定义 SQL 映射语句了。
          但首先，我们需要告诉 MyBatis 到哪里去找到这些语句。
          在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉
          MyBatis 到哪里去找映射文件。
          你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括  形式的 URL），或类名和包名等。例如：
        <!-- 使用相对于类路径的资源引用 -->
<mappers>
  <mapper resource="org/mybatis/builder/AuthorMapper.xml"/>
  <mapper resource="org/mybatis/builder/BlogMapper.xml"/>
  <mapper resource="org/mybatis/builder/PostMapper.xml"/>
</mappers><!-- 使用完全限定资源定位符（URL） -->
<mappers>
  <mapper url="file:///var/mappers/AuthorMapper.xml"/>
  <mapper url="file:///var/mappers/BlogMapper.xml"/>
  <mapper url="file:///var/mappers/PostMapper.xml"/>
</mappers><!-- 使用映射器接口实现类的完全限定类名 -->
<mappers>
  <mapper class="org.mybatis.builder.AuthorMapper"/>
  <mapper class="org.mybatis.builder.BlogMapper"/>
  <mapper class="org.mybatis.builder.PostMapper"/>
</mappers><!-- 将包内的映射器接口全部注册为映射器 -->
<mappers>
  <package name="org.mybatis.builder"/>
</mappers>这些配置会告诉 MyBatis 去哪里找映射文件，剩下的细节就应该是每个 SQL
        映射文件了，也就是接下来我们要讨论的。/Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/zh_CN/xdoc/dynamic-sql.xmlMyBatis 3 | 动态 SQLlu_picc@outlook.comZeShen Lu动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如：这条语句提供了可选的查找文本功能。如果不传入 “title”，那么所有处于 “ACTIVE” 状态的 BLOG 都会返回；如果传入了 “title” 参数，那么就会对 “title” 一列进行模糊查找并返回对应的 BLOG 结果（细心的读者可能会发现，“title” 的参数值需要包含查找掩码或通配符字符）。如果希望通过 “title” 和 “author” 两个参数进行可选搜索该怎么办呢？首先，我想先将语句名称修改成更名副其实的名称；接下来，只需要加入另一个条件即可。choose、when、otherwise有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员精选的 Blog）。trim、where、set前面几个例子已经方便地解决了一个臭名昭著的动态 SQL 问题。现在回到之前的 “if” 示例，这次我们将 “state = ‘ACTIVE’” 设置成动态条件，看看会发生什么。如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样：这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样:
        这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。MyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动： 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”， 元素也会将它们去除。如果  元素与你期望的不太一样，你也可以通过自定义 trim 元素来定制  元素的功能。比如，和  元素等价的自定义 trim 元素为： 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有  属性中指定的内容，并且插入  属性中指定的内容。用于动态更新语句的类似解决方案叫做  元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：这个例子中， 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。或者，你可以通过使用元素来达到同样的效果：注意，我们覆盖了后缀值设置，并且自定义了前缀值。动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如： 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！ 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。至此，我们已经完成了与 XML 配置及映射文件相关的讨论。下一章将详细探讨 Java API，以便你能充分利用已经创建的映射配置。要在带注解的映射器接口类中使用动态 SQL，可以使用  元素。比如: 元素允许你在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文。比如：多数据库支持如果配置了 databaseIdProvider，你就可以在动态代码中使用名为 “_databaseId” 的变量来为不同的数据库构建特定的语句。比如下面的例子：动态 SQL 中的插入脚本语言MyBatis 从 3.2 版本开始支持插入脚本语言，这允许你插入一种语言驱动，并基于这种语言来编写动态 SQL 查询语句。可以通过实现以下接口来插入一种语言：实现自定义语言驱动后，你就可以在 mybatis-config.xml 文件中将它设置为默认语言：或者，你也可以使用  属性为特定的语句指定语言：
        或者，在你的 mapper 接口上添加  注解： 可以使用 Apache Velocity 作为动态语言，更多细节请参考 MyBatis-Velocity 项目。你前面看到的所有 xml 标签都由默认 MyBatis 语言提供，而它由语言驱动 （别名为 ）所提供。
      /Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/zh_CN/xdoc/java-api.xml既然你已经知道如何配置 MyBatis 以及如何创建映射，是时候来尝点甜头了。MyBatis 的 Java API 就是这个甜头。稍后你将看到，和 JDBC 相比，MyBatis
  大幅简化你的代码并力图保持其简洁、容易理解和维护。为了使得 SQL 映射更加优秀，MyBatis 3 引入了许多重要的改进。在我们深入 Java API 之前，理解关于目录结构的最佳实践是很重要的。MyBatis 非常灵活，你可以随意安排你的文件。但和其它框架一样，目录结构有一种最佳实践。
  
  让我们看一下典型的应用目录结构：
  <-- MyBatis *.jar 文件在这里。<-- MyBatis 配置文件在这里，包括映射器类、XML 配置、XML 映射文件。<-- 在 XML 配置中出现的属性值在这里。当然，这是推荐的目录结构，并非强制要求，但使用一个通用的目录结构将更有利于大家沟通。本章接下来的示例将假定你遵循这种目录结构。使用 MyBatis 的主要 Java 接口就是 SqlSession。你可以通过这个接口来执行命令，获取映射器实例和管理事务。在介绍 SqlSession 接口之前，我们先来了解如何获取一个 SqlSession 实例。SqlSessions 是由 SqlSessionFactory 实例创建的。SqlSessionFactory 对象包含创建 SqlSession 实例的各种方法。而 SqlSessionFactory 本身是由 SqlSessionFactoryBuilder 创建的，它可以从 XML、注解或 Java 配置代码来创建 SqlSessionFactory。 当 Mybatis 与一些依赖注入框架（如 Spring 或者 Guice）搭配使用时，SqlSession 将被依赖注入框架创建并注入，所以你不需要使用 SqlSessionFactoryBuilder 或者 SqlSessionFactory，可以直接阅读 SqlSession 这一节。请参考 Mybatis-Spring 或者 Mybatis-Guice 手册以了解更多信息。SqlSessionFactoryBuilder 有五个 build() 方法，每一种都允许你从不同的资源中创建一个 SqlSessionFactory 实例。第一种方法是最常用的，它接受一个指向 XML 文件（也就是之前讨论的 mybatis-config.xml 文件）的 InputStream 实例。可选的参数是 environment 和 properties。environment 决定加载哪种环境，包括数据源和事务管理器。比如：如果你调用了带 environment 参数的 build 方法，那么 MyBatis 将使用该环境对应的配置。当然，如果你指定了一个无效的环境，会收到错误。如果你调用了不带 environment 参数的 build 方法，那么就会使用默认的环境配置（在上面的示例中，通过 default="development" 指定了默认环境）。如果你调用了接受 properties 实例的方法，那么 MyBatis 就会加载这些属性，并在配置中提供使用。绝大多数场合下，可以用 ${propName} 形式引用这些配置值。回想一下，在 mybatis-config.xml 中，可以引用属性值，也可以直接指定属性值。因此，理解属性的优先级是很重要的。在之前的文档中，我们已经介绍过了相关内容，但为了方便查阅，这里再重新介绍一下：如果一个属性存在于下面的多个位置，那么 MyBatis 将按照以下顺序来加载它们：首先，读取在 properties 元素体中指定的属性；其次，读取在 properties 元素的类路径 resource 或 url 指定的属性，且会覆盖已经指定了的重复属性；最后，读取作为方法参数传递的属性，且会覆盖已经从 properties 元素体和 resource 或 url 属性中加载了的重复属性。因此，通过方法参数传递的属性的优先级最高，resource 或 url 指定的属性优先级中等，在 properties 元素体中指定的属性优先级最低。
  总结一下，前四个方法很大程度上是相同的，但提供了不同的覆盖选项，允许你可选地指定 environment 和/或 properties。以下给出一个从 mybatis-config.xml 文件创建 SqlSessionFactory 的示例：注意，这里我们使用了 Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类正如其名，会帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。在略读该类的源代码或用 IDE 查看该类信息后，你会发现一整套相当实用的方法。这里给出一个简表：最后一个 build 方法接受一个 Configuration 实例。Configuration 类包含了对一个 SqlSessionFactory 实例你可能关心的所有内容。在检查配置时，Configuration 类很有用，它允许你查找和操纵 SQL 映射（但当应用开始接收请求时不推荐使用）。你之前学习过的所有配置开关都存在于 Configuration 类，只不过它们是以 Java API 形式暴露的。以下是一个简单的示例，演示如何手动配置 Configuration 实例，然后将它传递给 build() 方法来创建 SqlSessionFactory。现在你就获得一个可以用来创建 SqlSession 实例的 SqlSessionFactory 了。SqlSessionFactory 有六个方法创建 SqlSession 实例。通常来说，当你选择其中一个方法时，你需要考虑以下几点：事务处理：你希望在 session 作用域中使用事务作用域，还是使用自动提交（auto-commit）？（对很多数据库和/或 JDBC 驱动来说，等同于关闭事务支持）数据库连接：你希望 MyBatis 帮你从已配置的数据源获取连接，还是使用自己提供的连接？语句执行：你希望 MyBatis 复用 PreparedStatement 和/或批量更新语句（包括插入语句和删除语句）吗？基于以上需求，有下列已重载的多个 openSession() 方法供使用。默认的 openSession() 方法没有参数，它会创建具备如下特性的 SqlSession：将会事务作用域开启（也就是不自动提交）。将由当前环境配置的 DataSource 实例中获取 Connection 对象。事务隔离级别将会使用驱动或数据源的默认设置。预处理语句不会被复用，也不会批量处理更新。相信你已经能从方法签名中知道这些方法的区别。向  可选参数传递  值即可开启自动提交功能。若要使用自己的  实例，传递一个  实例给  参数即可。注意，我们没有提供同时设置  的方法，这是因为 MyBatis 会依据传入的 Connection 来决定是否启用 autoCommit。对于事务隔离级别，MyBatis 使用了一个 Java 枚举包装器来表示，称为 ，事务隔离级别支持 JDBC 的五个隔离级别（、），并且与预期的行为一致。你可能对  参数感到陌生。这个枚举类型定义了三个值:
  ：该类型的执行器没有特别的行为。它为每个语句的执行创建一个新的预处理语句。：该类型的执行器会复用预处理语句。：该类型的执行器会批量执行所有更新语句，如果 SELECT 在多个更新中间执行，将在必要时将多条更新语句分隔开来，以方便理解。 在 SqlSessionFactory 中还有一个方法我们没有提及，就是 getConfiguration()。这个方法会返回一个 Configuration 实例，你可以在运行时使用它来检查 MyBatis 的配置。
   如果你使用过 MyBatis 的旧版本，可能还记得 session、事务和批量操作是相互独立的。在新版本中则不是这样。上述三者都包含在 session 作用域内。你不必分别处理事务或批量操作就能得到想要的全部效果。
  正如之前所提到的，SqlSession 在 MyBatis 中是非常强大的一个类。它包含了所有执行语句、提交或回滚事务以及获取映射器实例的方法。SqlSession 类的方法超过了 20 个，为了方便理解，我们将它们分成几种组别。语句执行方法这些方法被用来执行定义在 SQL 映射 XML 文件中的 SELECT、INSERT、UPDATE 和 DELETE 语句。你可以通过名字快速了解它们的作用，每一方法都接受语句的 ID 以及参数对象，参数可以是原始类型（支持自动装箱或包装类）、JavaBean、POJO 或 Map。selectOne 和 selectList 的不同仅仅是 selectOne 必须返回一个对象或 null 值。如果返回值多于一个，就会抛出异常。如果你不知道返回对象会有多少，请使用 selectList。如果需要查看某个对象是否存在，最好的办法是查询一个 count 值（0 或 1）。selectMap 稍微特殊一点，它会将返回对象的其中一个属性作为 key 值，将对象作为 value 值，从而将多个结果集转为 Map 类型值。由于并不是所有语句都需要参数，所以这些方法都具有一个不需要参数的重载形式。
  游标（Cursor）与列表（List）返回的结果相同，不同的是，游标借助迭代器实现了数据的惰性加载。try (Cursor<MyEntity> entities = session.selectCursor(statement, param)) {
   for (MyEntity entity:entities) {
      // 处理单个实体
   }
}insert、update 以及 delete 方法返回的值表示受该语句影响的行数。最后，还有 select 方法的三个高级版本，它们允许你限制返回行数的范围，或是提供自定义结果处理逻辑，通常在数据集非常庞大的情形下使用。
  RowBounds 参数会告诉 MyBatis 略过指定数量的记录，并限制返回结果的数量。RowBounds 类的 offset 和 limit 值只有在构造函数时才能传入，其它时候是不能修改的。数据库驱动决定了略过记录时的查询效率。为了获得最佳的性能，建议将 ResultSet 类型设置为 SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE（换句话说：不要使用 FORWARD_ONLY）。ResultHandler 参数允许自定义每行结果的处理过程。你可以将它添加到 List 中、创建 Map 和 Set，甚至丢弃每个返回值，只保留计算后的统计结果。你可以使用 ResultHandler 做很多事，这其实就是 MyBatis 构建 结果列表的内部实现办法。ResultHandler从版本 3.4.6 开始， 会在存储过程的 REFCURSOR 输出参数中传递使用的  语句。它的接口很简单：ResultContext 参数允许你访问结果对象和当前已被创建的对象数目，另外还提供了一个返回值为 Boolean 的 stop 方法，你可以使用此 stop 方法来停止 MyBatis 加载更多的结果。使用 ResultHandler 的时候需要注意以下两个限制：使用带 ResultHandler 参数的方法时，收到的数据不会被缓存。当使用高级的结果映射集（resultMap）时，MyBatis 很可能需要数行结果来构造一个对象。如果你使用了 ResultHandler，你可能会接收到关联（association）或者集合（collection）中尚未被完整填充的对象。立即批量更新方法当你将  设置为  时，可以使用这个方法清除（执行）缓存在 JDBC 驱动类中的批量更新语句。事务控制方法
    有四个方法用来控制事务作用域。当然，如果你已经设置了自动提交或你使用了外部事务管理器，这些方法就没什么作用了。然而，如果你正在使用由 Connection 实例控制的 JDBC 事务管理器，那么这四个方法就会派上用场：
  默认情况下 MyBatis 不会自动提交事务，除非它侦测到调用了插入、更新、删除或 select with  enabled 方法改变了数据库。如果你没有使用这些方法提交修改，那么你可以在 commit 和 rollback 方法参数中传入 true 值，来保证事务被正常提交（注意，在自动提交模式或者使用了外部事务管理器的情况下，设置 force 值对 session 无效）。大部分情况下你无需调用 rollback()，因为 MyBatis 会在你没有调用 commit 时替你完成回滚操作。不过，当你要在一个可能多次提交或回滚的 session 中详细控制事务，回滚操作就派上用场了。 MyBatis-Spring 和 MyBatis-Guice 提供了声明式事务处理，所以如果你在使用 Mybatis 的同时使用了 Spring 或者 Guice，请参考它们的手册以获取更多的内容。本地缓存Mybatis 使用到了两种缓存：本地缓存（local cache）和二级缓存（second level cache）。每当一个新 session 被创建，MyBatis 就会创建一个与之相关联的本地缓存。任何在 session 执行过的查询结果都会被保存在本地缓存中，所以，当再次执行参数相同的相同查询时，就不需要实际查询数据库了。本地缓存将会在做出修改、事务提交或回滚，以及关闭 session 时清空。默认情况下，本地缓存数据的生命周期等同于整个 session 的周期。由于缓存会被用来解决循环引用问题和加快重复嵌套查询的速度，所以无法将其完全禁用。但是你可以通过设置 localCacheScope=STATEMENT 来只在语句执行时使用缓存。注意，如果 localCacheScope 被设置为 SESSION，对于某个对象，MyBatis 将返回在本地缓存中唯一对象的引用。对返回的对象（例如 list）做出的任何修改将会影响本地缓存的内容，进而将会影响到在本次 session 中从缓存返回的值。因此，不要对 MyBatis 所返回的对象作出更改，以防后患。你可以随时调用以下方法来清空本地缓存：确保 SqlSession 被关闭对于你打开的任何 session，你都要保证它们被妥善关闭，这很重要。保证妥善关闭的最佳代码模式是这样的：SqlSession session = sqlSessionFactory.openSession();
try (SqlSession session = sqlSessionFactory.openSession()) {
    // 假设下面三行代码是你的业务逻辑
    session.insert(...);
    session.update(...);
    session.delete(...);
    session.commit();
} 和 SqlSessionFactory 一样，你可以调用当前使用的 SqlSession 的 getConfiguration 方法来获得 Configuration 实例。使用映射器上述的各个 insert、update、delete 和 select 方法都很强大，但也有些繁琐，它们并不符合类型安全，对你的 IDE 和单元测试也不是那么友好。因此，使用映射器类来执行映射语句是更常见的做法。我们已经在之前的入门章节中见到过一个使用映射器的示例。一个映射器类就是一个仅需声明与 SqlSession 方法相匹配方法的接口。下面的示例展示了一些方法签名以及它们是如何映射到 SqlSession 上的。总之，每个映射器方法签名应该匹配相关联的 SqlSession 方法，字符串参数 ID 无需匹配。而是由方法名匹配映射语句的 ID。此外，返回类型必须匹配期望的结果类型，返回单个值时，返回类型应该是返回值的类，返回多个值时，则为数组或集合类，另外也可以是游标（Cursor）。所有常用的类型都是支持的，包括：原始类型、Map、POJO 和 JavaBean。 映射器接口不需要去实现任何接口或继承自任何类。只要方法签名可以被用来唯一识别对应的映射语句就可以了。 映射器接口可以继承自其他接口。在使用 XML 来绑定映射器接口时，保证语句处于合适的命名空间中即可。唯一的限制是，不能在两个具有继承关系的接口中拥有相同的方法签名（这是潜在的危险做法，不可取）。你可以传递多个参数给一个映射器方法。在多个参数的情况下，默认它们将会以 param 加上它们在参数列表中的位置来命名，比如：#{param1}、#{param2}等。如果你想（在有多个参数时）自定义参数的名称，那么你可以在参数上使用 @Param("paramName") 注解。你也可以给方法传递一个 RowBounds 实例来限制查询结果。映射器注解设计初期的 MyBatis 是一个 XML 驱动的框架。配置信息是基于 XML 的，映射语句也是定义在 XML 中的。而在 MyBatis 3 中，我们提供了其它的配置方式。MyBatis 3 构建在全面且强大的基于 Java 语言的配置 API 之上。它是 XML 和注解配置的基础。注解提供了一种简单且低成本的方式来实现简单的映射语句。 不幸的是，Java 注解的表达能力和灵活性十分有限。尽管我们花了很多时间在调查、设计和试验上，但最强大的 MyBatis 映射并不能用注解来构建——我们真没开玩笑。而 C# 属性就没有这些限制，因此 MyBatis.NET 的配置会比 XML 有更大的选择余地。虽说如此，基于 Java 注解的配置还是有它的好处的。注解如下表所示：注解使用对象XML 等价形式类implemetation为给定的命名空间（比如类）配置缓存。属性：
        指定参数值或占位符（placeholder）（该占位符能被  内的配置属性替换）。属性：。（仅在 MyBatis 3.4.2 以上可用）引用另外一个命名空间的缓存以供使用。注意，即使共享相同的全限定类名，在 XML 映射文件中声明的缓存仍被识别为一个独立的命名空间。属性：。如果你使用了这个注解，你应设置  或者  属性的其中一个。 属性用于指定能够表示该命名空间的 Java 类型（命名空间名就是该 Java 类型的全限定类名）， 属性（这个属性仅在 MyBatis 3.4.2 以上可用）则直接指定了命名空间的名字。方法收集一组结果以传递给一个结果对象的构造方法。属性：，它是一个  数组。ConstructorArgs 集合的一部分，代表一个构造方法参数。属性：。id 属性和 XML 元素  相似，它是一个布尔值，表示该属性是否用于唯一标识和比较对象。从版本 3.5.4 开始，该注解变为可重复注解。决定使用何种结果映射的一组取值（case）。属性：。cases 属性是一个  的数组。表示某个值的一个取值以及该取值对应的映射。属性：。results 属性是一个  的数组，因此这个注解实际上和  很相似，由下面的  注解指定。一组结果映射，指定了对某个特定结果列，映射到某个属性或字段的方式。属性：。value 属性是一个  注解的数组。而 id 属性则是结果映射的名称。从版本 3.5.4 开始，该注解变为可重复注解。在列和属性或字段之间的单个结果映射。属性： 相似，它是一个布尔值，表示该属性是否用于唯一标识和比较对象。one 属性是一个关联，和  类似，而 many 属性则是集合关联，和  类似。这样命名是为了避免产生名称冲突。复杂类型的单个属性映射。属性：
        ，指定可加载合适类型实例的映射语句（也就是映射器方法）全限定名；
        ，指定在该映射中覆盖全局配置参数 ；
        （3.5.5以上可用）, 结果集的完全限定名，该结果映射到查询结果中的集合对象；
        （3.5.5以上可用），在嵌套的结果集中对所查询的列进行分组的列前缀。
         注解 API 不支持联合映射。这是由于 Java 注解不允许产生循环引用。复杂类型的集合属性映射。属性：
        ，指定可加载合适类型实例集合的映射语句（也就是映射器方法）全限定名；
         ；
        （3.5.5以上可用），结果集的完全限定名，该结果映射到查询结果中的集合对象；
        供返回值为 Map 的方法使用的注解。它使用对象的某个属性作为 key，将对象 List 转化为 Map。属性：，指定作为 Map 的 key 值的对象属性名。映射语句的属性该注解允许你指定大部分开关和配置选项，它们通常在映射语句上作为属性出现。与在注解上提供大量的属性相比， 注解提供了一致、清晰的方式来指定选项。属性：。注意，Java 注解无法指定  值。因此，一旦你使用了  注解，你的语句就会被上述属性的默认值所影响。要注意避免默认值带来的非预期行为。
        （3.5.5以上可用）, 如果有一个配置好的 ,
        MyBatis 会加载不带  属性和带有匹配当前数据库  属性的所有语句。如果同时存在带  属性的相同语句，则后者会被舍弃。

        注意： 属性只在某些数据库中有效（如 Oracle、PostgreSQL 等）。要了解更多关于  和  可选值信息，请查看“insert, update 和 delete”一节。
        每个注解分别代表将会被执行的 SQL 语句。它们用字符串数组（或单个字符串）作为参数。如果传递的是字符串数组，字符串数组会被连接成单个完整的字符串，每个字符串之间加入一个空格。这有效地避免了用 Java 代码构建 SQL 语句时产生的“丢失空格”问题。当然，你也可以提前手动连接好字符串。属性：，指定用来组成单个 SQL 语句的字符串数组。
         属性的相同语句，则后者会被舍弃。
        
        允许构建动态 SQL。这些备选的 SQL 注解允许你指定返回 SQL 语句的类和方法，以供运行时执行。（从 MyBatis 3.4.6 开始，可以使用  代替  来作为返回类型）。当执行映射语句时，MyBatis 会实例化注解指定的类，并调用注解指定的方法。你可以通过  传递映射方法接收到的参数、"Mapper interface type" 和 "Mapper method"（仅在 MyBatis 3.4.5 以上支持）作为参数。（MyBatis 3.4 以上支持传入多个参数）
        属性：。
         属性用于指定类名
        ( 属性是  的别名, 你必须指定任意一个。
        但是你如果在全局配置中指定  ，两个属性都可以忽略)。
         用于指定该类的方法名（从版本 3.5.1 开始，可以省略  属性，MyBatis 将会使用  接口解析方法的具体实现。如果解析失败，MyBatis 将会使用名为  的降级实现）。 接下来的“SQL 语句构建器”一章将会讨论该话题，以帮助你以更清晰、更便于阅读的方式构建动态 SQL。
        如果你的映射方法接受多个参数，就可以使用这个注解自定义每个参数的名字。否则在默认情况下，除  以外的参数会以 "param" 加参数位置被命名。例如 。如果使用了 ，参数就会被命名为 
        这个注解的功能与  标签完全一致。该注解只能在  标注的方法上使用，否则将会被忽略。如果标注了  注解，MyBatis 将会忽略掉由  注解所设置的生成主键或设置（configuration）属性。属性： 以字符串数组形式指定将会被执行的 SQL 语句， 指定作为参数传入的对象对应属性的名称，该属性将会更新成新的值， 可以指定为  或  以指明 SQL 语句应被在插入语句的之前还是之后执行。 则指定  的 Java 类型。 则用于选择语句类型，可以选择  之一，它们分别对应于 。默认值是 这个注解为  或者  注解指定 XML 映射中  元素的 id。这使得注解的 select 可以复用已在 XML 中定义的 ResultMap。如果标注的 select 注解中存在  注解，这两个注解将被此注解覆盖。在使用了结果处理器的情况下，需要使用此注解。由于此时的返回类型为 void，所以 Mybatis 需要有一种方法来判断每一行返回的对象类型。如果在 XML 有对应的结果映射，请使用  注解。如果结果类型在 XML 的  元素中指定了，就不需要使用其它注解了。否则就需要使用此注解。比如，如果一个标注了 @Select 的方法想要使用结果处理器，那么它的返回类型必须是 void，并且必须使用这个注解（或者 @ResultMap）。这个注解仅在方法返回类型是 void 的情况下生效。如果使用了这个注解，定义在 Mapper 接口中的方法就能够调用  方法。（Mybatis 3.3 以上可用）映射注解示例这个例子展示了如何使用 @SelectKey 注解来在插入前读取数据库序列的值：这个例子展示了如何使用 @SelectKey 注解来在插入后读取数据库自增列的值：这个例子展示了如何使用  注解来调用 ：这些例子展示了如何通过指定 @Result 的 id 属性来命名结果集：这个例子展示了如何使用单个参数的 @SqlProvider 注解：这个例子展示了如何使用多个参数的 @SqlProvider 注解：@SelectProvider(type = UserSqlBuilder.class, method = "buildGetUsersByName")
List<User> getUsersByName(
    @Param("name") String name, @Param("orderByColumn") String orderByColumn);

class UserSqlBuilder {

  // 如果不使用 @Param，就应该定义与 mapper 方法相同的参数
  public static String buildGetUsersByName(
      final String name, final String orderByColumn) {
    return new SQL(){{
      SELECT("*");
      FROM("users");
      WHERE("name like #{name} || '%'");
      ORDER_BY(orderByColumn);
    }}.toString();
  }

  // 如果使用 @Param，就可以只定义需要使用的参数
  public static String buildGetUsersByName(@Param("orderByColumn") final String orderByColumn) {
    return new SQL(){{
      SELECT("*");
      FROM("users");
      WHERE("name like #{name} || '%'");
      ORDER_BY(orderByColumn);
    }}.toString();
  }
}这是一个在全局配置下让所有映射方法在同一个 sql provider 类里面的例子（3.5.6 后可用）:
Configuration configuration = new Configuration();
configuration.setDefaultSqlProviderType(TemplateFilePathProvider.class); // 让所有映射方法在同一个 sql provider 类里面
// ...
// 在 sql provider 注解上可以省略 type/value 属性
// 如果省略，MyBatis 将使用 defaultSqlProviderType 所指定的类
public interface UserMapper {

  @SelectProvider // 等价于 @SelectProvider(TemplateFilePathProvider.class)
  User findUser(int id);

  @InsertProvider // 等价于 @InsertProvider(TemplateFilePathProvider.class)
  void createUser(User user);

  @UpdateProvider // 等价于 @UpdateProvider(TemplateFilePathProvider.class)
  void updateUser(User user);

  @DeleteProvider // 等价于 @DeleteProvider(TemplateFilePathProvider.class)
  void deleteUser(int id);
}以下例子展示了 （3.5.1 后可用）的默认实现使用方法：
    @SelectProvider(UserSqlProvider.class)
List<User> getUsersByName(String name);

// 在你的 provider 类中实现 ProviderMethodResolver 接口
class UserSqlProvider implements ProviderMethodResolver {
  // 默认实现中，会将映射器方法的调用解析到实现的同名方法上
  public static String getUsersByName(final String name) {
    return new SQL(){{
      SELECT("*");
      FROM("users");
      if (name != null) {
        WHERE("name like #{value} || '%'");
      }
      ORDER_BY("id");
    }}.toString();
  }
}这个例子展现了如何在声明注解时使用  属性（3.5.5后可用）：
@Select(value = "SELECT SYS_GUID() FROM dual", databaseId = "oracle") // 如果 DatabaseIdProvider 提供的是 "oracle"，使用这条语句
@Select(value = "SELECT uuid_generate_v4()", databaseId = "postgres") // 如果 DatabaseIdProvider 提供的是 "postgres"，使用这条语句
@Select("SELECT RANDOM_UUID()") // 如果 DatabaseIdProvider 没有配置或者没有对应的 databaseId, 使用这条语句
String generateId();

  /Users/burakyetistiren/Desktop/Subject_Prog_CodeQL_Taint/src/main/java/db/src/site/zh_CN/xdoc/sqlmap-xml.xmlMyBatis 3 | XML 映射器XML 映射器MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的
      XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近
      95% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：
          – 该命名空间的缓存配置。
        
          – 引用其它命名空间的缓存配置。
        
          – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。
        
            – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。
          
          – 可被其它语句引用的可重用语句块。
        
          – 映射插入语句。
        
          – 映射更新语句。
        
          – 映射删除语句。
        
          – 映射查询语句。
        下一部分将从语句本身开始来描述每个元素的细节。查询语句是 MyBatis 中最常用的元素之一——光能把数据存到数据库中价值并不大，还要能重新取出来才有用，多数应用也都是查询比修改要频繁。
        MyBatis 的基本原则之一是：在每个插入、更新或删除操作之间，通常会执行多个查询操作。因此，MyBatis
        在查询和结果映射做了相当多的改进。一个简单查询的 select 元素是非常简单的。比如：
        
          这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个
          HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。
        注意参数符号：
          这就告诉 MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC
          中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：
        // 近似的 JDBC 代码，非 MyBatis 代码...
String selectPerson = "SELECT * FROM PERSON WHERE ID=?";
PreparedStatement ps = conn.prepareStatement(selectPerson);
ps.setInt(1,id);
          当然，使用 JDBC 就意味着使用更多的代码，以便提取结果并将它们映射到对象实例中，而这就是 MyBatis
          的拿手好戏。参数和结果映射的详细细节会分别在后面单独的小节中说明。
        
          select 元素允许你配置很多属性来配置每条语句的行为细节。
        Select 元素的属性
              在命名空间中唯一的标识符，可以被用来引用这条语句。
              
                将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为
                MyBatis 可以根据语句中实际传入的参数计算出应该使用的类型处理器（TypeHandler），默认值为未设置（unset）。
              
                  用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。
                
                期望从这条语句中返回结果的类全限定名或别名。
                注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。
                resultType 和 resultMap 之间只能同时使用一个。
              
                对外部 resultMap 的命名引用。结果映射是 MyBatis
                最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。
                resultType 和 resultMap 之间只能同时使用一个。
              
                将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。
              
                将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。
              
                这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。
              
                这是一个给驱动的建议值，尝试让驱动程序每次批量返回的结果行数等于这个设置值。
                默认值为未设置（unset）（依赖驱动）。
              
                可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用
                Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。
              
                FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或
                DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖数据库驱动）。
              
                如果配置了数据库厂商标识（databaseIdProvider），MyBatis
                会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。
              
                这个设置仅针对嵌套结果 select 语句：如果为
                true，则假设结果集以正确顺序（排序后）执行映射，当返回新的主结果行时，将不再发生对以前结果行的引用。
                这样可以减少内存消耗。默认值：。
              
                这个设置仅适用于多结果集的情况。它将列出语句执行后返回的结果集并赋予每个结果集一个名称，多个名称之间以逗号分隔。
              
          数据变更语句 insert，update 和 delete 的实现非常接近：
        Insert, Update, Delete 元素的属性在命名空间中唯一的标识符，可以被用来引用这条语句。用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。
                将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。
              这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。
              
                （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的
                getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。
              unset
               （仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用
                getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（）。如果生成列不止一个，可以用逗号分隔多个属性名称。
              
                （仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。
              
                如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带
                databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。
              下面是 insert，update 和 delete 语句的示例：如前所述，插入语句的配置规则更加丰富，在插入语句里面有一些额外的属性和子元素用来处理主键的生成，并且提供了多种生成方式。首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置为目标属性就 OK 了。例如，如果上面的 Author 表已经在 id 列上使用了自动生成，那么语句可以修改为：
          如果你的数据库还支持多行插入, 你也可以传入一个  数组或集合，并返回自动生成的主键。
        
          对于不支持自动生成主键列的数据库和可能不支持自动生成主键的 JDBC 驱动，MyBatis 有另外一种方法来生成主键。
        
          这里有一个简单（也很傻）的示例，它可以生成一个随机 ID（不建议实际使用，这里只是为了展示
          MyBatis 处理问题的灵活性和宽容度）：
        在上面的示例中，首先会运行 selectKey 元素中的语句，并设置 Author 的
        id，然后才会调用插入语句。这样就实现了数据库自动生成主键类似的行为，同时保持了 Java 代码的简洁。
        selectKey 元素描述如下：
        selectKey 元素的属性 语句结果应该被设置到的目标属性。如果生成列不止一个，可以用逗号分隔多个属性名称。
              
                返回结果集中生成列属性的列名。如果生成列不止一个，可以用逗号分隔多个属性名称。
              
                结果的类型。通常 MyBatis 可以推断出来，但是为了更加准确，写上也不会有什么问题。MyBatis
                允许将任何简单类型用作主键的类型，包括字符串。如果生成列不止一个，则可以使用包含期望属性的
                Object 或 Map。
              
                可以设置为 。如果设置为
                ，那么它首先会生成主键，设置  再执行插入语句。如果设置为
                ，那么先执行插入语句，然后是  中的语句 - 这和 Oracle
                数据库的行为相似，在插入语句内部可能有嵌入索引调用。
              
                和前面一样，MyBatis 支持 ，
                类型的映射语句，分别代表  和
                 类型。
              
          在一些特殊情况下，一些数据库允许 INSERT、UPDATE 或 DELETE 语句返回结果集（例如：PostgreSQL 和 MariaDB 数据库的  子句，或者是 MS SQL Server 的  子句）。这种类型的语句必须使用 ，用于映射返回的数据。
        
          这个元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。
          参数可以静态地（在加载的时候）确定下来，并且可以在不同的 include 元素中定义不同的参数值。比如：
        
          这个 SQL 片段可以在其它语句中使用，例如：
        
          也可以在 include 元素的 refid 属性或内部语句中使用属性值，例如：
        
          之前见到的所有语句都使用了简单的参数形式。但实际上，参数是 MyBatis
          非常强大的元素。对于大多数简单的使用场景，你都不需要使用复杂的参数，比如：
        Integer
          上面的这个示例说明了一个非常简单的命名参数映射。鉴于参数类型（parameterType）会被自动设置为
          ，这个参数可以随意命名。原始类型或简单数据类型（比如
          ）因为没有其它属性，会用它们的值来作为参数。
          然而，如果传入一个复杂的对象，行为就会有点不一样了。比如：
        
          如果 User 类型的参数对象传递到了语句中，会查找 id、username 和 password
          属性，然后将它们的值传入预处理语句的参数中。
        
          对传递语句参数来说，这种方式真是干脆利落。不过参数映射的功能远不止于此。
        
          首先，和 MyBatis 的其它部分一样，参数也可以指定一个特殊的数据类型。
        
          和 MyBatis 的其它部分一样，几乎总是可以根据参数对象的类型确定 javaType，除非该对象是一个
          。这个时候，你需要显式指定 
          来确保正确的类型处理器（）被使用。
        PreparedStatement.setNull() JDBC 要求，如果一个列允许使用 null
        值，并且会使用值为 null 的参数，就必须要指定 JDBC 类型（jdbcType）。阅读
        的 JavaDoc 来获取更多信息。
        
          要更进一步地自定义类型处理方式，可以指定一个特殊的类型处理器类（或别名），比如：
        参数的配置好像越来越繁琐了，但实际上，很少需要如此繁琐的配置。对于数值类型，还可以设置  指定小数点后保留的位数。INOUTINOUT
          最后，mode 属性允许你指定  或
           参数。如果参数的  为 
          或 ，将会修改参数对象的属性值，以便作为输出参数返回。
          如果 ），而且
          （也就是 Oracle 的
          REFCURSOR），你必须指定一个  引用来将结果集
           映射到参数的类型上。要注意这里的
           属性是可选的，如果留空并且 jdbcType 是
          ，它会被自动地被设为 
          MyBatis 也支持很多高级的数据类型，比如结构体（structs），但是当使用 out
          参数时，你必须显式设置类型的名称。比如（再次提示，在实际中要像这样不能换行）：
        
          尽管上面这些选项很强大，但大多时候，你只须简单指定属性名，顶多要为可能为空的列指定
          ，其他的事情交给 MyBatis 自己去推断就行了。
        
          字符串替换
        
          默认情况下，使用 
          参数语法时，MyBatis 会创建 
          参数占位符，并通过占位符安全地设置参数（就像使用 ? 一样）。
          这样做更安全，更迅速，通常也是首选做法，不过有时你就是想直接在 SQL 语句中直接插入一个不转义的字符串。
          比如 ORDER BY 子句，这时候你可以：
        这样，MyBatis 就不会修改或转义该字符串了。
@Select("select * from user where id = #{id}")
User findById(@Param("id") long id);

@Select("select * from user where name = #{name}")
User findByName(@Param("name") String name);

@Select("select * from user where email = #{email}")
User findByEmail(@Param("email") String email);

// 其它的 "findByXxx" 方法

          当 SQL 语句中的元数据（如表名或列名）是动态生成的时候，字符串替换将会非常有用。
          举个例子，如果你想  一个表任意一列的数据时，不需要这样写：
          
          而是可以只写这样一个方法：
          
          其中  会被直接替换，而  会使用  预处理。
          这样，就能完成同样的任务：
          
          这种方式也同样适用于替换表名的情况。
        
          用这种方式接受用户的输入，并用作语句参数是不安全的，会导致潜在的 SQL
          注入攻击。因此，要么不允许用户输入这些字段，要么自行转义并检验这些参数。
        Result_MapsResultSets 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90%
          的 JDBC  数据提取代码中解放出来，并在一些情形下允许你进行一些
          JDBC 不支持的操作。实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份
           能够代替实现同等功能的数千行代码。ResultMap
          的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。
        
          之前你已经见过简单映射语句的示例，它们没有显式指定 。比如：
        
      上述语句只是简单地将所有的列映射到  的键上，这由  属性指定。虽然在大部分情况下都够用，但是 HashMap 并不是一个很好的领域模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为领域模型。MyBatis 对两者都提供了支持。看看下面这个 JavaBean：
        
          基于 JavaBean 的规范，上面这个类有 3 个属性：id，username 和
          hashedPassword。这些属性会对应到 select 语句中的列名。
        
          这样的一个 JavaBean 可以被映射到 ，就像映射到
           一样简单。
        
          类型别名是你的好帮手。使用它们，你就可以不用输入类的全限定名了。比如：
        <!-- mybatis-config.xml 中 -->
<typeAlias type="com.someapp.model.User" alias="User"/>

<!-- SQL 映射 XML 中 -->
<select id="selectUsers" resultType="User">
  select id, username, hashedPassword
  from some_table
  where id = #{id}
</select>
          在这些情况下，MyBatis 会在幕后自动创建一个 ，再根据属性名来映射列到
          JavaBean 的属性上。如果列名和属性名不能匹配上，可以在 SELECT
          语句中设置列别名（这是一个基本的 SQL 特性）来完成匹配。比如：
        
          在学习了上面的知识后，你会发现上面的例子没有一个需要显式配置
          ，这就是 
          的优秀之处——你完全可以不用显式地配置它们。
          虽然上面的例子不用显式配置 。
          但为了讲解，我们来看看如果在刚刚的示例中，显式使用外部的
           会怎样，这也是解决列名不匹配的另外一种方式。
        
          然后在引用它的语句中设置  属性就行了（注意我们去掉了
           属性）。比如:
        
          如果这个世界总是这么简单就好了。
        高级结果映射
          MyBatis 创建时的一个思想是：数据库不可能永远是你所想或所需的那个样子。
          我们希望每个数据库都具备良好的第三范式或 BCNF 范式，可惜它们并不都是那样。
          如果能有一种数据库映射模式，完美适配所有的应用程序，那就太好了，但可惜也没有。
          而 ResultMap 就是 MyBatis 对这个问题的答案。
        
          比如，我们如何映射下面这个语句？
        <!-- 非常复杂的语句 -->
<select id="selectBlogDetails" resultMap="detailedBlogResultMap">
  select
       B.id as blog_id,
       B.title as blog_title,
       B.author_id as blog_author_id,
       A.id as author_id,
       A.username as author_username,
       A.password as author_password,
       A.email as author_email,
       A.bio as author_bio,
       A.favourite_section as author_favourite_section,
       P.id as post_id,
       P.blog_id as post_blog_id,
       P.author_id as post_author_id,
       P.created_on as post_created_on,
       P.section as post_section,
       P.subject as post_subject,
       P.draft as draft,
       P.body as post_body,
       C.id as comment_id,
       C.post_id as comment_post_id,
       C.name as comment_name,
       C.comment as comment_text,
       T.id as tag_id,
       T.name as tag_name
  from Blog B
       left outer join Author A on B.author_id = A.id
       left outer join Post P on B.id = P.blog_id
       left outer join Comment C on P.id = C.post_id
       left outer join Post_Tag PT on PT.post_id = P.id
       left outer join Tag T on PT.tag_id = T.id
  where B.id = #{id}
</select>
          你可能想把它映射到一个智能的对象模型，这个对象表示了一篇博客，它由某位作者所写，有很多的博文，每篇博文有零或多条的评论和标签。
          我们先来看看下面这个完整的例子，它是一个非常复杂的结果映射（假设作者，博客，博文，评论和标签都是类型别名）。
          不用紧张，我们会一步一步地来说明。虽然它看起来令人望而生畏，但其实非常简单。
        <!-- 非常复杂的结果映射 -->
<resultMap id="detailedBlogResultMap" type="Blog">
  <constructor>
    <idArg column="blog_id" javaType="int"/>
  </constructor>
  <result property="title" column="blog_title"/>
  <association property="author" javaType="Author">
    <id property="id" column="author_id"/>
    <result property="username" column="author_username"/>
    <result property="password" column="author_password"/>
    <result property="email" column="author_email"/>
    <result property="bio" column="author_bio"/>
    <result property="favouriteSection" column="author_favourite_section"/>
  </association>
  <collection property="posts" ofType="Post">
    <id property="id" column="post_id"/>
    <result property="subject" column="post_subject"/>
    <association property="author" javaType="Author"/>
    <collection property="comments" ofType="Comment">
      <id property="id" column="comment_id"/>
    </collection>
    <collection property="tags" ofType="Tag" >
      <id property="id" column="tag_id"/>
    </collection>
    <discriminator javaType="int" column="draft">
      <case value="1" resultType="DraftPost"/>
    </discriminator>
  </collection>
</resultMap> 元素有很多子元素和一个值得深入探讨的结构。
          下面是 元素的概念视图。
        结果映射（resultMap） - ID 参数；标记出作为 ID 的结果可以帮助提高整体性能 - 将被注入到构造方法的一个普通结果 - 用于在实例化类时，注入结果到构造方法中
             – 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能 – 注入到字段或 JavaBean 属性的普通结果嵌套结果映射 – 关联可以是  元素，或是对其它结果映射的引用 – 一个复杂类型的关联；许多结果将包装成这种类型
            嵌套结果映射 – 集合可以是  – 一个复杂类型的集合
            嵌套结果映射 –  也是一个结果映射，因此具有相同的结构和元素；或者引用其它的结果映射 – 基于某些值的结果映射
                 – 使用结果值来决定使用哪个 ResultMap 的属性列表当前命名空间中的一个唯一标识，用于标识一个结果映射。
                类的完全限定名, 或者一个类型别名（关于内置的类型别名，可以参考上面的表格）。
              
                如果设置这个属性，MyBatis 将会为本结果映射开启或者关闭自动映射。
                这个属性会覆盖全局的属性 autoMappingBehavior。默认值：未设置（unset）。
              最佳实践
          最好逐步建立结果映射。单元测试可以在这个过程中起到很大帮助。
          如果你尝试一次性创建像上面示例那么巨大的结果映射，不仅容易出错，难度也会直线上升。
          所以，从最简单的形态开始，逐步迭代。而且别忘了单元测试！
          有时候，框架的行为像是一个黑盒子（无论是否开源）。因此，为了确保实现的行为与你的期望相一致，最好编写单元测试。
          并且单元测试在提交 bug 时也能起到很大的作用。
        
          下一部分将详细说明每个元素。
        id & result
          这些元素是结果映射的基础。
          元素都将一个列的值映射到一个简单数据类型（String, int, double, Date
          等）的属性或字段。
        
          这两者之间的唯一不同是，
          元素对应的属性会被标记为对象的标识符，在比较对象实例时使用。
          这样可以提高整体的性能，尤其是进行缓存和嵌套结果映射（也就是连接映射）的时候。
        
          两个元素都有一些属性：
        Id 和 Result 的属性
                映射到列结果的字段或属性。如果 JavaBean
                有这个名字的属性（property），会先使用该属性。否则 MyBatis 将会寻找给定名称的字段（field）。
                无论是哪一种情形，你都可以使用常见的点式分隔形式进行复杂属性导航。
                比如，你可以这样映射一些简单的东西：“username”，或者映射到一些复杂的东西上：“address.street.number”。
              resultSet.getString(columnName)
                数据库中的列名，或者是列的别名。一般情况下，这和传递给
                 方法的参数一样。
              
                一个 Java 类的全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。
                如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是
                HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。
              
                JDBC 类型，所支持的 JDBC 类型参见这个表格之后的“支持的 JDBC 类型”。
                只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是
                JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC
                编程，你需要对可以为空值的列指定这个类型。
              
                我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。
                这个属性值是一个类型处理器实现类的全限定名，或者是类型别名。
              支持的 JDBC 类型
          为了以后可能的使用场景，MyBatis 通过内置的 jdbcType 枚举类型支持下面的 JDBC 类型。
        构造方法
          通过修改对象属性的方式，可以满足大多数的数据传输对象（Data Transfer Object,
          DTO）以及绝大部分领域模型的要求。但有些情况下你想使用不可变类。
          一般来说，很少改变或基本不变的包含引用或数据的表，很适合使用不可变类。
          构造方法注入允许你在初始化时为类设置属性的值，而不用暴露出公有方法。MyBatis
          也支持私有属性和私有 JavaBean 属性来完成注入，但有一些人更青睐于通过构造方法进行注入。
           元素就是为此而生的。
        
          看看下面这个构造方法:
        
          为了将结果注入构造方法，MyBatis 需要通过某种方式定位相应的构造方法。
          在下面的例子中，MyBatis 搜索一个声明了三个形参的构造方法，参数类型以
           和
           的顺序给出。
        
          当你在处理一个带有多个形参的构造方法时，很容易搞乱 arg 元素的顺序。
          从版本 3.4.3 开始，可以在指定参数名称的前提下，以任意顺序编写 arg 元素。
          为了通过名称来引用构造方法参数，你可以添加  注解，或者使用
          '-parameters' 编译选项并启用 
          选项（默认开启）来编译项目。下面是一个等价的例子，尽管函数签名中第二和第三个形参的顺序与
          constructor 元素中参数声明的顺序不匹配。
        
          如果存在名称和类型相同的可写属性，那么可以省略  。
        
          剩余的属性和规则和普通的 id 和 result 元素是一样的。
        
                一个 Java 类的完全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。
                如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是
                HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。
              
                JDBC 类型，所支持的 JDBC 类型参见这个表格之前的“支持的 JDBC 类型”。
                只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是
                JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC
                编程，你需要对可能存在空值的列指定这个类型。
              
                我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。
                这个属性值是一个类型处理器实现类的完全限定名，或者是类型别名。
              
                用于加载复杂类型属性的映射语句的 ID，它会从 column
                属性中指定的列检索数据，作为参数传递给此 select 语句。具体请参考关联元素。
              
                结果映射的 ID，可以将嵌套的结果集映射到一个合适的对象树中。
                它可以作为使用额外 select 语句的替代方案。它可以将多表连接操作的结果映射成一个单一的
                。这样的 
                将会将包含重复或部分数据重复的结果集。为了将结果集正确地映射到嵌套的对象树中，MyBatis
                允许你 “串联”结果映射，以便解决嵌套结果集的问题。想了解更多内容，请参考下面的关联元素。
              
                构造方法形参的名字。从 3.4.3 版本开始，通过指定具体的参数名，你可以以任意顺序写入
                arg 元素。参看上面的解释。
              关联
          关联（association）元素处理“有一个”类型的关系。
          比如，在我们的示例中，一个博客有一个用户。关联结果映射和其它类型的映射工作方式差不多。
          你需要指定目标属性名以及属性的（很多时候 MyBatis
          可以自己推断出来），在必要的情况下你还可以设置 JDBC
          类型，如果你想覆盖获取结果值的过程，还可以设置类型处理器。
        
          关联的不同之处是，你需要告诉 MyBatis 如何加载关联。MyBatis 有两种不同的方式加载关联：
        
            嵌套 Select 查询：通过执行另外一个 SQL 映射语句来加载期望的复杂类型。
          
            嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集。
          
          首先，先让我们来看看这个元素的属性。你将会发现，和普通的结果映射相比，它只在 select 和 resultMap 属性上有所不同。
        
                映射到列结果的字段或属性。如果用来匹配的 JavaBean
                存在给定名字的属性，那么它将会被使用。否则 MyBatis 将会寻找给定名称的字段。
                无论是哪一种情形，你都可以使用通常的点式分隔形式进行复杂属性导航。
                比如，你可以这样映射一些简单的东西：“username”，或者映射到一些复杂的东西上：“address.street.number”。
              
                JDBC 类型，所支持的 JDBC 类型参见这个表格之前的“支持的 JDBC 类型”。
                只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是
                JDBC 的要求而非 MyBatis 的要求。如果你直接面向
                JDBC 编程，你需要对可能存在空值的列指定这个类型。
              关联的嵌套 Select 查询column="{prop1=col1,prop2=col2}"prop1prop2
              数据库中的列名，或者是列的别名。一般情况下，这和传递给
               方法的参数一样。
              注意：在使用复合主键的时候，你可以使用 
              这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得
               作为参数对象，被设置为对应嵌套 Select 语句的参数。
              
                用于加载复杂类型属性的映射语句的 ID，它会从 column
                属性指定的列中检索数据，作为参数传递给目标 select 语句。
                具体请参考下面的例子。注意：在使用复合主键的时候，你可以使用
                 这样的语法来指定多个传递给嵌套
                Select 查询语句的列名。这会使得 
                作为参数对象，被设置为对应嵌套 Select 语句的参数。
              
                可选的。有效值为 。
                指定属性后，将在映射中忽略全局配置参数 ，使用属性的值。
              
          示例：
        selectAuthor
          就是这么简单。我们有两个 select
          查询语句：一个用来加载博客（Blog），另外一个用来加载作者（Author），而且博客的结果映射描述了应该使用
           语句加载它的 author 属性。
        
          其它所有的属性将会被自动加载，只要它们的列名和属性名相匹配。
        
          这种方式虽然很简单，但在大型数据集或大型数据表上表现不佳。这个问题被称为“N+1 查询问题”。
          概括地讲，N+1 查询问题是这样子的：
        你执行了一个单独的 SQL 语句来获取结果的一个列表（就是“+1”）。对列表返回的每条记录，你执行一个 select 查询语句来为每条记录加载详细信息（就是“N”）。
          
          这个问题会导致成百上千的 SQL 语句被执行。有时候，我们不希望产生这样的后果。
        
          好消息是，MyBatis 能够对这样的查询进行延迟加载，因此可以将大量语句同时运行的开销分散开来。
          然而，如果你加载记录列表之后立刻就遍历列表以获取嵌套的数据，就会触发所有的延迟加载查询，性能可能会变得很糟糕。
        
          所以还有另外一种方法。
        关联的嵌套结果映射
                结果映射的 ID，可以将此关联的嵌套结果集映射到一个合适的对象树中。
                它可以作为使用额外 select 语句的替代方案。它可以将多表连接操作的结果映射成一个单一的
                 有部分数据是重复的。
                为了将结果集正确地映射到嵌套的对象树中, MyBatis
                允许你“串联”结果映射，以便解决嵌套结果集的问题。使用嵌套结果映射的一个例子在表格以后。
              
                当连接多个表时，你可能会不得不使用列别名来避免在 
                中产生重复的列名。指定 columnPrefix 列名前缀允许你将带有这些前缀的列映射到一个外部的结果映射中。
                详细说明请参考后面的例子。
              
                默认情况下，在至少一个被映射到属性的列不为空时，子对象才会被创建。
                你可以在这个属性上指定非空的列来改变默认行为，指定后，Mybatis
                将只在这些列中任意一列非空时才创建一个子对象。可以使用逗号分隔来指定多个列。默认值：未设置（unset）。
              
                如果设置这个属性，MyBatis 将会为本结果映射开启或者关闭自动映射。
                这个属性会覆盖全局的属性 autoMappingBehavior。注意，本属性对外部的结果映射无效，所以不能搭配
                 元素使用。默认值：未设置（unset）。
              
          之前，你已经看到了一个非常复杂的嵌套关联的例子。
          下面的例子则是一个非常简单的例子，用于演示嵌套结果映射如何工作。
          现在我们将博客表和作者表连接在一起，而不是执行一个独立的查询语句，就像这样：
        
          注意查询中的连接，以及为确保结果能够拥有唯一且清晰的名字，我们设置的别名。
          这使得进行映射非常简单。现在我们可以映射这个结果：
        
          在上面的例子中，你可以看到，博客（Blog）作者（author）的关联元素委托名为
          “authorResult” 的结果映射来加载作者对象的实例。
        非常重要：
          id 元素在嵌套结果映射中扮演着非常重要的角色。你应该总是指定一个或多个可以唯一标识结果的属性。
          虽然，即使不指定这个属性，MyBatis 仍然可以工作，但是会产生严重的性能问题。
          只需要指定可以唯一标识结果的最少属性。显然，你可以选择主键（复合主键也可以）。
        
          现在，上面的示例使用了外部的结果映射元素来映射关联。这使得 Author 的结果映射可以被重用。
          然而，如果你不打算重用它，或者你更喜欢将你所有的结果映射放在一个具有描述性的结果映射元素中。
          你可以直接将结果映射作为子元素嵌套在内。这里给出使用这种方式的等效例子：
        
          那如果博客（blog）有一个共同作者（co-author）该怎么办？select 语句看起来会是这样的：
        
          回忆一下，Author 的结果映射定义如下：
        
          由于结果中的列名与结果映射中的列名不同。你需要指定 
          以便重复使用该结果映射来映射 co-author 的结果。
        关联的多结果集（ResultSet）
                当使用多个结果集时，该属性指定结果集中用于与 
                匹配的列（多个列名以逗号隔开），以识别关系中的父类型与子类型。
              
                指定外键对应的列名，指定的列将与父类型中  的给出的列进行匹配。
              
                指定用于加载复杂类型的结果集名字。
              从版本 3.2.3 开始，MyBatis 提供了另一种解决 N+1 查询问题的方法。
          某些数据库允许存储过程返回多个结果集，或一次性执行多个语句，每个语句返回一个结果集。
          我们可以利用这个特性，在不使用连接的情况下，只访问数据库一次就能获得相关数据。
        在例子中，存储过程执行下面的查询并返回两个结果集。第一个结果集会返回博客（Blog）的结果，第二个则返回作者（Author）的结果。在映射语句中，必须通过  属性为每个结果集指定一个名字，多个名字使用逗号隔开。
          现在我们可以指定使用 “authors” 结果集的数据来填充 “author” 关联：
        
          你已经在上面看到了如何处理“有一个”类型的关联。但是该怎么处理“有很多个”类型的关联呢？这就是我们接下来要介绍的。
        集合
          集合元素和关联元素几乎是一样的，它们相似的程度之高，以致于没有必要再介绍集合元素的相似部分。
          所以让我们来关注它们的不同之处吧。
        
          我们来继续上面的示例，一个博客（Blog）只有一个作者（Author)。但一个博客有很多文章（Post)。
          在博客类中，这可以用下面的写法来表示：
        
          要像上面这样，映射嵌套结果集合到一个 List 中，可以使用集合元素。
          和关联元素一样，我们可以使用嵌套 Select 查询，或基于连接的嵌套结果映射集合。
        集合的嵌套 Select 查询
          首先，让我们看看如何使用嵌套 Select 查询来为博客加载文章。
        
          你可能会立刻注意到几个不同，但大部分都和我们上面学习过的关联元素非常相似。
          首先，你会注意到我们使用的是集合元素。
          接下来你会注意到有一个新的 “ofType” 属性。这个属性非常重要，它用来将
          JavaBean（或字段）属性的类型和集合存储的类型区分开来。
          所以你可以按照下面这样来阅读映射：
        读作： “posts 是一个存储 Post 的 ArrayList 集合”
        
          在一般情况下，MyBatis 可以推断 javaType 属性，因此并不需要填写。所以很多时候你可以简略成：
        集合的嵌套结果映射
          现在你可能已经猜到了集合的嵌套结果映射是怎样工作的——除了新增的 “ofType” 属性，它和关联的完全相同。
        首先, 让我们看看对应的 SQL 语句：
          我们再次连接了博客表和文章表，并且为每一列都赋予了一个有意义的别名，以便映射保持简单。
          要映射博客里面的文章集合，就这么简单：
        
          再提醒一次，要记得上面 id 元素的重要性，如果你不记得了，请阅读关联部分的相关部分。
        
          如果你喜欢更详略的、可重用的结果映射，你可以使用下面的等价形式：
        集合的多结果集（ResultSet）
          像关联元素那样，我们可以通过执行存储过程实现，它会执行两个查询并返回两个结果集，一个是博客的结果集，另一个是文章的结果集：
        我们指定 “posts” 集合将会使用存储在 “posts” 结果集中的数据进行填充： 注意
          对关联或集合的映射，并没有深度、广度或组合上的要求。     Ͳ2    